<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Avisynth Video Filtering" />
<title>Simple MDegrain Mod&nbsp;&mdash;&nbsp;SMDegrain()</title>
<link rel="stylesheet" type="text/css" href="avisynth.css" />
</head>

<body>

<h1>Simple MDegrain Mod&nbsp;&mdash;&nbsp;SMDegrain()</h1>

<p>&nbsp;</p>
<h2>Abstract</h2>

<p>
<b>Author: </b>Dogway<br/>
<b>Version: </b>v3.2.0d RC1<br/>
<b>Download: </b><a href="http://forum.videohelp.com/threads/369142" target="_blank">http://forum.videohelp.com/threads/369142</a><br/>
<b>Category: </b>Temporal Denoiser Script Function<br/>
<b>Date:</b> 30-May-2021
</p>
<p>&nbsp;</p>
<h2><a id="up"></a>Table of contents</h2>
<ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#aknowledgements">Aknowledgements</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#workflow">Quick Workflow Guide</a></li>
<li><a href="#parameters">Parameters Description:</a> <a href="#basic">Basic</a>, <a href="#16bit">High Bit Depth</a>, <a href="#advanced">Advanced</a></li>
<li><a href="#finalnotes">Final Notes</a></li>
<li><a href="#examples">Example Scripts</a></li>
<li><a href="#changelog">Changelog</a></li>
</ul>
<p>&nbsp;</p>
<h2><a id="dependencies"></a>Dependencies&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<b>Required<br/></b>
MaskTools2 and one of the MVTools2 plugins (mod versions recommended)
<ul>
	<li><b><a href="http://forum.doom9.org/showthread.php?t=98985" target="_blank">MaskTools2</a></b> (v2a48 or higher) or <a href="http://forum.doom9.org/showpost.php?p=1423459" target="_blank">Vit's mod</a>** or <a href="http://forum.doom9.org/showthread.php?p=1655989#post1655989" target="_blank">tp7's mod</a>*  (recommended)</li>
	<li><b><a href="http://avisynth.org.ru/mvtools/mvtools2.html" target="_blank">MVTools2</a></b> (v2.5.11.3 or higher) or...</li>
	    <b><a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">MVTools2 mod</a></b> (v2.6.0.5 or higher)   (for tr > 3 or 16 bit processing <i>*multithreading and some other features & bugfixes</i>)<br/>
</ul>
<b>Optional<br/></b>
Use <a href="http://forum.doom9.org/showpost.php?p=1423459" target="_blank">Vit's plugin mods</a> or better yet <a href="http://forum.doom9.org/showthread.php?p=1655989#post1655989" target="_blank">tp7's plugin mods*</a> when possible for more MT stability and bugfixes:<br/>
<ul>
  <li><b><a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">Dither</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by cretindesalpes</i>&nbsp;&nbsp;&nbsp;(for 16 bit processing, and for <var>prefilter=</var>4) <i>v1.27.0 or higher. Requires MVTools2 mod which is bundled in the .zip.</i></li>
	<li><b><a href="http://avisynth.org/mediawiki/Removegrain" target="_blank">Repair</a> (<a href="http://forum.doom9.org/showthread.php?p=1655989#post1655989" target="_blank">tp7's*</a>)</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by kassandro</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>contrasharp=</var>true)</li>
	<li><b><a href="http://avisynth.org/mediawiki/Removegrain" target="_blank">RemoveGrain</a> (<a href="http://forum.doom9.org/showthread.php?p=1655989#post1655989" target="_blank">tp7's*</a>)</b>&nbsp;<i>by kassandro</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>contrasharp=</var>true or <var>prefilter=</var>1 or 2)</li>
    <li><b><a href="http://www.removegrainhd.de.tf/" target="_blank">RemoveGrainHD</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by kassandro</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>prefilter=</var>2, or <var>contrasharp=</var>true in HD inputs)</li>
	<li><b><a href="http://avisynth.org/mediawiki/LSFmod" target="_blank">LSFmod</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by LaTo</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>contrasharp</var> > 0.0. "Script")</li>
	<li><b><a href="http://avisynth.org/mediawiki/Removegrain" target="_blank">SSE2Tools</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by kassandro</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for YUY2 support)**</li>
	<li><b><a href="http://web.missouri.edu/~kes25c/" target="_blank">nnedi3</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by tritical</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>subpixel=</var>3)</li>
	<li><b><a href="http://web.missouri.edu/~kes25c/" target="_blank">Dfttest</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by tritical</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>prefilter=</var>3) <i>*Use the one included in Dither when filtering in 16bit</i></li>
	<li><b><a href="http://forum.doom9.org/showthread.php?t=171379" target="_blank">KNLmeansCL</a></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>by Khanattila</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for <var>prefilter=</var>4)***</li>
</ul>
<i>&nbsp;&nbsp;&nbsp;&nbsp;* Beware, <a href="http://forum.doom9.org/showthread.php?p=1655989#post1655989" target="_blank">tp7's plugin mods</a> have no YUY2 support, require AviSynth 2.6a5 or latest Set's MT for v2.6, and Visual C++ 2012 Redistributable.</i><br/>
<i>&nbsp;&nbsp;&nbsp;&nbsp;** YUY2 support is broken on every iteration of masktools in the 2.6 branch, use Vit's mt_masktools-25 (even for 2.6 avsiynth) for the latest working version of masktools with YUY2</i><br/>
<i>&nbsp;&nbsp;&nbsp;&nbsp;*** It requires you to have your card's CL drivers installed (for either NVidia or AMD) and Visual C++ 2013 Redistributable (x86).</i>
<p>&nbsp;</p>
<h2><a id="aknowledgements"></a>Aknowledgements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<a href="http://forum.doom9.org/showthread.php?t=152326" target="_blank">Original SMDegrain()</a> by Caroliano<br/><br/>
This function uses code from Didée, and cretindesalpes' creations,
and has parts inspired by LaTo's functions (old readme, Show panel, etc)
and Jawed's Killer() function, as well as relying on third-party tools for certain features.<br/><br/>
Special thanks go to: cretindesalpes, Didée, Gavino, Sagekilla, and MVtools people.
<p>&nbsp;</p>
<h2><a id="introduction"></a>Introduction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
SMDegrain is not a magic function, but rather a convenient one ("magic" if any comes from the internal mvtools plugin). It just takes the reiterative code blocks needed for mvtools+mdegrain denoising and wraps them into this function. It has internal switches for when you deal with interlaced or YUY2 content, so all you need is to enable the parameter in the function argument, saving you from writting long lines of code and preventing from easy-to-commit mistakes. YUY2 is automatically detected so it even doesn't need to be actively enabled. Besides that it adds some small and well founded enhancements listed below, like ability for the so much discussed <var>prefilter</var>s, slightly better motion vectors (thanks to an internal TV->PC luma expansion), option for nnedi3 <var>subpixel</var> accuracy, <var>globals</var> import/export, some dark luma enhancement parameters (for better motion vectors, not the actual clip), <var>show</var> panel, and <var>contrasharp</var> option, among others:<br/>
<br/>
<b>High bitdepth denoising:</b> This is the first wrapper function to support 32bit (16bit pipeline) MDegrain denoising.<br/>
<b>Higher temporal radius (tr>3):</b> As the above feature the mvtools2 mod allows (and hence this script) for for hack-free higher temporal radius.<br/>
<b>Contrasharpening:</b> The pretty much standarized sharpening method created by Didée is blended into the function, so you can easily use it in 16bit pipelines. An strength biased method is also possible. A <var>CClip</var> parameter is also supplied so you can choose another source to sharpen from, other than the default <var>SMDegrain()</var> input.<br/>
<b>YUY2 support:</b> It automatically supports YUY2 sources for all the given parameters.<br/>
<b>Interlaced support:</b> It supports <var>interlaced</var> sources, for YUY2 color spaces and most parameters as well.<br/>
<b>Extended Subpixel Accuracy:</b> nnedi3 is added as the 4th option for this setting, not strictly necessary in most cases, but if you are a quality mad try to set it on.<br/>
<b>Better Motion Vectors:</b> An internal conversion from TV levels (16-235) to PC levels (0-255) is done to the clip the motion analysis will be performed on, so you can get better motion vectors (up to 16%)<br/>
<b>Prefilters:</b> An easy parameter to load generalist <var>prefilter</var>s that perform well in most situations. It also accepts loading your personal <var>prefilter</var>ed clips.<br/>
<b>Motion Filters:</b> New since version 3.0d. It will allow you to filter those parts where <var>SMDegrain()</var> couldn't find a matching block, or in other words motion areas where <var>SMDegrain()</var> couldn't denoise. One use for it would be spatial denoisers or deblockers since motion areas are prone to heavy blocking and artifacts.<br/>
<b>Motion Vectors Globals Input/Output:</b> Reuse motion vectors <var>globals</var> for faster processing, or just use <var>SMDegrain()</var> as a shortcut for creating nice quality motion vectors.<br/>
<b>RefineMotion Option (MRecalculate):</b> If time is not an issue, you should use this one for a quality boost.<br/>
<b>Show Panel:</b> Everything is off by default, but some settings change in context (i.e. when in HD). Check what is happening behind the scenes and have a fast look at all your settings.<br/>
<b>Robust:</b> Everything listed above works together with each other indistinctly (interoperability). In the process some error proof, bugfixes and bug workarounds were implemented or at least warned so you know that most of what is done is reliable, bugs free, carefree and optimized. The general idea is to serve as an user friendly front end for vanilla mvtools2+mdegrain or as the original script creator entitled <i>"To make your scripts shorter and less geeky"</i>. Most parameters are turned off or defaulted to mvtools2 defaults or close. Features are based on popular general conceived good practices and time tested procedures.<br/>
<br/>
Parameters are arranged in 3 blocks.<br/>
<br/>
<b><a href="#basic">Basic:</a></b> For people who just need the most basic parameters because either they don't have the time, knowledge or interest into looking for complex settings. Or they are content with defaults (pretty much mvtools defaults)<br/>
<b><a href="#16bit">High Bit Depth:</a></b> There's not much to think about this. This just enables (default is disabled), high bit depth denoising. That is, more quality, but also needs more processing power hence slower.<br/>
<b><a href="#advanced">Advanced:</a></b> If you run into some problems, are nitpicking or just want to fine tune your settings according to the source, have a look at this block, it contains the rest and bulk of the function parameters.<br/>
<br/>
<br/>
Temporal denoising is a widespread procedure for noise cleaning in most type of video sources. The only limitation for <var>SMDegrain()</var> being when there are (very) high levels of grain, in which case you would need to rely on more "creative" and source centric solutions (see <a href="http://forum.doom9.org/showthread.php?p=1544619#post1544619" target="_blank">this</a> and <var>prefilter</var> notes), but those are the rare cases.<br/>
<br/>
To picture what the function does, a simple <var>SMDegrain()</var> call matches the next code (for SD resolutions):<br/>
<br/>
<pre>
super_search = Dither_Luma_Rebuild(S0=1.0,c=0.0625).MSuper(rfilter=4)

bv2 = super_search.MAnalyse(isb = true,  delta = 2, overlap= 4)
bv1 = super_search.MAnalyse(isb = true,  delta = 1, overlap= 4)
fv1 = super_search.MAnalyse(isb = false, delta = 1, overlap= 4)
fv2 = super_search.MAnalyse(isb = false, delta = 2, overlap= 4)

MDegrain2(MSuper(levels=1), bv1, fv1, bv2, fv2, thSAD=300, thSADC=150)</pre><br/>
<br/>
As you see no wizardry. The only changes made are the TV->PC luma expansion (Dither_Luma_Rebuild(S0=1.0,c=0.0625) similar to color_yuv(levels="TV->PC")) so you have more range to detect motion vectors, the rfilter=4 for a bit more quality super search, the changed default of <var>overlap</var> from 0 to 4 and <var>thSAD</var> and <var>thSADC</var> from 400 to 300 and 150 respectively for safer results. Nothing else. The problem is that as soon you want to change a little thing like say temporal radius it requires you to edit in more than a few places, so this is very annoying and so forth the main reason for <var>SMDegrain()</var>.<br/>

<p>&nbsp;</p>
<h2><a id="workflow"></a>Quick Workflow Guide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<ul>
    <li>Input can be YV12 or YUY2 (interleaved YUY2 which is the common standard format)</li>
    <li>Input luma must <b>NOT</b> be PC range (sources normally are in TV range). It's also recommended to be in modulus 16 size (resolution multiple of 16), although not strictly necessary </li>
	<li>Crop if necessary before <var>SMDegrain()</var> (when not <var>interlaced</var>)</li>
	<li>Recommended to deblock if blocking is present, before crop (when cropping) and <var>SMDegrain()</var>. Or you can use <var>prefilter=</var>3 which is also a good deblocker (dfttest) and let <var>SMDegrain()</var> clean the blocking for you</li>
	<li>Default output <var>mode</var>(dithering) for <var>lsb=</var>true (when non <var>interlaced</var>) is ordered dither (optimized for encoding), so it is not recommended to keep filtering non-edge areas of your source, you can instead use <var>mode=</var>6 (error diffusion) or <var>lsb_out=</var>true and keep filtering in 16bit </li>
	<li>Read the <var>prefilter</var> setting explanation for solutions to problematic sources</li>
  <li><i>SMDegrain(tr=2,thSAD=250,contrasharp=true,refinemotion=true,lsb=true)</i><br/>I consider this a good starting point where to start tweaking, whether be it for quality or speed</li>
</ul>
<p>&nbsp;</p>
<h2><a id="parameters"></a>Parameters&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<br/>
<p><i>SMDegrain (clip input, int <a href="#tr">"tr"</a>, int <a href="#thSAD">"thSAD"</a>, int <a href="#thSAD">"thSADC"</a>, bool <a href="#RefineMotion">"RefineMotion"</a>, val <a href="#contrasharp">"contrasharp"</a>, clip <a href="#CClip">"CClip"</a>, bool <a href="#interlaced">"interlaced"</a>, int <a href="#plane">"plane"</a>, int <a href="#Globals">"Globals"</a>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <a href="#pel">"pel"</a>, int <a href="#subpixel">"subpixel"</a>, val <a href="#prefilter">"prefilter"</a>, clip <a href="#mfilter">"mfilter"</a>, int <a href="#blksize">"blksize"</a>, int <a href="#overlap">"overlap"</a>, int <a href="#search">"search"</a>, bool <a href="#Truemotion">"truemotion"</a>, int <a href="#limit">"limit"</a>, int <a href="#limit">"limitc"</a>, int <a href="#thSCD1">"thSCD1"</a>, int <a href="#thSCD2">"thSCD2"</a>,     \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool <a href="#chroma">"chroma"</a>, int <a href="#hpad">"hpad"</a>, int <a href="#hpad">"vpad"</a>, bool <a href="#lsb">"lsb"</a>, bool <a href="#lsb_in">"lsb_in"</a>, bool <a href="#lsb_out">"lsb_out"</a>, int <a href="#mode">"mode"</a>, bool <a href="#slices">"slices"</a>, val <a href="#Show">"Show"</a>, float <a href="#Str">"Str"</a>, float <a href="#Amp">"Amp"</a>)</i></p><br/>
<br/><br/>
<h3><a id="basic"></a>Basic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="tr"></a>tr</h4>
<i>[int: 1, "2", 3, 4, 5, 6, ...]</i><br/>
<br/>
Temporal radius. Select between <i>MDegrain</i> 1, 2, 3, 4, 5, 6 or higher. Higher is generally better, but also much slower and improvements get less drastic.<br/>
This can be considered the strength of the denoising. tr 4, 5 and 6 (limit is <var>tr=</var>128, 64 for interlaced) require Dither's MVTools2 mod.<br/>
<br/>
<h4><a id="thSAD"></a>thSAD, thSADC</h4>
<i>[int:"300"], [int:"150"]</i><br/>
<br/>
<i>"Sum of Absolute Differences"</i> threshold. This is the spatial difference threshold where the motion search will consider whether to denoise given the next formula: <a href="http://forum.doom9.org/showthread.php?p=1562037#post1562037" target="_blank">Denoise_Weight = max( 0, 1 - 2*blockSAD² / (thSAD² + blockSAD²) )</a><br/>
This spatial difference will be compared in blocks (<var>blksize</var>). If your noise is not getting into consideration for the denoising try raising this value, or reduce its SAD with previous <var>prefilter</var>ing.<br/>
You can alternatively raise the block size (<var>blksize</var>), which will likely even blocks SAD. Low values can result in staggered/blotchy denoising, large values can result in ghosting and artifacts. Values in the range 200~600 are usual.<br/>
<var>thSADC</var> is the same logic applied to chroma <var>plane</var>s, since there are less differences on the chroma planes it uses by default <var>thSAD</var>/2 for safer chroma results.<br/>
<br/>
<i>*Use slightly greater values than you are used to in other mdegrain based functions since the internal clip for the motion search in SMDegrain() has the contrast increased.</i><br/>
<br/>
<h4><a id="contrasharp"></a>Contrasharp</h4>

<i>[bool: true, "false"] or [int: 0 ~ 100 ]</i><br/>
<br/>
Contrasharpening is a technique that compares the differences between the clip before blurring (original) and after blurring (filtered), and sharpens locally with consequent strength.<br/>
By default the before "sharp" clip is the one used as input for <var>SMDegrain()</var>, the "after" clip is the denoised clip. Independently a "before" clip can be specified with the <var>CClip</var> parameter (See <a href="#CClip">below</a>)<br/>
<br/>
<var>Contrasharp</var> when set to "true", will use Didée's <i>Contrasharpening()</i> function (or the modded version <i>ContraHD()</i> for HD sources) which:<br/>
  <i>"Sharpens the denoised clip, but doesn't add more to any pixel than what was removed previously"</i><br/>
   In the practice you will get a slightly sharper result than the source, which is welcome.<br/>
In the other hand if your parameter input is an integer, <i>LSFmod()</i> will be used instead. It will be much slower, but maybe better for certain sources.<br/>
Its value will serve as a <var>contrasharp</var>ening multiplier, use one around 50 for similar strength as <i>Contrasharpening()</i>.<br/>
The drawbacks for LSFmod (integer inputs) are that they are no-suitable for HD sources and no support for planar (YUY2) inputs.
<br/>
<h4><a id="RefineMotion"></a>RefineMotion</h4>

<i>[bool: true, "false"]</i><br/>
<br/>
Refines and recalculates motion data of previously estimated (by <i>MAnalyse</i>) motion vectors.<br/>
Turn it on for better motion vectors, specially when dealing with ghosting issues, small details or lineart fading and whatnot.<br/>
&nbsp;&nbsp;*<i>It won't enhance much if you use a <var>prefilter</var> (in case you use it) so strong that blurs too much or kills all the details you are aiming to protect in first place.</i><br/>
<br/>
<h4><a id="plane"></a>plane</h4>

<i>[int: 0, 1, 2, 3, "4"]</i><br/>
<br/>
Select the planes you wish to process:<br/>
<ul>
	<li>0 - luma only</li>
	<li>1 - chroma U</li>
	<li>2 - chroma V</li>
	<li>3 - both chromas</li>
	<li>4 - all (Default)</li>
</ul>
<br/>
&nbsp;&nbsp;*<i>Keep in mind that <var>plane</var>=4 (2 and 3 as well) can sometimes create chroma smearing. In such case I recommend denoising chroma <var>planes</var> in the spatial domain.</i><br/>
<br/>
<h4><a id="interlaced"></a>Interlaced</h4>

<i>[bool: true, "false"]</i><br/>
<br/>
If you want to denoise an <var>interlaced</var> source set this parameter to true. Output will also be <var>interlaced</var>.
Just keep in mind that if you pair this with <var>lsb_out=</var>true then you will have to add <i>Weave().DitherPost(mode=6,interlaced=true)</i> when converting back to 8 bit.<br/>

<br/><br/><br/><br/>
<h3><a id="16bit"></a>High Bit Depth Processing And Dithering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="lsb"></a>lsb</h4>
<i>[bool: true, "false"]</i><br/>
<br/>
This enables 32 bit depth precision for denoising.<br/>
It will allow you to gain extra denoising accuracy, most noticeable in the prevention of banding in flat areas.
For this to be used you will need the <a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">Dither package with its version of MVTools2.</a><br/>
<br/>
<h4><a id="lsb_in"></a>lsb_in</h4>
<i>[bool: true, "false"]</i><br/>
<br/>
Set it to true if you use <var>SMDegrain()</var> in a 16 bits filter chain.<br/>
For this to be used you will need the <a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">Dither package with its version of MVTools2.</a>  <i>*(Mind you, it's not native lsb_in but it should work fine)</i><br/>
<br/>
<h4><a id="lsb_out"></a>lsb_out</h4>
<i>[bool: true, "false"]</i><br/>
<br/>
If you set <var>lsb</var> to true, you can also choose to output in 16 bits (an internal 32 bit->16 bit conversion is done) so you can keep filtering in 16 bits<br/>
or/and use your own Ditherpost().<br/>
<i>*Use the helpers at the end of the <var>SMDegrain()</var> script to make Ditherpost() able to use when dealing with YUY2 formats.</i><br/>
For this to be used you will need the <a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">Dither package with its version of MVTools2.</a><br/>
<br/>
<h4><a id="mode"></a>mode</h4>
<i>[int: -1, "0", 1, 2, 3, 4, 5, 6, 7, 8]</i><br/>
<br/>
If you process in 32bit and <var>lsb_out</var> (16bit output) is not enabled, a dithering method must be chosen for the 32bit->8bit conversion. (<var>Interlaced</var> content is locked to <var>mode=</var>6)<br/>
The default mode=0 will help you optimize the dithering for optimum encodings when no further non-edge processing is done. Use mode=6 (error diffusion) if further processing is needed.<br/>
<ul>
	<li>-1: no dither, round to the closest value
	<li>0: 8-bit Bayer ordered dither + noise. (Default)</li>
	<li>1: 1-bit dither</li>
	<li>2: 2-bit dither, light</li>
	<li>3: 2-bit dither, medium</li>
	<li>4: 2-bit dither, strong</li>
	<li>5: 2-bit dither, stronger</li>
	<li>6: Serpentine Floyd-Steinberg error diffusion + noise. Well-balanced algorithm.</li>
	<li>7: Stucki error diffusion + noise. Looks sharp and preserve light edges and details well.</li>
	<li>8: Atkinson error diffusion + noise. Generates distinct patterns but keeps clean the flat areas.</li>
	<li>9: Random Dither. Wrapped mode for mode=-1 & ampn=1.0. Poor SNR (Signal-to-noise ratio). Academical</li>
</ul>
For this to be used you will need the <a href="#dependencies">Dither package with its version of MVTools2.</a><br/>
<br/>
<h4><a id="slices"></a>slices</h4>
<i>[bool: "true", false]</i><br/>
<br/>
From the Dither documentation: <i>"Set it to false to disable plane slicing. Slicing is used in multithreading and can create artefacts at slice boundaries with error-diffusion algorithms. Disabling slicing reduces the threading preformances."</i>
Defaulted to true for speed, you can turn it off if you experience said issues so it will use single thread processing (slow) in the few places it might be required within <var>SMDegrain()</var>.
<br/>
<br/><br/><br/><br/>
<h3><a id="advanced"></a>Advanced&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="pel"></a>pel</h4>
<i>[int: 1, "2", 4]</i><br/>
<br/>
Accuracy of the motion estimation.
<ul>
	<li>1: means a precision to the pixel. (Default 1 for HD material)<br/>
	<li>2: means a precision to half a pixel. (Default)
	<li>4: means a precision to quarter a pixel, produced by spatial interpolation (more accurate but slower and not always better due to big level scale step).
</ul>
<br/>
<h4><a id="subpixel"></a>subpixel</h4>
<i>[int: 0, 1, "2", 3]</i><br/>
<br/>
Subpixel accuracy. It chooses an interpolation method for <var>pel=</var>2 or 4. This is the 'sharp' parameter in <i>msuper()</i>,<br/>
although it isn't related to output sharpness but better accuracy for the motion estimation.<br/>
<ul>
	<li>subpixel = 0 for soft interpolation (bilinear)</li>
	<li>subpixel = 1 for bicubic interpolation (4 tap Catmull-Rom)</li>
	<li>subpixel = 2 for sharper Wiener interpolation (6 tap, similar to Lanczos) (Default)</li>
	<li>subpixel = 3 for nnedi3 high quality subpixel interpolation</li>
</ul>
For <var>subpixel=</var>3 you will need the nnedi3 plugin. Very useful when used along <var>pel=</var>4 on very small sources, although overkill and unnecesary in most cases.<br/>
<br/>
<h4><a id="prefilter"></a>prefilter</h4>
<i>[int: "-1", 0, 1, 2, 3, 4] or [clip: - ]</i><br/>
<br/>
<ul>
	<li>-1 = off (Default)</li>
	<li>0 = light controlled gauss blur</li>
	<li>1 = mild median/gauss blur</li>
	<li>2 = strong median/gauss blur</li>
	<li>3 = dfttest (spatial)</li>
	<li>4 = KNLmeansCL (spatio-temporal GPU filter)</li>
	<li>variable = <var>prefilter</var>ed clip input variable</li>
</ul>
<br/>
Denoises a version of the clip that will be used to obtain the motion vectors.<br/>
Useful for very damaged/grainy sources. This will help to get better motion vectors.<br/>
For sources with Gibbs noise, especially on anime, try <var>prefilter=</var>1 or 2 or better yet strong median filters (through clip input)<br/>
in order to soothe the high SAD of sharp edges. For blocky sources, or a general more quality/safer <var>prefilter</var> use option 3 (<i>dfttest</i>)*<br/>
<var>prefilter=</var>4 is aimed at grainy sources, it also helps to stabilize film wobble artifacts. I expanded the filter to work on YUY2 sources<br/>
and chroma planes (unsupported natively). Requires the Dither tools.<br/>
&nbsp;*By default dfttest outputs a sstring txt file to your script folder, you can delete it. This doesn't happen when using the modded dfttest (version 1.9.2 or higher) of the Dither tools.<br/>
For HD sources <var>prefilter=</var>2 makes more sense than 1, because it uses a wider denoising window.<br/>
<br/>
If instead you want to use your own <var>prefilter</var> denoiser, just define it in a variable and reference it here. Remember to:<br/>
<ul>
	<li>Feed always 8 bit clips.</li>
	<li>Input in fields for <var>interlaced</var> content <i>*(read below)</i></li>
	<li>Feed here planar ( by using <i>Interleaved2Planar()</i> ) YUY2 clips (not interleaved) when working with YUY2 sources.</li>
</ul>
You will likely want to use spatial denoisers like median filters (removegrain=17, medianblur, etc).<br/>
For very grainy or fizz grain noise you can try <var>prefilter=</var>4 as described above, other methods previosuly recommended are <var>prefilter</var>ing in temporal,<br/>
one example try adding a new <var>SMDegrain()</var> line again but without globals. Use <var>lsb_in</var>, <var>lsb_out</var> according so results are smooth.<br/>
You can even use <var>SMDegrain()</var> as a prefilter for <var>SMDegrain()</var> in very temporal unstable sources.<br/>
Another trick for fizz grain is to serve a <var>prefilter</var>ed clip where bright values are more denoised than dark values,<br/>
you can do this through luma masks with masktools2 code. Search in <a href="http://forum.doom9.org/showthread.php?t=162813" target="_blank">Doom9</a> for reference.<br/>
<br/>
Remember how <var>interlaced</var> sources must be <var>prefilter</var>ed (when you are serving it as your own custom <var>prefilter</var>):<br/>
For interlaced content use: <i>separatefields().spatial_prefilters_here()</i><br/>
For temporal filters odd and even frames must be processed separately: <i>separatefields().interleave(selecteven().TempPrefilt(),selectodd().TempPrefilt())</i><br/>
<br/>
<var>SMDegrain()</var> (its core: mdegrain in fact) is likely to produce blending artifacts or oversmooth in dark areas specially on cartoons, to tackle this see <a href="#RefineMotion"><var>RefineMotion</var></a><br/>
or expand the luma range in the darks. For this there are many options, you can use your preferred gamma enhancer and input it as the <var>prefilter</var>,<br/>
or use the examples below for linear brightening (masktools2) and input it as a <var>prefilter</var> as well. Or at last and the recommended solution,<br/>
to use the built-in <var>Str</var> (strength) and <var>Amp</var> (amplitude) parameters for a curve type dark enhancement, check the effects by enabling <var>Show</var><br/>
and changing your previewing conditions to PC levels.<br/>
<br/>
For brightening dark values linearly (brighter parts less brightening)<br/>
<pre>str=1
mt_lut("x x "+string(str)+" 6 * - 255 - abs 255 / ^ x 1 - abs +")</pre>
<br/>
Or for a more contrasty image (although not as much dark enhancing - not linear)<br/>
<pre>str=40
mt_lut("x x "+string(str)+" 6 * - 255 - abs 255 / ^ "+string(str)+" / x 1 - abs +")</pre>
<br/>
<br/>
Good resources for custom <var>prefilter</var> code:<br/>
<ul>
	<li><a href="http://forum.doom9.org/showthread.php?t=162813" target="_blank">http://forum.doom9.org/showthread.php?t=162813</a></li>
	<li><a href="http://forum.doom9.org/showthread.php?t=132310" target="_blank">http://forum.doom9.org/showthread.php?t=132310</a></li>
	<li><a href="http://forum.doom9.org/showthread.php?t=133977" target="_blank">http://forum.doom9.org/showthread.php?t=133977</a></li>
</li>
</ul>
<br/>Notes:
To sum it up; generally in denoising, temporal filters are always preferred due to its natural look (versus spatial filters).<br/>
But more often than not for good results <var>prefilter</var>ing plays a key role on the output quality, and setting it up nicely can be looked as an art by itself.<br/>
<br/>
If there's a reached point where no <var>prefilter</var>ing, no <var>thSAD</var> tweaking, etc, makes able to denoise a certain motion part/area/scene,<br/>
then this is due to the motion vectors preventing them from being "denoised" (also read "artifacted"), in which case you will need to rely on alternative solutions (motion compensation, filters like MCTemporalDenoise(), TemporalDegrain(), <a href="http://forum.doom9.org/showthread.php?p=1544619#post1544619" target="_blank">Multilevel mdegrain</a>, etc) or just use plain spatial filters with motion masks.<br/>
Creating these discerning masks for static and motion scenes and combining them is a research task on the end user side.<br/>
<br/>
<h4><a id="mfilter"></a>mfilter</h4>
<i>[clip: - ]</i><br/>
<br/>
As with <var>prefilter</var>, in mfilter (Motion Filter) you can add a clip variable. This clip will be passed through those areas where smdegrain() couldn't find a matching block, normally high motion areas.<br/>
One use for it would be to to use spatial filters, like deblockers or blurring filters that mimic motion blur.<br/>
<br/>
<h4><a id="Str"></a>Str</h4>
<i>[float: 0.0 ~ 8.0]  Default: 1.0 (inactive)</i><br/>
<br/>
With this parameter you control the strength of the brightening of the <var>prefilter</var> clip. This is good when problems with<br/>
dark areas arise (check the <a href="#prefilter">above</a> explanation). The benefit of using this and not an external function is because this<br/>
is done in the same stage as the TV->PC range conversion thus more memory friendly and less quantization artifacts.<br/>
<br/>
<h4><a id="Amp"></a>Amp</h4>
<i>[float: 0.0 ~ 1.0]  Default: 0.0625</i><br/>
<br/>
Use this together with <var>Str</var> (active when <var>Str</var> is different from 1.0). This defines the amplitude of the brightening in the luma range, for example by using 1.0 all the<br/>
luma range will be used and the brightening will find its peak at luma value 128 in the original. Default is 0.0625 (1.0/16) which just sits over luma value 16 (256/16)<br/>
This and the <var>Str</var> parameters are extrapolated arguments of a cretindesalpes' function, you can find a graph and more insight explanations at the original <a href="http://forum.doom9.org/showthread.php?p=1548318#post1548318" target="_blank">post</a>.<br/>
Check these 2 parameters effects by enabling <var>Show</var>.<br/>
<br/>
<h4><a id="blksize"></a>blksize</h4>
<i>[int: 4, "8", 16]</i><br/>
<br/>
Size of a block (horizontal). (Default 16 for HD material)<br/>
Larger blocks are less sensitive to noise, are faster, but also less accurate.<br/>
<br/>
<h4><a id="overlap"></a>overlap</h4>
<i>[int: "<var>blksize</var>/2"]</i><br/>
<br/>
Must be *even* and *less* than block size. Common <var>overlap</var> values: <var>blksize</var>/4 or <var>blksize</var>/2.<br/>
The greater <var>overlap</var>, the more blocks number, and the lesser the processing speed.<br/>
<br/>
<h4><a id="search"></a>Search</h4>
<i>[int: 0, 1, 2, 3, "4", 5, 6, 7]</i><br/>
<br/>
	<ul>
	<li>0 = 'OneTimeSearch'</li>
	<li>1 = 'NStepSearch'</li>
	<li>2 = Logarithmic</li>
	<li>3 = Exhaustive</li>
	<li>4 = Hexagon (Default)</li>
	<li>5 = Uneven Multi Hexagon (UMH)</li>
    <li>6 = pure Horizontal exhaustive search</li>
    <li>7 = pure Vertical exhaustive search</li></ul>
See details at <a href="http://avisynth.org.ru/mvtools/mvtools2.html" target="_blank">MVTools2</a> documentation.<br/>
<br/>
<h4><a id="Truemotion"></a>Truemotion</h4>
<i>[bool: "true", false] * "false" for HD</i><br/>
<br/>
<var>Truemotion</var> is a preset of some parameters values. It allows easy to switch default values of all "true motion" parameters at once.<br/>
Set it 'true' for true motion search (high vector coherence), set it 'false' to search motion vectors with best SAD.<br/>
Default is 'true' (as in MVtools2 default, and contrary to MCTemporalDenoise()).

By turning it off it could protect better low frequency details (shading) when in motion (i.e. walls, grounds, clouds texture, motion blur, etc),<br/>
and also protect from tiny details loss but it could leave more noise unfiltered.<br/>
Default is 'true' for smoother/cleaner (more temporal coherence) high frequency details or lineart. For HD sources where the main problems are just excessive grain,<br/>
I have defaulted it to false, this is not only faster but honors detail accuracy (the main existing point for HD sources) and overall object shading.<br/>
<br/>
<h4><a id="chroma"></a>Chroma</h4>
<i>[bool: "true", false]</i><br/>
<br/>
Takes chroma <var>plane</var>s into consideration for calculating the motion vectors.<br/>
Turn it off for more speed with little cost in quality, or when your chroma is not reliable enough for motion estimation.<br/>
&nbsp;&nbsp;*<i>Whatch out if you turn this off when processing chroma planes (aka luma vectors when chroma denoising), it has shown problems in <a href="http://forum.doom9.org/showthread.php?p=1551305#post1551305" target="_blank">previous tests</a>.</i><br/>
<br/>
<br/>
<h4><a id="hpad"></a>Hpad, Vpad</h4>
<i>[int: "<var>blksize</var>"]</i><br/>
<br/>
It is horizontal/vertical padding added internally to source frame (both left and right, and top and bottom).<br/>
Small padding is added for more correct motion estimation near frame borders.<br/>
Try to have clean borders in your source (no NAB*/black borders) to start with before tweaking this setting.<br/>
If necessary, crop beforehand ideally in multiples of 16. Turn it to 0 if you are running out of resources in your system.<br/>
*<i>Nominal Analog Blanking</i><br/>
<br/>
<br/>
<h4><a id="thSCD1"></a>thSCD1</h4>
<i>[int: "400"] *int(pow((<var>blksize</var>*2.5),2))</i><br/>
<br/>
Threshold which decides whether a block has changed between the previous frame and the current one. So it is one of the thresholds used to tweak the scene changes detection engine. Raising it will lower the number of blocks detected as changed. It may be useful for noisy or flickered video. To fix blending on scene changes on dark scenes, try first the <var>Str</var> and <var>Amp</var> parameters.<br/>
<br/>
<br/>
<h4><a id="thSCD2"></a>thSCD2</h4>
<i>[int: 0~"130"~255]</i><br/>
<br/>
Threshold which sets how many blocks have to change for the frame to be considered as a scene change.<br/>
<br/>
<br/>
<h4><a id="limit"></a>limit,limitC</h4>
<i>[int: 1 ~ "255"]</i><br/>
<br/>
Maximal change of pixel luma/chroma (post-process like DeGrainMedian plugin<br/>
and LimitChange function of SSETools plugin, to prevent some artifacts)<br/>
<br/>
<br/>
<h4><a id="CClip"></a>CClip</h4>
<i>[clip: - ]</i><br/>
<br/>
Define here a variable name referencing an earlier stage of your processing chain as the sharp version for the <var>contrasharp</var>ening to compare against.<br/>
Just keep in mind video resolution must be the same size and the features comparable.<br/>
<br/>
	<ul><li>If <var>contrasharp</var> is not declared, by default it will use the <i>contrasharpening()</i> function, add <var>contrasharp=</var>'an integer' to force <i>LSFmod</i> instead.</li>
	<li>For <var>interlaced</var> sources input must also be <var>interlaced</var>.</li>
	<li>You can reference either 8 or 16bit sharp clips independently.</li></ul>
<br/>
<h4><a id="Globals"></a>Globals</h4>
<i>[int: "0", 1, 2, 3 ]</i><br/>
<br/>
With this parameter you can, among other things, load pre-processed motion vectors (<var>Globals=</var>1), so you save doing this step again.<br/>
<br/>
The integers define what do you want to do with the global variables. Default is 0.<br/>
<br/>
 <ul>
    <li>0: Don't read nor output globals (Just process) (Default)</li>
	<li>1: Read globals --> Process</li>
	<li>2: Process      --> Output globals</li>
	<li>3: Output globals only (Don't process clip)</li></ul>
<br/>
Some parameters MUST MATCH those from the processed vectors stage (e.g. <var>Globals=</var>2 or 3) and the read vectors stage (e.g. <var>Globals=</var>1).
<var>pel=</var>, <var>subpixel=</var>, <var>chroma=</var> and <var>vpad/hpad</var>.
Other than that the only settings that work when reading (<var>Globals=</var>1) are: <var>tr=</var>, <var>thSAD=</var>, <var>plane</var>, <var>limit</var>, <var>limitc</var>, <var>contrasharp</var>, <var>CClip</var>, <var>interlaced</var> and the <var>lsb</var> parameters. Others are ignored.<br/>
Global names that can be reused are: <var>Super</var>, <var>bv1</var>, <var>fv1</var>, <var>bv2</var>, <var>fv2</var>, <var>bv3</var>, <var>fv3</var>, <var>bv4</var>, <var>fv4</var>, <var>bv6</var>, <var>fv6</var>, <var>vmulti</var>.<br/>
<br/>
e.g.:<pre>
                         SMDegrain(tr=3,thSAD=400,globals=3)    # Outputs vectors

                         SMDegrain(tr=2,thSAD=200,globals=1)    # You can use a same or <b>lower</b> "tr" or "thSAD" if you want</pre>
or<pre>

                         SMDegrain(tr=3,thSAD=400,globals=3)    # Outputs vectors

                         Super = MSuper(levels=1)               # Add this line just before if you have some processing between Globals Output and Input.
                         MDegrain3(Super, bv1, fv1, bv2, fv2, bv3, fv3, thSAD=400)</pre><br/>
<br/>
<br/>
<h4><a id="Show"></a>Show</h4>
<i>[bool: true, "false" ] or [string: "Speed", "Memory", "Quality" ]</i><br/>
<br/>
This will show the <var>prefilter</var>ed clip to be used for the motion search to the left(<--), and the used parameters list to the right (-->)<br/>
<br/>
If the parameters panel is broken i.e. overlapping lines, hidden lines, etc, most likely your settings are wrong, (e.g. <var>lsb_in=</var>true when input is 8bit)<br/>
so it will also work well as a debug function. If you set <var>Show</var> to a string as indicated above, related parameters will be highlighted to guide you on<br/>
correctly tweaking the function. This is loosely based, so it doesn't exclude you from reading carefully every parameter explanation.<br/>
<br/>
Even when you are not using any <var>prefilter</var>ing, the clip to be used for the motion search where you obtain the motion vectors,<br/>
will be converted from TV levels to PC levels, the only exception being when using <var>Globals=</var>1 (Read) in which case the "<var>prefilter</var>ed" clip<br/>
will be exactly the same as input clip (that is no luma conversion, although constrained to 8 bit). Additionally you can tweak the dark expansion with<br/>
<var>Str</var> and <var>Amp</var> parameters and check the effects in the left panel, but be aware to change your viewing conditions as it is in PC levels.<br/>
<br/>
The left panel preserves its properties so you can crop out the right panel and use it as a <var>prefilter</var> clip of any <i>msuper()</i>.<br/>
Therefore if you are not processing chroma for motion analysis(<var>chroma=</var>false) the <var>prefilter</var>ed clip will be green, don't panic, this is correct, this happens when the<br/>
U and V <var>plane</var>s are set to a value of 0 which is a dummy value meaning nothing or "discard". In this regard for previewing tasks with <var>prefilter</var>ings<br/>
or just the <var>Str</var> and <var>Amp</var> effect simply set <var>chroma</var> to true temporally. For YUY2 sources set <i>Planar2Interleaved()</i> after cropping for previewing.<br/>
<p>&nbsp;</p>
<h2><a id="finalnotes"></a>Final Notes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
If there is an important parameter not implemented,<br/>
you have any issue or found a bug, please don't hesitate<br/>
and ask in the VideoHelp thread:<br/><br/>
(<a href="http://forum.videohelp.com/threads/369142" target="_blank">http://forum.videohelp.com/threads/369142</a>)<br/>
<p>&nbsp;</p>
<h2><a id="examples"></a>Example Scripts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<br/>
A basic yet very functional call for light grain (mvtools2+masktools2 only needed)
<pre>SMDegrain(tr=1,thSAD=300,contrasharp=true)</pre>
<br/>
A typical more worked call compatible with official mvtools2 (mvtools2+masktools2 only needed)
<pre>SMDegrain(tr=2,thSAD=300,interlaced=true,prefilter=1,contrasharp=true)</pre>
<br/>
The next is a personal preference. Turned all chroma off for safeness (on SD chroma is rarely temporal-reliable enough) and speed.
<pre>SMDegrain(tr=2,thSAD=300,contrasharp=true,refinemotion=true,lsb=true,chroma=false,plane=0)</pre>
<br/>
This is a good example to show that <var>interlaced</var> YUY2 sources can be processed seamlessly.
<pre># mod4 (modulus 4) interlaced YUY2 source
SMDegrain(tr=1,thSAD=250,interlaced=true,contrasharp=true,lsb=true)</pre>
<br/>
For dealing with dark scenes (you could also add <var>truemotion=</var>false)
<pre>SMDegrain(tr=3,thSAD=300,contrasharp=true,str=2.0,refinemotion=true,lsb=true)</pre>
<br/>
HD sources are detected automatically, and as so settings are optimized for speed; <var>pel=</var>1, <var>blksize=</var>16, <var>overlap=</var>8, <var>truemotion=</var>false
<pre># HD source (from 1100px wide or 600px high up)
SMDegrain(tr=2,thSAD=180,prefilter=2,contrasharp=30,refinemotion=true,lsb=true,chroma=false,plane=0)</pre>
<br/>
Tackling a grainy source:
<pre>
pre=fluxsmootht(3).removegrain(11)
SMDegrain(tr=6,thSAD=500,contrasharp=40,prefilter=pre,str=1.2,refinemotion=true,lsb=true)</pre>

OR

<pre>SMDegrain(tr=5,thSAD=500,contrasharp=40,prefilter=4,str=1.2,refinemotion=true,lsb=true)
</pre>
<br/>
Here 2 things are shown; how to work on a 16bit pipeline, and reference a prior state of the script for the <var>contrasharp</var>ening process.
<pre>sharp_ref=last
dfttest(tbsize=1,sigma=10,lsb=true)

SMDegrain(tr=3,thSAD=300,CClip=sharp_ref,lsb_in=true,lsb_out=true)

LinearResize(854,480,lsb_in=true, mode=0)</pre>
<br/>
(Re)using motion vectors <var>globals</var>
<pre>SMDegrain(tr=1,thSAD=400,prefilter=3,str=1.4,globals=3)    # Output vectors only
MFlowFps(Super, bv1, fv1, num=60,den=1)</pre>
<br/>
<p>&nbsp;</p>
<h2><a id="changelog"></a>Changelog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<p><b>v3.1.2d</b> (21-07-2015)</p>
	<ul>
	    <li>Fixed regression where external prefilters wouldn't be parsed for luma expansion</li>
	</ul>
<p><b>v3.1.1d</b> (16-07-2015)</p>
	<ul>
	    <li>Workaround to force KNLMeansCL use discrete video card (now required)</li>
	</ul>
<p><b>v3.1d</b> (14-07-2015)</p>
	<ul>
	    <li>New prefilter mode 4 for grainy sources. GPU based spatio-temporal KNLmeans</li>
	    <li>Added dither output mode "Random Dither".</li>
	    <li>Added "slices" option from Dither</li>
	    <li>Added soft=-2 (automatic) to internal lsfmod</li>
	    <li>Added assert for chroma denoise when luma only motion vectors (mvtools bug)</li>
	    <li>Improved lsb_in code (now using sub/add method)</li>
	    <li>Removed vpad/hpad=0 optimization preset for HD</li>
	    <li>Fixed prefilter=3 code for lsb_in YUY2</li>
	    <li>More fixes to Show Panel...</li>
	    <li>Updated and fixed documentation (notes on YUY2 support)</li>
	</ul>
<p><b>v3.0d</b> (27-03-2015)</p>
	<ul>
	    <li>Adjusted SD<>HD discretion</li>
	    <li>Added mfilter (Motion Filter) new feature</li>
	    <li>subpixel=3 (nnedi3); removed qual=2 due to possible blending bug (quote by cretindesalpes), this also boosts speed</li>
	    <li>Lowered the defaults for less aggressive denoise (still somewhat high)</li>
	    <li>Fixed chroma not showing in debug (show) mode when lsb=true and prefilter=3 were paired</li>
	    <li>Fixed long lasting issues in Show Panel for certain not mod height resolutions</li>
	    <li>Now prefilter=0 is minblur(0), lighter denoising than prefilter=1, default is now -1 (off)</li>
	    <li>Documentation update (plugin updates, notes, links, examples, etc)</li>
	</ul>
<p><b>v2.2d</b> (05-03-2013)</p>
	<ul>
	    <li>Removed one residual variable in Contrasharpening function</li>
	    <li>Fixed a regression at v2.0 for Interlaced YUY2 sources by changing wrong variable ifC to if0, and...</li>
	    <li>...adding a missing weave() to the last MergeChroma() call</li>
	    <li>Dropped Dither support. (Will still work/not work as before, but lack of official support renders it to a YMMV condition)</li>
	</ul>
<p><b>v2.1d</b> (09-09-2012)</p>
	<ul>
	    <li>Fixed Refinemotion Globals Input labels</li>
	    <li>Fixed ContrasharpeningHD Vectors for Interlaced HD sources</li>
	    <li>Added ability to import Global Vectors even when "tr" is lower than parent instance "tr" (credit to cretindesalpes)</li>
	    <li>Expanded support for Interlaced Denoising "tr" up to 64 (credit to cretindesalpes)</li>
	    <li>Cosmetics</li>
	</ul>
<p><b>v2.0d</b>  (07-06-2012)</p>
	<ul>
	    <li>Fixed and optimized chroma handling for lsb_in, contrasharpening and YUY2 content v.1.95</li>
	    <li>Enhanced Chroma bypass on the sharpening stage</li>
	    <li>Merged ContraHD() internally for Contrasharpening in HD sources</li>
	    <li>Dropped QTGMC support on import/export motion vectors (small value for increased confusion)</li>
	    <li>Fixed Median code for planar inputs in MinBlur() (needs RemoveGrainHD, dropped medianblur requirement)</li>
	    <li>Defaulted truemotion to false for HD inputs</li>
	    <li>Code Optimization and Clean up</li>
	    <li>Others</li>
	</ul>
<p><b>v1.9d</b>  (23-03-2012)</p>
	<ul>
	    <li>Added truemotion parameter (default=true), change it to false (as in MCTemporalDenoise()), so low frequency detail won't be lost (walls...), although it could leave more noise on high frequency details</li>
		<li>Added thSADC, and thSCD1/thSCD2 parameters for finer control</li>
	    <li>Tweaked prefilter=3 dfttest sigmas for better low frequency detail protection</li>
		<li>Detached explanation and converted to html. Updated and extended the contents as well</li>
		<li>Fine tuned and robustized the Show Panel</li>
		<li>Optimized and organized code, more precisely the contrasharpening part</li>
		<li>Fixed a few ternary checks for when Globals=3</li>
		<li>Others</li>
	</ul>
<p><b>v1.8d</b>  (18-01-2012)</p>
	<ul>
		<li>Added automatic dark protection for prefilter=3 (dfttest performs badly in darks) v1.71d and extended its dark protection v1.8</li>
		<li>Fixed chroma variable when chroma=false, from 2 (copy chroma) to 1 (discard chroma) v1.71d</li>
		<li>Explanation and cosmetics v1.71d</li>
		<li>Added acknowledgments and updated explanation</li>
		<li>Added brackets to all functions (it has been reported to cause threading problems under certain circumstances) (<a href="http://forum.doom9.org/showthread.php?p=1515886#post1515886" target="_blank">http://forum.doom9.org/showthread.php?p=1515886#post1515886)</a></li>
		<li>Reworked and fixed the parameters panel. Now you have a color guide to have an idea on what to tweak depending on selected mode in Show. For strings: "Speed", "Memory" and "Quality"</li>
		<li>Optimized lsb_in for HD resolutions which was causing memory hogs</li>
		<li>Fixed contrasharpening for YUY2 sources when lsb=true</li>
		<li>Fixed some inconsistencies for YUY2 sources when prefilter=3</li>
	</ul>
<p><b>v1.7d</b>  (11-01-2012)</p>
	<ul>
		<li>Fixed and extended introduction explanation v.1.61d</li>
		<li>Fixed some issues for Globals=1 (Read) in relation to lsb_in and luma expansion auto-prefilter v.1.61d</li>
		<li>Added mild gauss blur prefilter option as prefilter=1. Consequent modes are displaced v.1.61d</li>
		<li>Changed prefilter 1 and 2 to Minblur (Gauss/Median combination) v.1.63d</li>
		<li>Updated MinBlur function v.1.62d and v.1.66</li>
		<li>Code tidied up v.1.62d
		<li>Updated luma expansion, now you can enhance darks (with 'Str' and 'Amp') in the same step as the TV->PC conversion stage, thus +optimized, +quality. v.1.63d by cretindesalpes (<a href="http://forum.doom9.org/showthread.php?p=1548318#post1548318" target="_blank">http://forum.doom9.org/showthread.php?p=1548318#post1548318)</a></li>
		<li>Removed pre_custom. Now use prefilter to load a prefiltered clip, as well as modes 0~3</li>
		<li>Added Show parameter. Now you can see the used and default parameters along the prefilter clip as well</li>
		<li>Fixed one note related to prefilter clip input for interlaced content</li>
	</ul>
<p><b>v1.6d</b>  (24-12-2011) (first open release)</p>
	<ul>
		<li>Fixed and extended introduction explanation</li>
		<li>Fixed Ditherpost for interlaced sources</li>
		<li>Fixed a broken reference for reading MRecalculate globals when tr>3</li>
		<li>Fixed a Globals=1 MSuper automatization</li>
		<li>Fixed a plane processing bypass when chroma=false</li>
		<li>Added LSFmod as optional contrasharpening (slower, but biased contrasharpening and probably better depending on source)</li>
		<li>Added default luma expansion auto-prefilter for motion search (16% more values)</li>
		<li>Added YUY2 support</li>
		<li>Added the 'mode' parameter of Ditherpost()</li>
		<li>Added support for interlaced temporal radius up to 6</li>
	</ul>
<p><b>v1.5d</b>  (14-10-2011)</p>
	<ul>
		<li>Changed "srchSuper" Global variable to "QTGMC_srchSuper", compatible with QTGMC. Anyhow you may probably want to create a new super clip. Test it out! v.1.41d</li>
		<li>Introduction spelling and presentation v.1.42d</li>
		<li>Added lsb and lsb_in for prefilter=2 (dfttest) v.1.43d & v.1.44d</li>
		<li>Some better definitions for the settings help v.1.45d</li>
		<li>pelclip is now subpixel = 3 ('sharp' parameter before) v.1.45d</li>
		<li>Other minor tweaks v.1.45d</li>
		<li>Fixed an important issue when using prefilter with subpixel=3 ('pelclip' parameter before)</li>
		<li>Optimizations in Ditherpost for chroma</li>
		<li>Changed rfilter (hierarchical levels smoothing/scaling) from default 2 to 4. Better results in my judge</li>
		<li>Some more little tweaks in code and introduction</li>
	</ul>
<p><b>v1.4d</b>  (16-09-2011)</p>
	<ul>
		<li>Added pelclip option for top quality subpixel interpolation when pel > 1</li>
		<li>Changed QTGMCV parameter to Globals, and added a bunch of new features like vectors output from <var>SMDegrain()</var></li>
		<li>Big introduction and code optimization tweaks</li>
	</ul>
<p><b>v1.3d</b>  (14-09-2011)</p>
	<ul>
		<li>Fixed an important issue on the Interlaced parameter and improved overall handling (v.1.21d & v.1.3d)</li>
	</ul>
<p><b>v1.2d</b>  (13-09-2011)</p>
	<ul>
		<li>Added Interlaced parameter, for processing interlaced sources</li>
		<li>Some introduction and code optimization tweaks (v.1.12d & v.1.2d)</li>
	</ul>
<p><b>v1.1d</b>  (12-09-2011)</p>
	<ul>
		<li>Implemented MDegrainN for tr > 3, from the MVTools2 mod of Dither</li>
		<li>Minor introduction and code optimization tweaks</li>
	</ul>
<p><b>v1.0d</b>  (09-09-2011)</p>
	<ul>
		<li>Added CClip parameter. Reference an earlier stage of your processing chain as your sharp version for the contrasharpening</li>
	</ul>
<p><b>v0.9d</b>  (09-09-2011)</p>
	<ul>
		<li>Added QTGMCV parameter, for reusing vectors from QTGMC bob deinterlacer</li>
	</ul>
<p><b>v0.8d</b>  (05-09-2011)</p>
	<ul>
		<li>Fixed a few things related to the lsb_in option</li>
		<li>Minor introduction and code optimization tweaks</li>
	</ul>
<p><b>v0.7d</b>  (05-09-2011)</p>
	<ul>
		<li>Implemented "fake" lsb_in option. Output will have slightly more quality (if any), and will compress better. (Experimental)</li>
		<li>Fixed a not passed argument in the hpad, vpad parameters</li>
	</ul>
<p><b>v0.6d</b>  (04-09-2011)</p>
	<ul>
		<li>Minor introduction and code optimization tweaks</li>
	</ul>
<p><b>v0.5d</b>  (19-07-2011)</p>
	<ul>
		<li>Added dfttest option for preblur (now prefilter) option. Slower but better due to its internal deblock+denoise operation, plus sharper results</li>
		<li>Added pre_custom option for the prefilter process, define here a denoised clip as your prefiltered version</li>
		<li>Updated the introduction help</li>
	</ul>
<p><b>v0.4d</b>  (03-06-2011)</p>
	<ul>
		<li>Added preblur option for slight vector blurring where motionmatch is bad                     (<a href="http://forum.doom9.org/showthread.php?t=161594" target="_blank">http://forum.doom9.org/showthread.php?t=161594)</a></li>
		<li>Added RefineMotion parameter for better motion vectors. Based off Killer()                   (<a href="http://forum.doom9.org/showthread.php?p=1266572#post1266572" target="_blank">http://forum.doom9.org/showthread.php?p=1266572#post1266572)</a></li>
		<li>Added parameters "lsb" and "lsb_out", for the MVTools2 mod version of cretindesalpes' Dither (<a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">http://forum.doom9.org/showthread.php?p=1386559#post1386559)</a></li>
		<li>Other minor aesthetics and performance adjustments</li>
	</ul>
<p><b>v0.3d</b>  (04-03-2011)</p>
	<ul>
		<li>First Mod version</li>
		<li>Fixed plane (for MDegrain) and added chroma (for MAnalyse) parameters</li>
	</ul>
<p><b>v0.2</b>  (24-01-2010)</p>
	<ul>
		<li>Added introductory section</li>
		<li>Added more parameters</li>
	</ul>
<p><b>v0.1</b></p>
	<ul>
		<li>Basic working version</li>
		<li>Not released</li>
	</ul>
</body>
</html>