<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Avisynth Video Filtering" />
<title>Simple MDegrain Mod&nbsp;&mdash;&nbsp;SMDegrain()</title>
<link rel="stylesheet" type="text/css" href="avisynth.css" />
</head>

<body>

<h1>Simple MDegrain Mod&nbsp;&mdash;&nbsp;SMDegrain()</h1>

<p>&nbsp;</p>
<h2>Abstract</h2>

<p>
<b>Author: </b>Dogway<br/>
<b>Version: </b>v4.4.0d<br/>
<b>Download: </b><a href="https://github.com/Dogway/Avisynth-Scripts/tree/master/SMDegrain" target="_blank">https://github.com/Dogway/Avisynth-Scripts/SMDegrain</a><br/>
<b>Discussion: </b><a href="https://forum.doom9.org/showthread.php?t=182881" target="_blank">https://forum.doom9.org/showthread.php?t=182881</a><br/>
<b>Category: </b>Temporal Denoiser<br/>
<b>Date:</b> 16-May-2023
</p>
<p>&nbsp;</p>
<h2><a id="up"></a>Table of contents</h2>
<ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#aknowledgements">Aknowledgements</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#parameters">Parameters Description:</a> <a href="#basic">Basic</a>, <a href="#advanced">Advanced</a></li>
<li><a href="#examples">Example Scripts</a></li>
<li><a href="#finalnotes">Final Notes</a></li>
<li><a href="#changelog">Changelog</a></li>
</ul>
<p>&nbsp;</p>
<h2><a id="dependencies"></a>Dependencies&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<b>Required<br/></b>
<ul>
<table>
  <tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/ExTools.avsi" target="_blank">ExTools</a></b></li></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v10.2 or higher)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/MVTools" target="_blank">MVTools2</a></b></li></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v2.7.45 or higher)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/ResizersPack.avsi" target="_blank">ResizersPack</a></b></li></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v12.0 or higher)</td></tr>
  </tr>
</table>
</ul>
<b>Optional<br/></b>
<ul>
<table>
  <tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/MIX%20mods/LSFplus.avsi" target="_blank">LSFplus</a></b></li></td><td>&nbsp;&nbsp;(v6.0 or higher)</td><td>&nbsp;&nbsp;(for Contrasharp>0)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/MIX%20mods/SharpenersPack.avsi" target="_blank">SharpenersPack</a></b></li></td><td>&nbsp;&nbsp;(v5.1 or higher)</td><td>&nbsp;&nbsp;(for Contrasharp or LFR)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/GradePack.avsi" target="_blank">GradePack</a></b></li></td><td>&nbsp;&nbsp;(v9.0 or higher)</td><td>&nbsp;&nbsp;(for Str=0.1 to 1.0 ~ex_retinex()~ or show)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/ScenesPack.avsi" target="_blank">ScenesPack</a></b></li></td><td>&nbsp;&nbsp;(v4.5 or higher)</td><td>&nbsp;&nbsp;(for Str=0.1 to 1.0 ~ex_retinex()~ if '_SceneRange' frameprops exist)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/MasksPack.avsi" target="_blank">MasksPack</a></b></li></td><td>&nbsp;&nbsp;(v6.6 or higher)</td><td>&nbsp;&nbsp;(for show)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/RgTools" target="_blank">RgTools</a></b></li></td><td>&nbsp;&nbsp;(v1.2 or higher)</td><td>&nbsp;&nbsp;(for Contrasharp or prefilter=0~3)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/Dfttest" target="_blank">DFTTest</a></b></li></td><td>&nbsp;&nbsp;(v1.9.7 or higher)</td><td>&nbsp;&nbsp;(for prefilter=5)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/KNLMeansCL" target="_blank">KNLMeansCL</a></b></li></td><td>&nbsp;&nbsp;(v1.1.1e or higher)</td><td>&nbsp;&nbsp;(for prefilter=6)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/DGDecNV" target="_blank">DGDecNV</a></b></li></td><td>&nbsp;&nbsp;(v246 or higher)</td><td>&nbsp;&nbsp;(for prefilter=7)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/BM3DCUDA" target="_blank">BM3D</a></b></li></td><td>&nbsp;&nbsp;(test10 or higher)</td><td>&nbsp;&nbsp;(for prefilter=8)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts" target="_blank">TransformsPack</a></b></li></td><td>&nbsp;&nbsp;(v1.9 or higher)</td><td>&nbsp;&nbsp;(for prefilter=7 or prefilter=8)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/Neo_TMedian" target="_blank">neo_tmedian</a></b></li></td><td>&nbsp;&nbsp;(r2 or higher)</td><td>&nbsp;&nbsp;(for mode="medianT") (broken for interlaced inputs)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/VsTTempSmooth" target="_blank">vsTTempSmooth</a></b></li></td><td>&nbsp;&nbsp;(v1.2.3 or higher)</td><td>&nbsp;&nbsp;(for mode="TemporalSmooth")</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/NNEDI3CL" target="_blank">NNEDI3CL</a></b></li></td><td>&nbsp;&nbsp;(v1.0.7 or higher)</td><td>&nbsp;&nbsp;(for subpixel=4)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/Average" target="_blank">Average</a></b></li></td><td>&nbsp;&nbsp;(v0.95 or higher)</td><td>&nbsp;&nbsp;(for LFR or mfilter + (Contrasharp or mode!=MDegrain) )</td></tr>
  </tr>
</table>
</ul>
<p>&nbsp;</p>
<h2><a id="aknowledgements"></a>Aknowledgements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<a href="https://forum.doom9.org/showthread.php?t=152326" target="_blank">Original SMDegrain()</a> by Caroliano<br/><br/>
This function uses code from Didée, and cretindesalpes' creations,
and has parts inspired by LaTo's functions (Show panel, etc)
and Jawed's Killer() function, as well as relying on third-party tools for certain features.<br/><br/>
Special thanks go to: cretindesalpes, Didée, Gavino, Sagekilla, and MVtools developers.
<p>&nbsp;</p>
<h2><a id="introduction"></a>Introduction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
SMDegrain is a simple wrapper for MVTools and client functions for general purpose temporal denoising.
Unlike other MVTools based denoising filters, here and specially at default values the output will be source agnostic and similar to a plain MVTools code block.
<br/>
The changes are mainly for useability and convenience, so you can think of it like an interface for MVTools or an extension of it so to speak. For example it will work out of the box with YUY2, interlaced inputs, HBD clips or a combination of them.
<br/>
Internally default values have been optimized with pareto statistics via <a href="https://forum.doom9.org/showthread.php?t=175723" target="_blank">Zopti</a>, so except for <var>tr</var> (radius) and <var>thSAD</var> there isn't a need to tweak much further.
<br/>
What SMDegrain brings though is an interface to apply <var>prefilters</var>, either via the internal presets or external custom ones, motion filters, different degrain <var>modes</var>, lowpassing to recover smearing, etc. Following a list of the main features:
<br/>
<br/>
<b>Frame properties support:</b> Reads frame properties for details on luma/chroma range, bitdepth, source matrix or interlacing.<br/>
<b>High bitdepth denoising:</b> Supports AviSynth+ native HBD formats, from 8-bit up to 16-bit.<br/>
<b>Contrasharpening:</b> The pretty much standarized sharpening method created by Didée is blended into the function, so you can easily use it in HBD pipelines. An strength biased method is also possible via an internal LSFplus call. A <var>CClip</var> parameter is also supplied so you can choose another source to sharpen from, other than the default <var>SMDegrain()</var> input.<br/>
<b>Interlaced support:</b> It supports <var>interlaced</var> sources, for YUY2 color spaces and most parameters as well.<br/>
<b>UHD optimized:</b> UHD denoising can be optimized via motion vector scaling providing much higher performance. Enabled by default with <var>UHDhalf</var> argument.<br/>
<b>Extended Subpixel Accuracy:</b> nnedi3 is added as the 4th option for <var>subpixel</var>. Not strictly necessary in most cases.<br/>
<b>Better Motion Vectors:</b> An internal conversion from TV levels (16-235) to PC levels (0-255) and a dark zone luma expansion is done to the clip where the motion analysis will be performed on, so you can get much better motion vectors<br/>
<b>Prefilters:</b> An easy parameter to load predefined <var>prefilter</var>s that perform well in most situations. It also accepts loading your personal <var>prefilter</var>ed clips.<br/>
<b>Degrain modes:</b> As a bonus you can try other temporal denoisers (mainly from the ex_median() function) with <var>mode</var> so you can test temporal medians from a simple medianT to a ML3Dex algorithm in a motion compensated fashion.<br/>
<b>Smear protection:</b> Smearing of low contrast shading is a known side-effect of MDegrain, as a solution the <var>LFR</var> argument was added to recover low frequency details along <var>DCTFlicker</var> to temporally calm down the recovered frequencies.<br/>
<b>Motion Filters:</b> It will allow you to filter those parts where <var>SMDegrain()</var> couldn't find a matching block, or in other words motion areas where <var>SMDegrain()</var> couldn't denoise. One use for it would be spatial denoisers or deblockers since motion areas are prone to heavy blocking and artifacts.<br/>
<b>Motion Vectors Globals Input/Output:</b> Reuse motion vectors <var>globals</var> for faster processing, or just use <var>SMDegrain()</var> as a shortcut for creating nice quality motion vectors.<br/>
<b>RefineMotion Option (MRecalculate):</b> Performs finer block matching refinement, unless you are very performance deprived you should use this as default for a quality boost.<br/>
<b>Show Panel:</b> Everything is off by default, but a few settings change in context (i.e. when in HD). Check what is happening behind the scenes and have a fast look at all your settings.<br/>
<b>Robust:</b> Everything listed above works together with each other indistinctly with interoperability, reliability and optimization in mind. The general idea is to serve as an user friendly front end for vanilla mvtools2+mdegrain or as the original script creator entitled <i>"To make your scripts shorter and less geeky"</i>. Most parameters are turned off or defaulted to MVTools2 defaults or close. Features are based on popular general conceived good practices and time tried-and-tested procedures.<br/>
<br/>
Parameters are arranged in 2 blocks.<br/>
<br/>
<b><a href="#basic">Basic:</a></b> For people who just need the most basic parameters because either they don't have the time, knowledge or interest into looking for complex settings. Or they are content with defaults (pretty much mvtools defaults)<br/>
<b><a href="#advanced">Advanced:</a></b> If you run into some problems, are nitpicking or just want to fine tune your settings according to the source, have a look at this block, it contains the rest and bulk of the function parameters.<br/>
<br/>
To picture what the function does, a simple <var>SMDegrain()</var> call matches the next code (for SD resolutions):<br/>
<br/>
<pre>
super_search = ex_Luma_Rebuild(S0=5.0,c=0.0312, bits=8).MSuper(rfilter=3,sharp=2)

bv2 = super_search.MAnalyse(isb = true,  delta = 2, overlap = 4, search = 2)
bv1 = super_search.MAnalyse(isb = true,  delta = 1, overlap = 4, search = 2)
fv1 = super_search.MAnalyse(isb = false, delta = 1, overlap = 4, search = 2)
fv2 = super_search.MAnalyse(isb = false, delta = 2, overlap = 4, search = 2)

MDegrain2(MSuper(levels=1), bv1, fv1, bv2, fv2, thSAD=300, thSADC=57, thSCD1=365, thSCD2=130)</pre>
<br/>
As you see nothing drastic. The only changes made are the TV->PC luma expansion (ex_Luma_Rebuild() call) so you have more range to detect motion vectors, and some Zopti optimized values; <var>rfilter</var> to 3 for a bit more quality super search, the changed default of <var>overlap</var> from 0 to 4, search from 0 to 2 which has a higher performance/quality ratio, and <var>thSAD</var> and <var>thSADC</var> from 400 to 300 and 57 respectively for safer results.<br/>
<br/>
This setup optimized internally along with <var>RefineMotion</var> might be all you need for most sources, but eventually you might encounter very grainy clips or simply noise and/or blocking. For these cases you can make use of the internal prefilter presets, but if those don't help even more creative approaches are required (see <var>prefilter</var> notes). The basis for good temporal denoising with SMDegrain is a good, source centric prefiltering, which in itself is a form of art.<br/>
<br/>

<p>&nbsp;</p>
<h2><a id="parameters"></a>Parameters&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<br/>
<p><i>SMDegrain (clip input, int <a href="#tr">"tr"</a>, int <a href="#thSAD">"thSAD"</a>, int <a href="#thSADC">"thSADC"</a>, bool <a href="#RefineMotion">"RefineMotion"</a>, val <a href="#contrasharp">"contrasharp"</a>, clip <a href="#CClip">"CClip"</a>, string <a href="#mode">"mode"</a>, bool <a href="#interlaced">"interlaced"</a>, int <a href="#plane">"plane"</a>, int <a href="#Globals">"Globals"</a>, bool <a href="#tv_range">"tv_range"</a>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <a href="#pel">"pel"</a>, int <a href="#subpixel">"subpixel"</a>, val <a href="#prefilter2">"prefilter"</a>, clip <a href="#mfilter">"mfilter"</a>, int <a href="#blksize">"blksize"</a>, int <a href="#overlap">"overlap"</a>, int <a href="#limit">"limit"</a>, float <a href="#limitC">"limitC"</a>, bool <a href="#limitS">"limitS"</a>, val <a href="#LFR">"LFR"</a>, bool <a href="#DCTFlicker">"DCTFlicker"</a>, int <a href="#thSCD1">"thSCD1"</a>, int <a href="#thSCD2">"thSCD2"</a>, &nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool <a href="#luma">"luma"</a>, bool <a href="#chroma">"chroma"</a>, int <a href="#hpad">"hpad"</a>, int <a href="#vpad">"vpad"</a>, val <a href="#Show">"Show"</a>, float <a href="#Str">"Str"</a>, float <a href="#Amp">"Amp"</a>, int <a href="#DCT">"DCT"</a>, int <a href="#searchparam">"searchparam"</a>, int <a href="#pelsearch">"pelsearch"</a>, int <a href="#search">"search"</a>, bool <a href="#truemotion">"truemotion"</a>, int <a href="#gpuid">"gpuid"</a>, int <a href="#rfilter">"rfilter"</a>, bool <a href="#UHDhalf">"UHDhalf"</a>)</i></p><br/>
<br/><br/>
<h3><a id="basic"></a>Basic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="tr"></a>tr</h4>
<i>[int: 1, "2", 3, 4, 5, 6, ...]</i><br/>
<br/>
Temporal radius. Select between <i>MDegrain</i> 1, 2, 3, 4, 5, 6 or higher. The higher generally the better, but also much slower and improvements get less drastic (diminished returns) to circumvent smearing or ghosting.<br/>
Also with larger 'tr' all the truemotion and vector penalty settings lose their meaning and turn basically to no-op.<br/>
This can be considered the strength of the denoising. Supports up to <var>tr=</var>128, 64 for interlaced.<br/>
<br/>
<h4><a id="thSAD"></a>thSAD, thSADC</h4>
<i>[int:"300"], [int:"226"] (for HD)</i><br/>
<br/>
<i>"Sum of Absolute Differences"</i> threshold. This is the spatial difference threshold where the motion search will consider whether to denoise given the next formula: <a href="https://forum.doom9.org/showthread.php?p=1562037" target="_blank">Denoise_Weight = max( 0, 1 - 2*blockSAD² / (thSAD² + blockSAD²) )</a><br/>
This spatial difference will be compared in blocks (<var>blksize</var>). If your noise is not getting into consideration for the denoising try raising this value, or reduce its SAD with previous <var>prefilter</var>ing.<br/>
You can alternatively raise the block size (<var>blksize</var>), which will likely even blocks SAD. Low values can result in staggered/blotchy denoising, large values can result in ghosting and artifacts. Values in the range 200~600 are usual.<br/>
<var>thSADC</var> is the same logic applied to chroma <var>plane</var>s, since there are less differences on the chroma planes it uses by default ~<var>thSAD</var>/5 for safer chroma results (internally uses a function fit).
<br/><br/>
<h4><a id="contrasharp"></a>Contrasharp</h4>

<i>[bool: true, "false"] or [int: 0 ~ 100 ]</i><br/>
<br/>
Contrasharpening is a technique that compares the differences between the clip before blurring (original) and after blurring (filtered), and compensates (sharpens) locally with consequent strength.<br/>
By default the before "sharp" clip is the one used as input for <var>SMDegrain()</var>, the "after" clip is the denoised clip. Independently a "before" clip can be specified with the <var>CClip</var> parameter (See <a href="#CClip">below</a>)<br/>
<br/>
<var>Contrasharp</var> when set to "true", will use ex_ContraSharpening() (an ExTools mod to Didée's <i>Contrasharpening()</i>) which:<br/>
  <i>"Sharpens the denoised clip, but doesn't add more to any pixel than what was removed previously"</i><br/>
   In the practice you will get a slightly sharper result than the source, which is welcome.<br/>
In the other hand if your parameter input is an integer, <i>LSFplus()</i> (an optimized LSFmod mod) will be used instead. It will be slower, but maybe better for certain sources.<br/>
Its value will serve as a <var>contrasharp</var>ening multiplier, use one around 50 for similar strength as <i>ex_ContraSharpening()</i>.
<br/><br/>
<h4><a id="RefineMotion"></a>RefineMotion</h4>

<i>[bool: true, "false"]</i><br/>
<br/>
Refines and recalculates motion data of previously estimated (by <i>MAnalyse</i>) motion vectors.<br/>
Turn it on for better motion vectors, specially when dealing with ghosting issues, small details or lineart fading and whatnot.<br/>
&nbsp;&nbsp;*<i>Beware: It won't enhance much if you use a <var>prefilter</var> (in case you use it) so strong that blurs too much or kills all the details you are aiming to "refine" in first place.</i>
<br/><br/>
<h4><a id="interlaced"></a>Interlaced</h4>

<i>[bool: true, "false"]</i><br/>
<br/>
By default not needed since it will be read from frame properties, but if you are getting issues or just want to play it safe set this parameter to true. Output will also be <var>interlaced</var>.<br/>
Note that must feed directly interlaced clips into <var>CClip</var>, <var>prefilter</var>, or <var>mfilter</var>, without the need to separate fields. Check examples on the bottom section.<br/>
Given the packing sub-format for interlaced clips, the minimum 'tr' allowed is of 2 even if tr=1 is set, and jumps in 2 so for tr=3 -> 4, tr=4 -> 4, and so on.
<br/><br/>
<h4><a id="plane"></a>plane</h4>

<i>[int: 0, 1, 2, 3, "4"]</i><br/>
<br/>
Select the planes you wish to process:<br/>
<ul>
    <li>0 - luma only</li>
    <li>1 - chroma U</li>
    <li>2 - chroma V</li>
    <li>3 - both chromas</li>
    <li>4 - all (Default)</li>
</ul>
&nbsp;&nbsp;*<i>Keep in mind that <var>plane</var>=4 (2 and 3 as well) can sometimes create chroma smearing. In such case I recommend denoising chroma <var>planes</var> separately in the spatial domain.</i>
<br/><br/>
<h4><a id="prefilter"></a>prefilter</h4>
<i>[int: "-1", 0, 1, 2, 3, 4, 5, 6, 7, 8] or [clip: - ] or [string: "", "SBR", "MinBlur", "MinBlur2", "MinBlur3", "IQMST", "DFTTest", "KNLMeans", "DGDenoise", "BM3D"]</i><br/>
<br/>
See <a href="#prefilter2">below</a> for a review of prefilter presets.
<br/><br/><br/><br/>
<h3><a id="advanced"></a>Advanced&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="mode"></a>mode</h4>
<i>[string: "MDegrain", MedianT, MedianST, MedianSTS, <a href="http://avisynth.nl/index.php/TemporalSoften" target="_blank">TemporalSoften</a>, TemporalSmooth, <a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/ExTools.avsi#L1454" target="_blank">TemporalGauss</a>, <a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/ExTools.avsi#L2035" target="_blank">FluxSmoothT</a>, <a href="http://avisynth.nl/index.php/Dfttest" target="_blank">DFTTest</a>, ML3DEx, Hybrid, TL3D, STWM, IQMT, GaussST5]</i><br/>
<br/>
Defines the filter for the temporal degrain. Normally should be left at default MDegrain which works best, but using other modes can provide Motion Compensation filtering<br/> to filters that aren't motion protected like ML3DEx, IQMT, etc. probably for prefiltering or other uses. Most of these modes are explained in ExTools ex_median() entry (<a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/ExTools.avsi#L2299" target="_blank">link</a>).<br/>
If you append 'r' to the mode string (ie. rMedianT) it tells the filter to run twice for recursion, as a cheap way of <a href="#prefilter">Degrain Refinement</a>.<br/>
TemporalSoften and TemporalSmooth are not supported in recursion mode to prevent ghosting, caution with TemporalGauss as well.
<br/><br/>
<h4><a id="pel"></a>pel</h4>
<i>[int: "1", 2, 4]</i><br/>
<br/>
Accuracy of the motion estimation.
<ul>
    <li>1: means a precision to the pixel. (Default for HD material)<br/>
    <li>2: means a precision to half a pixel. (Default for SD material)
    <li>4: means a precision to quarter a pixel, produced by spatial interpolation (more accurate but slower and not always better due to big level scale step).
</ul>
<br/>
<h4><a id="subpixel"></a>subpixel</h4>
<i>[int: 0, 1, 2, "3", 4]</i><br/>
<br/>
Subpixel accuracy. It chooses an interpolation method for <var>pel=</var>2 or 4. This is the 'sharp' parameter in <i>msuper()</i> extended with modes 3 and 4.<br/>
Unrelated to output sharpness but accuracy for the motion estimation.<br/>
<ul>
    <li>subpixel = 0 for soft interpolation (bilinear)</li>
    <li>subpixel = 1 for bicubic interpolation (4 tap Catmull-Rom)</li>
    <li>subpixel = 2 for sharper Wiener interpolation (6 tap, similar to Lanczos)</li>
    <li>subpixel = 3 for blackman taps=6 high quality subpixel interpolation (Default)</li>
    <li>subpixel = 4 for nnedi3 high quality subpixel interpolation</li>
</ul>
For <var>subpixel=</var>4 you will need nnedi3 (gpuid=-1) or NNEDI3CL (gpuid=0) plugin. Very useful when used along <var>pel=</var>4 on very small sources, although overkill and unnecesary in most cases.<br/>
<br/>
<h4><a id="rfilter"></a>rfilter</h4>
<i>[int: 0, 1, 2, "3"]</i><br/>
<ul>
    <li>0 : simple 4 pixels averaging like unfiltered SimpleResize (old method)</li>
    <li>1 : triangle (shifted) filter like ReduceBy2 for more smoothing (decreased aliasing)</li>
    <li>2 : triangle filter like BilinearResize for even more smoothing</li>
    <li>3 : quadratic filter for even more smoothing (Default)</li>
    <li>4 : cubic filter like BicubicResize(b=1,c=0) for even more smoothing</li>
</ul>
Hierarchical levels smoothing and reducing (halving) filter.<br/>
Set and forget setting. Mode 3 gives the most accuracy for downscaling.<br/>
<br/>
<h4><a id="prefilter2"></a>prefilter</h4>
<i>[int: "-1", 0, 1, 2, 3, 4, 5, 6, 7, 8] or [clip: - ] or [string: "", "SBR", "MinBlur", "MinBlur2", "MinBlur3", "IQMST", "DFTTest", "KNLMeans", "DGDenoise", "BM3D"]</i><br/>
<br/>
<ul>
    <li>-1 = off (Default)</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/SMDegrain/SMDegrain.avsi#L765" target="_blank">0</a> = light controlled gauss blur</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/SMDegrain/SMDegrain.avsi#L691" target="_blank">1</a> = mild median/gauss blur</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/SMDegrain/SMDegrain.avsi#L691" target="_blank">2</a> = strong median/gauss blur</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/ExTools.avsi#L2299" target="_blank">3</a> = very strong median/gauss blur (IQMV -Variable Inter Quartile Median- filter)</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/ExTools.avsi#L2299" target="_blank">4</a> = spatio-temporal median/gauss filter (IQMST)</li>
    <li><a href="http://avisynth.nl/index.php/Dfttest" target="_blank">5</a> = DFTTest (spatial)</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/SMDegrain/SMDegrain.avsi#L1213" target="_blank">6</a> = KNLmeansCL (spatio-temporal non-local means OpenCL GPU filter)*</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/SMDegrain/SMDegrain.avsi#L1160" target="_blank">7</a> = DGDenoise (spatial non-local means Cuda GPU filter)*</li>
    <li><a href="https://github.com/Dogway/Avisynth-Scripts/blob/fd8dacee9f11273b4b1d0a93af29e01570a4b461/SMDegrain/SMDegrain.avsi#L1055" target="_blank">8</a> = BM3D (temporal BM3D Cuda GPU filter)*</li>
    <li>- = <var>prefilter</var>ed clip input variable</li>
  *Watch out for OpenCL or CUDA version compatibilities with your GPU vendor
</ul>
<br/>
Despite being one of the most advanced filters for AviSynth, MVTools is <a href="https://forum.doom9.org/showthread.php?p=1969568" target="_blank">lacking</a> important motion predictors like rotate/scale-zoom/skew...<br/>
Currently only translation transforms are being predicted and therefore we need to help MAnalyse client function as much as possible to create accurate motion vectors.<br/>
<br/>
For this reason precisely one of the most important aspects for a satisfactory denoising in SMDegrain is to provide clean reference frames for MAnalyse,<br/>
specially when the source is grainy, technically speaking by lowering the SAD (Sum of Absolute Differences) where it matters most.
<br/><br/>
If you didn't realize already, most of the settings in MVTools and SMDegrain revolve around conditioning this <var>prefilter</var>ed clip.<br/>
From <var>pel</var>, going through <var>subpixel</var>, to luma expansion (<var>Str</var> and <var>Amp</var>) and obviously <var>prefilter</var>s.<br/>
<br/>
In general terms spatial prefiltering is enough (presets from 0 to 3 and 5 and 7) while very grainy sources might require spatio-temporal filters (presets 4, 6 and 8).<br/>
The goal here is not to provide a fully perfectly denoised clip but a slightly soft or out-of-focus version of an ideal clean clip, that is, soft edges (but not blurry) and clean flat areas.<br/>
For example cartoons may display many flat areas that work great with median filters (1 to 3) or even non-local means (6 and 7). While live action, depending on<br/> the nature of the grain, can use the spatial prefilters which are faster or BM3D (preset  8). Custom external prefilters will also be explained below.<br/><br/>
To put denoising filters in comparison back to back, we can broadly order them in the following sequence of quality:<br/>
<pre>BM3D (Block Matching 3D) > NLMeans > SAD Block Matching (MVTools) > Frequency Filters (FFT/DFT..) > Bilateral > Median > simple linear filters (Gaussian Filter, Wiener Filter...)</pre><br/>
<br/>
Another useful way to think about prefilters for example when building custom prefiltered clips is to treat the clip as if you were filtering as usual without SMDegrain, that is,<br/>
using Deblockers if blocking is present, Decrawlers, cleaning Gibbs noise, some spatial denoiser, etc. Then this clip is only fed to <var>prefilter</var> while the original is used as input for SMDegrain.<br/>
By doing this all those issues will be cleaned temporally more effectively while retaining more details. Now, yes, areas where block matching failed (motion areas) will passthrough<br/>
the original clip with all its artifacts, so the trick is to feed the same clip to <var>mfilter</var>, so motion areas will apply the <var>prefilter</var> clip spatially while stable areas will only treat them <a href="https://forum.doom9.org/showthread.php?p=1980946" target="_blank">temporally</a>.<br/>
<pre>pre=my_custom_prefiltering().ex_sbr() <font style="color:Green;"><b># sbr to soften edges</b></font>
SMDegrain(last,prefilter=pre,mfilter=pre)</pre><br/>
<br/>
Now you might think, if SMDegrain is so good, why not use it also for prefiltering?<br/>
Good question, and yes, that's actually one of the recommendations for fizz grain or simply very grainy sources (films like "300", "21 grams", etc).<br/>
Just keep in mind that running MVTools2 twice in the same script may lower performance greatly, but using a low radius (<var>tr</var>) can help towards that.<br/>
<br/>
For example, we have a very grainy 1080p source so we are going to apply quite extreme settings.<br/>
<pre>pre=SMDegrain(tr=1,mode="TemporalSoften",blksize=32,prefilter=8  ,thSAD=700,LFR=400,DCTFlicker=false,contrasharp=false,refinemotion=true)
    SMDegrain(tr=2,mode="MDegrain"      ,blksize=32,prefilter=pre,thSAD=400,LFR=200,DCTFlicker=true ,contrasharp=true ,refinemotion=true)</pre>
<br/>
TemporalSoften and TemporalGauss are two degraining <var>mode</var>s that switch a few internal settings to make it more temporally stable. It's quite an extreme approach<br/>
also with <var>blksize</var>=32 and <var>thSAD</var>=700, therefore we should recover some low frequency smearing with <var>LFR</var>=400 and <var>LFR</var>=200, <var>DCTFlicker</var>=true in the second call.<br/>
Following we feed this <var>prefilter</var> clip to the next SMDegrain call with saner settings of 'MDegrain' and <var>thSAD</var>=400.<br/>
<i>*For these two degraining modes you might want to manually tweak the <var>thSCD1</var> value, specially in the <var>thSAD</var> 400 to 800 range.<br/>
Higher than that it's automatically parametrized to give the lowest <var>thSCD1</var> value (prevents filtering across scene changes) with reasonable filtering.</i><br/>
<br/>
The above is for mild to strong sources, for very strong ones like "21 grams" I found myself using a double call:<br/>
<pre>SMDegrain(tr=3,mode="TemporalSoften",blksize=32,thSAD=1200,LFR=300,DCTFlicker=true,contrasharp=false,refinemotion=true)
SMDegrain(tr=1,mode="MDegrain"      ,blksize=32,thSAD=300 ,LFR=false              ,contrasharp=true ,refinemotion=true)</pre>
<br/>
Another option:
<pre>SMDegrain(tr=3,mode="TemporalGauss" ,blksize=32,thSAD=1300,LFR=300  ,contrasharp=false,refinemotion=true)
SMDegrain(tr=2,mode="TemporalSoften",blksize=32,thSAD= 600,LFR=false,contrasharp=true ,refinemotion=true)</pre>
<br/>
Another one this time with <var>prefilter</var>:
<pre>pre=ex_bm3d(60,3,preset="noisy")
SMDegrain(tr=2,mode="TemporalSoften",blksize=32,thSAD=600,prefilter=pre,refinemotion=true)
ex_unsharp(0.2,Fc=width()/2) <font style="color:Green;"><b># Remove the dreamy/softness look</b></font></pre>
<br/>
And another one with <var>prefilter</var> (the possibilities are endless so choose your poison):
<pre>SMDegrain(tr=3,mode="TemporalSoften",thSAD=600,LFR=300,DCTFlicker=true,prefilter="IQMST",refinemotion=true)</pre>
<br/>
The double call method is called <b>Degrain refinement</b>, while the ones using <var>prefilter</var> are called <b>Motion Vector refinement</b>, and both are considered<br/>
pyramidal refinements as you lower the strength of the prefilter/denoising the lower the stack. You can also mix both methods and experiment.<br/>
Double calls are effective in the sense that it naturally applies a binomial weighting to the pixels, the furthest frames having less weight,<br/>
just like two stacked mean/box blurs approximate a binomial blur in the spatial domain.<br/>
<br/>
Needless to say you can get prefiltering as complex as you wish, by using masking and other filters like ex_retinex(), ex_autolevels(), etc.<br/>
Creating these discerning masks and prefiltering chains is a research task on the end user side.<br/>
Might sound obvious but note that when feeding a clip to <var>prefilter</var> the clip format (dimensions, pixel type, etc) should match SMDegrain() input format.<br/>
<br/>
<br/>
Some (very) old examples of custom <var>prefilter</var>ing, for history:<br/>
<ul>
    <li><a href="https://forum.doom9.org/showthread.php?p=1544619" target="_blank">https://forum.doom9.org/showthread.php?p=1544619</a></li>
    <li><a href="https://forum.doom9.org/showthread.php?t=162813" target="_blank">https://forum.doom9.org/showthread.php?t=162813</a></li>
    <li><a href="https://forum.doom9.org/showthread.php?t=132310" target="_blank">https://forum.doom9.org/showthread.php?t=132310</a></li>
    <li><a href="https://forum.doom9.org/showthread.php?t=133977" target="_blank">https://forum.doom9.org/showthread.php?t=133977</a></li>
    <li><a href="https://forum.doom9.org/showthread.php?p=1367709" target="_blank">https://forum.doom9.org/showthread.php?p=1367709</a></li>
</li>
</ul>
<br/>This last example is a function called Calm(), wrapped by Terka but it's basically QTGMC's default prefiltering from line <a href="https://github.com/Dogway/Avisynth-Scripts/blob/f2d777aadaa7915edc73ba07f2ffd749429cf116/MIX%20mods/QTGMC%2B.avsi#L460" target="_blank">460</a> to <a href="https://github.com/Dogway/Avisynth-Scripts/blob/f2d777aadaa7915edc73ba07f2ffd749429cf116/MIX%20mods/QTGMC%2B.avsi#L492" target="_blank">492</a> using TR0=2 and SrchClipPP=3.<br/>
It's basically a TemporalGauss, with some limiting and a gaussian blur. What he missed was adding KeepOnlyBobShimmerFixes() which removes <i>"most"</i> TemporalSoften frame blending artifacts.<br/>
My improved alternative was already given above, but adding ex_sbr() instead of a gaussian blur:<br/>
<pre>pre=SMDegrain(2,thSAD=1600,mode="TemporalGauss",pel=1,rfilter=0,str=0,tv_range=false,plane=0,truemotion=true) <font style="color:Green;"><b># Tuned for speed or "dumb" MV</b></font>
pre=pre.ex_sbr(3,UV=3)</pre>
*You can read more about this and a stronger alternative more similar to Calm() for DeWobble on this <a href="https://forum.doom9.org/showthread.php?p=1984051" target="_blank">post and following pages.</a><br/>
<br/>Notes:
To sum it up; generally in denoising, temporal filters are always preferred due to its natural look (versus spatial filters).<br/>
But more often than not for good results <var>prefilter</var>ing plays a key role on the output quality, and setting it up nicely can be looked as an art by itself.<br/>
<br/>
<h4><a id="mfilter"></a>mfilter</h4>
<i>[clip: - ]</i><br/>
<br/>
As with <var>prefilter</var>, in mfilter (Motion Filter) you can add a clip variable. This clip will be passed through those areas where SMDegrain() couldn't find a matching block, normally high motion areas.<br/>
One use for it would be to use spatial filters, like deblockers or blurring filters that mimic motion blur.<br/>
Clip should match input format.<br/>
<br/>
<h4><a id="Str"></a>Str</h4>
<i>[float: 0.0 ~ 8.0]  Default: 5.0</i><br/>
<br/>
Based on the original <a href="https://forum.doom9.org/showthread.php?p=1548318" target="_blank">function</a> by cretindesalpes', with this parameter you control the strength of the brightening of the <var>prefilter</var> clip.<br/>
Unless you are filtering sports or TV shows aimed at daytime you most likely want this turned on at default value.<br/>
MVTools2 has issues on low frequency areas like shadows and shade details where the human eye excels at, so enhancing<br/>
the dynamic range of this area makes it easier for MAnalyse to create better motion vectors and avoid smearing.<br/>
This luma expansion is performed in the same stage as the TV->PC range conversion thus more memory friendly and less quantization artifacts.<br/>
From 0.0 to 1.0 (1.0 being no-op) uses ex_retinex(), the value will serve as the normalization factor (ie. 0.40 to normalize black to pixel value of 40 -in 8-bit scale-).<br/>
Use <var>show</var> to review the brightening curve for >1.0 values.<br/>
<br/>
<h4><a id="Amp"></a>Amp</h4>
<i>[float: 0.0 ~ 1.0]  Default: 0.0312</i><br/>
<br/>
Use this together with <var>Str</var>. This defines the amplitude of the brightening in the luma range, for example by using 1.0 all the<br/>
luma range will be used and the brightening will find its peak at luma value 128 in the original. Default is 0.0625 (1.0/16) which just sits over luma value 16 (256/16)<br/>
<br/>
<h4><a id="LFR"></a>LFR</h4>
<i>[bool: true, "false"] or [int: 50 ~ Resolution]</i><br/>
<br/>
Cutoff frequency for Low Frequency Restore -LFR-. 'true' enables a lowpass equal to 300 for a 1080p clip.<br/>
Useful in the presence of smearing when using too extreme settings (high <var>tr</var>, <var>thSAD</var>, <var>prefiltering</var>, etc).<br/>
The value represents a cutoff in resolution units of the maximum dimension, so for example 300 would lowpass all details above 1920/300 = 6.4 pixels wide.<br/>
<br/>
<h4><a id="DCTFlicker"></a>DCTFlicker</h4>
<i>[bool: true, "false"]</i><br/>
<br/>
Only works when <var>LFR</var> is activated. It tries to stabilize low frequency flicker produced by grain propagated to low frequencies by the DCT compression algorithm.<br/>
When enabled it will only pass low frequencies to motion areas and filtered through a custom temporal denoiser to <i>calm</i> the flicker. Only enable this when your source is very grainy.<br/>
<br/>
<h4><a id="blksize"></a>blksize</h4>
<i>[int: 4, 8, "16", 32, 48, 64]</i><br/>
<br/>
Size of a block (horizontal). (Default 16 for HD material)<br/>
Larger blocks are less sensitive to noise, are faster, but also less accurate.<br/>
<br/>
<h4><a id="overlap"></a>overlap</h4>
<i>[int: "<var>blksize</var>/2"]</i><br/>
<br/>
Must be *even* and *less* than block size. Common <var>overlap</var> values: <var>blksize</var>/4 or <var>blksize</var>/2.<br/>
The greater <var>overlap</var>, the more block count, and the lesser more processing speed.<br/>
<br/>
<h4><a id="search"></a>Search</h4>
<i>[int: 0, 1, "2", 3, 4, 5, 6, 7]</i><br/>
<br/>
    <ul>
    <li>0 = 'OneTimeSearch'</li>
    <li>1 = 'NStepSearch'</li>
    <li>2 = Logarithmic (Default)</li>
    <li>3 = Exhaustive</li>
    <li>4 = Hexagon</li>
    <li>5 = Uneven Multi Hexagon (UMH)</li>
    <li>6 = pure Horizontal exhaustive search</li>
    <li>7 = pure Vertical exhaustive search</li></ul>
By default 2, but switched to 4 when <var>RefineMotion</var> is enabled.<br/>
See details at <a href="http://avisynth.nl/index.php/MVTools" target="_blank">MVTools2</a> documentation.<br/>
<br/>
<h4><a id="DCT" ></a><a id="searchparam" ></a><a id="pelsearch" ></a>DCT, searchparam, pelsearch</h4>
<i>[-]</i><br/>
<br/>
See details at <a href="http://avisynth.nl/index.php/MVTools" target="_blank">MVTools2</a> documentation.<br/>
<br/>
<h4><a id="Truemotion"></a>Truemotion</h4>
<i>[bool: true, "false"] * "true" for SD</i><br/>
<br/>
<var>Truemotion</var> is a preset of some parameters values. It allows easy to switch default values of all "true motion" parameters at once.<br/>
Set it 'true' for true motion search (high vector coherence), set it 'false' to search motion vectors with best SAD.<br/>
Default is 'true' (as in MVtools2 default, and contrary to MCTemporalDenoise()).
By turning it off it could protect better low frequency<br/>
 details (shading) when in motion (i.e. walls, grounds, clouds texture, motion blur, etc), and also protect from tiny details loss but it could leave more noise unfiltered.<br/>
<br/>
Default is 'true' for SD for smoother/cleaner (more temporal coherence) high frequency details or lineart. For HD sources where the main problems are just excessive grain,<br/>
I have defaulted it to false, this is not only faster but honors detail accuracy (the main existing point for HD sources) and overall object shading.<br/>
<br/>
<h4><a id="chroma"></a>Chroma</h4>
<i>[bool: "true", false]</i><br/>
<br/>
Takes chroma <var>plane</var>s into consideration for calculating the motion vectors.<br/>
Turn it off for more speed with little cost in quality, or when your chroma is not reliable enough for motion estimation.<br/>
&nbsp;&nbsp;*<i>Whatch out if you turn this off when processing chroma planes (aka luma vectors when chroma denoising), it has shown problems in <a href="https://forum.doom9.org/showthread.php?p=1551305" target="_blank">previous tests</a>.</i><br/>
<br/>
<h4><a id="luma"></a>Luma</h4>
<i>[bool: "true", false]</i><br/>
<br/>
Takes luma <var>plane</var> into consideration for calculating the motion vectors.<br/>
For example if you were to denoise only Chroma planes (plane=1, 2 or 3), you might or might not want to use vectors from the Luma plane.<br/>
Actually MVTools2 doesn't have an option for this, so what this does is concerned to prefilters and finally a luma weighting that is half of the chroma on the MVTools2 side.<br/>
<br/>
<h4><a id="hpad"></a>Hpad, Vpad</h4>
<i>[int: "<var>blksize</var>"]</i><br/>
<br/>
It is horizontal/vertical padding added internally to source frame (both left and right, and top and bottom).<br/>
Small padding is added for more correct motion estimation near frame borders.<br/>
Try to have clean borders in your source (no NAB*/black borders) to start with before tweaking this setting.<br/>
If necessary, crop beforehand ideally in multiples of 16. Turn it to 0 if you are running out of resources in your system.<br/>
*<i>Nominal Analog Blanking</i><br/>
<br/>
<h4><a id="thSCD1"></a>thSCD1</h4>
<i>[int: "365"]</i><br/>
<br/>
Threshold which decides whether a block has changed between the previous frame and the current one. So it is one of the thresholds used to tweak the scene changes detection engine.<br/>
Raising it will lower the number of blocks detected as changed. It may be useful for noisy or flickered video. To fix blending on scene changes on dark scenes, try first the <var>Str</var> and <var>Amp</var> parameters.<br/>
<br/>
<h4><a id="thSCD2"></a>thSCD2</h4>
<i>[int: 0~"130"~255]</i><br/>
<br/>
Threshold which sets how many blocks have to change for the frame to be considered as a scene change.<br/>
<br/>
<h4><a id="limit"></a><a id="limitC"></a>limit,limitC</h4>
<i>[int: 1 ~ "255"]</i><br/>
<br/>
Maximal change of pixel luma/chroma (post-process like DeGrainMedian plugin<br/>
and LimitChange function of SSETools plugin, to prevent some artifacts)<br/>
<br/>
<h4><a id="limitS"></a>limitS</h4>
<i>[bool: "true", false]</i><br/>
<br/>
Limit type for the <var>contrasharp</var>ening: True: Spatial, False: Temporal (ignores <var>CClip</var>).<br/>
False (temporal) might give a more natural look albeit softer, so you might want to raise the <var>contrasharp</var>ening a bit.<br/>
<br/>
<h4><a id="CClip"></a>CClip</h4>
<i>[clip: - ]</i><br/>
<br/>
Define here a variable name referencing an earlier stage of your processing chain as the sharp version for the <var>contrasharp</var>ening to compare against.<br/>
If <var>contrasharp</var> is not declared, by default it will use the <i>ex_ContraSharpening()</i> function, add <var>contrasharp=</var>'an integer' to force <i>LSFplus()</i> instead.<br/>
Clip should match input format.<br/>
<br/>
<h4><a id="gpuid"></a>gpuid</h4>
<i>[int: -1, "0", 1... ]</i><br/>
<br/>
Enables GPU processing for the filters that support them. -1 is CPU mode, 0 is default GPU and >0 is device ID if you have more than one GPU.<br/>
-1 (CPU mode) is only for NNEDI3 (for subpixel=4) and BM3D (prefilter=8) as <var>prefilter</var> with KNLMeansCL is currently GPU only.<br/>
<br/>
<h4><a id="UHDhalf"></a>UHDhalf</h4>
<i>[bool: "true", false]</i><br/>
<br/>
For performance reasons computes motion vectors from a halved version of an UHD clip. Then the motion vectors are upscaled back to UHD resolution for denoising.<br/>
Keep aware that quality while good won't be on par with plain UHD denoising (<var>UHDHalf</var>=false), specially on low SAD areas where some slight blurring<br/>
or detail warping can happen. For this reason you might want to limit denoising to a value of 2 or 1 to minimize the effect (test with <var>limit</var>=2).<br/>
<br/>
<h4><a id="Globals"></a>Globals</h4>
<i>[int: "0", 1, 2, 3 ]</i><br/>
<br/>
With this parameter you can, among other things, load pre-processed motion vectors (<var>Globals=</var>1), so you save doing this step again.<br/>
<br/>
The integers define what to do with the global variables. Default is 0.<br/>
<br/>
 <ul>
    <li>0: Don't read nor output globals (Just process) (Default)</li>
    <li>1: Read globals --> Process</li>
    <li>2: Process      --> Output globals</li>
    <li>3: Output globals only (Don't process clip)</li></ul>
<br/>
Some parameters MUST MATCH those from the processed vectors stage (e.g. <var>Globals=</var>2 or 3) and the read vectors stage (e.g. <var>Globals=</var>1).
<var>pel=</var>, <var>subpixel=</var>, <var>chroma=</var> and <var>vpad/hpad</var>.<br/>
Other than that the only settings that work when reading (<var>Globals=</var>1) are: <var>tr=</var>, <var>thSAD=</var>, <var>plane</var>, <var>limit</var>, <var>limitc</var>, <var>contrasharp</var>, <var>CClip</var> and the <var>interlaced</var> parameters. Others are ignored.<br/>
Global names that can be reused are: <var>Super</var>, <var>bv1</var>, <var>fv1</var>, <var>bv2</var>, <var>fv2</var>, <var>bv3</var>, <var>fv3</var>, <var>bv4</var>, <var>fv4</var>, <var>bv6</var>, <var>fv6</var>, <var>vmulti</var>.<br/>
<br/>
e.g.:<pre>
                         SMDegrain(tr=3,thSAD=400,globals=3)    <font style="color:Green;"><b># Outputs vectors</b></font>

                         SMDegrain(tr=2,thSAD=200,globals=1)    <font style="color:Green;"><b># You can use a same or lower "tr" or "thSAD" if you want</b></font></pre>
or<pre>

                         SMDegrain(tr=3,thSAD=400,globals=3)    <font style="color:Green;"><b># Outputs vectors</b></font>

                         Super = MSuper(levels=1)               <font style="color:Green;"><b># Add this line just before if you have some processing between Globals Output and Input.</b></font>
                         MDegrain3(Super, bv1, fv1, bv2, fv2, bv3, fv3, thSAD=400)</pre>
<br/>
<h4><a id="Show"></a>Show</h4>
<i>[bool: true, "false" ] or [string: "Speed", "Memory", "Quality" ]</i><br/>
<br/>
This will show the brightening curve graph over the <var>prefilter</var>ed clip to be used for the motion search to the left(<--), and the used parameters list to the right (-->)<br/>
<br/>
If you set <var>Show</var> to a string as indicated above, related parameters will be highlighted to guide you on correctly tweaking the function.<br/>
This is loosely based, so it doesn't exclude you from reading carefully every parameter explanation.<br/>
<br/>
Even when you are not using any <var>prefilter</var>ing, the clip to be used for the motion search where you obtain the motion vectors,<br/>
will be converted from TV levels to PC levels, the only exception being when using <var>Globals=</var>1 (Read) in which case the "<var>prefilter</var>ed" clip<br/>
will be exactly the same as input clip (that is no luma conversion, although constrained to 8 bit). Additionally you can tweak the dark expansion with<br/>
<var>Str</var> and <var>Amp</var> parameters and check the effects in the left panel, but be aware to change your viewing conditions as it is in PC levels.<br/>
<br/>
If you are not processing chroma for motion analysis (<var>chroma=</var>false) the <var>prefilter</var>ed clip will be green, don't panic, this is correct, this happens when the<br/>
U and V <var>plane</var>s are set to a value of 0 which is a dummy value meaning nothing or "discard". In this regard for previewing tasks simply set <var>chroma</var> to true temporarily.
<p>&nbsp;</p>
<h2><a id="examples"></a>Example Scripts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<br/>
A basic yet very functional call for light grain.
<pre>SMDegrain(tr=1,thSAD=300,contrasharp=true)</pre>
<br/>
A personal preference. Turned all chroma off for safeness (on SD, chroma is rarely temporal-reliable enough) and speed.
<pre>SMDegrain(tr=2,thSAD=300,contrasharp=true,refinemotion=true,chroma=false,plane=0)</pre>
<br/>
This is a good example to show that <var>interlaced</var> YUY2 sources can be processed seamlessly.
<pre><font style="color:Green;"><b># Interlaced YUY2 source</b></font>
SMDegrain(tr=1,thSAD=250,interlaced=true,contrasharp=true)</pre>
<br/>
Denoising interlaced with a custom prefilter.
<pre>pre=SMD_UnfoldFieldsVertical().STTWM().SMD_FoldFieldsVertical() <font style="color:Green;"><b># Tailored SeparateFields then Interleaving back</b></font>
SMDegrain(tr=1,thSAD=250,interlaced=true,prefilter=pre,contrasharp=true)</pre>
<br/>
HD sources are detected automatically, and as so settings are optimized for speed; <var>pel=</var>1, <var>blksize=</var>16, <var>overlap=</var>8, <var>truemotion=</var>false
<pre><font style="color:Green;"><b># HD source (from 1100px wide or 600px high up)</b></font>
SMDegrain(tr=2,thSAD=180,prefilter=2,contrasharp=30,refinemotion=true,chroma=false,plane=0)</pre>
<br/>
Tackling a grainy source pragmatically.
<pre>SMDegrain(tr=3,thSAD=500,contrasharp=40,prefilter=8,refinemotion=true)</pre>
<br/>
How to reference a prior state of the script for the <var>contrasharp</var>ening process.
<pre>sharp_ref=last
Deblock_QED(quant1=30, quant2=40)

SMDegrain(tr=3,thSAD=300,CClip=sharp_ref)</pre>
<br/>
Leverage <var>prefilter</var> and <var>mfilter</var> for a spatio-temporal deblock on an mpeg file.<br/>
Also set contrasharpening to temporal limited (limitS)
<pre>pre=Deblock_QED(quant1=30, quant2=40)
SMDegrain(2, 200, prefilter=pre, mfilter=pre, refinemotion=true, contrasharp=60, limitS=false, chroma=false)</pre>
<br/>
How to degrain an PQ encoded HDR clip. Note that <var>prefilter</var> clips also pass through ex_Luma_Rebuild() internally.
<pre>pre=DGHDRtoSDR(YUV420P16_Lim, mode="pq", gamma=1/2.4, tm=1.0, white=1500) <font style="color:Green;"><b># Check different white levels (60, 100, 203 or default 400) depending on source metadata</b></font>
SMDegrain(tr=3,thSAD=300,prefilter=pre,UHDHalf=true)                      <font style="color:Green;"><b># 'UHDHalf' enabled (Default) for a performance boost</b></font></pre>
<br/>
(Re)using motion vectors <var>globals</var>.
<pre>SMDegrain(tr=1,thSAD=400,prefilter=3,str=1.4,globals=3) <font style="color:Green;"><b># Output vectors only</b></font>
MFlowFps(Super, bv1, fv1, num=60,den=1)</pre>
<br/>
<p>&nbsp;</p>
<h2><a id="finalnotes"></a>Final Notes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
If there is an important parameter not implemented,<br/>
you have any issue or found a bug, please don't hesitate<br/>
and ask in the main Doom9 thread:<br/><br/>
(<a href="https://forum.doom9.org/showthread.php?t=182881" target="_blank">https://forum.doom9.org/showthread.php?t=182881</a>)<br/>
<br/>
<b>What to expect for the future?</b><br/>
As DLSS3 enabled RTX GPUs lower the prices and AMD plays the catch up game<br/>
we might see more GPU based motion estimation APIs that open up advanced options<br/>
for very high quality motion vectors at reasonable or even good speeds.<br/>
Machine learning is also getting its way into AviSynth+ thanks<br/>
to the work of Asd-g and other active members, so the future is bright.<br/>
<p>&nbsp;</p>
<h2><a id="changelog"></a>Changelog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<p><b>v4.4.0d</b> (16-05-2023)</p>
    <ul>
        <li>Change back default for 'limit'</li>
        <li>Add better example for DGHDRtoSDR() prefiltering.</li>
        <li>Documentation updates.</li>
    </ul>
<p><b>v4.3.0d</b> (01-04-2023)</p>
    <ul>
        <li>Construct vector variables in a for loop</li>
        <li>Fix 'mode', 'mfilter' and 'LFR' when isMult (tr > 6)</li>
        <li>Swizzle in unprocessed planes to MFilter clip when the option is used</li>
    </ul>
<p><b>v4.2.0d</b> (27-03-2023)</p>
    <ul>
        <li>Fix ex_DGDenoise() when processing chroma</li>
        <li>Limit prefilter=6 (KNLMeansCL) gpuid to 0 minimum</li>
        <li>Optimization. Reuse Mavg var conversion to YUV</li>
        <li>Optimization. Engulf CClip code block into !GlobalO logic</li>
        <li>Optimization. Add 'luma' arg, for chroma only MV, or luma denoise with chroma only MVs</li>
        <li>Logic cleanup for isInter in show code block</li>
    </ul>
<p><b>v4.1.0d</b> (09-03-2023)</p>
    <ul>
        <li>Remove all references to RGB since it isn't supported by MVTools2</li>
        <li>Pass LFR through the motion mask to further mask out DCT flicker (even when DCTFlicker=false, when true mask is stronger)</li>
        <li>Replace prefilter=4 (FluxSmoothST) with "IQMST", suited for very grainy live action HD sources</li>
        <li>Update documentation</li>
    </ul>
<p><b>v4.0.0d</b> (02-03-2023)</p>
    <ul>
        <li>YUY2 support for all clip type arguments via internal planar conversion  (CClip, mfilter, prefilter and input)</li>
        <li>Direct interlaced support for all 'mode' filters and clip type arguments (CClip, mfilter, prefilter and input)</li>
        <li>Update handling of interlaced content. Bugfix + Performance + Code optimization</li>
        <li>Update chroma shift for UHDHalf to use Catmull-Rom instead of slower spline16</li>
        <li>Allow string types for 'prefilter' argument to define the preset</li>
        <li>Replace GaussT5 with TemporalGauss 'mode' and add TemporalSmooth mode (IDW weightings)</li>
        <li>Reparametrize thSCD1, DCTR and scaleCSAD for TS (Temporal___) modes (regression fix)</li>
        <li>Add 'mode' to show panel</li>
        <li>Allow recursion for all 'mode's except TemporalSoften</li>
        <li>Optimizations for chroma only denoising</li>
        <li>Add 'threads' arg for when CPU nnedi3 (pel>1, subpixel=4 and gpuid=-1)</li>
        <li>ex_retinex() - Fixed highlights=false for lvl=1 and lvl=2</li>
        <li>ex_retinex() - Fixed range conversion for all 'lvl' modes</li>
        <li>ex_BM3D() - Fix range string format when converting to other formats</li>
        <li>ex_DGDenoise() - Update chroma subsampling kernel to 'Didee' instead of slower spline36</li>
        <li>Finished Documentation</li>
    </ul>
<p><b>v3.6.0d</b> (06-02-2023)</p>
    <ul>
        <li>ex_Luma_Rebuild - Add 'lo' and 'hi' args for optional normalization</li>
        <li>Some typos and cosmetics</li>
    </ul>
<p><b>v3.5.9d</b> (18-01-2023)</p>
    <ul>
        <li>Better field parity detection for interlaced clips</li>
        <li>Frame property assignments for interlaced clips</li>
    </ul>
<p><b>v3.5.8d</b> (16-01-2023)</p>
    <ul>
        <li>Support back YUY2 via internal YV16 conversion</li>
        <li>Add IQMV as prefilter=3 and tune ex_FluxSmoothST() (prefilter=4)</li>
        <li>Optimize ex_BM3D() and ex_DGDenoise() format revert, and support Y clips</li>
        <li>Support Y clips when show=true</li>
    </ul>
<p><b>v3.5.7d</b> (02-12-2022)</p>
    <ul>
        <li>Fix logic for nnedi3 pixel center shift (subpixel=4)</li>
        <li>Fix Globals output (Globals=3)</li>
        <li>Fix super_render pelclip being set to nop() when reading Globals</li>
    </ul>
<p><b>v3.5.6d</b> (30-11-2022)</p>
    <ul>
        <li>Fix pixel center shift deviation in nnedi3 (subpixel=4) for high pel</li>
        <li>Swap prefilter 6 and 7 order for more coherence</li>
        <li>Tweak mode="dfttest" internal 'tmode' arg to work with odd 'tr'</li>
    </ul>
<p><b>v3.5.5d</b> (20-09-2022)</p>
    <ul>
        <li>Add 'DFTTest' as mode</li>
        <li>Update Documentation (WIP)</li>
        <li>Cosmetics</li>
    </ul>
<p><b>v3.5.4d</b> (02-08-2022)</p>
    <ul>
        <li>Replaced NNEDI3CL() with nnedi3wrap() so you can switch to CPU or GPU nnedi3 via 'gpuid' arg</li>
        <li>Since ResizersPack is now mandatory, nmod() was used where appropiate</li>
        <li>Fixed dimension references when UHDHalf is used</li>
        <li>Changed Str=1 to go directly to ConvertBits()</li>
        <li>Fixed 'show' panel for UHD and increased curve precision in 'show'</li>
        <li>ex_retinex() - Fixed normalization in HBD for lvl=3</li>
        <li>ex_retinex() - Expanded mask terminator</li>
    </ul>
<p><b>v3.5.3d</b> (08-07-2022)</p>
    <ul>
        <li>Replace nnedi3 calls (CPU based) with NNEDI3CL (GPU) when subpixel=4</li>
    </ul>
<p><b>v3.5.2d</b> (28-06-2022)</p>
    <ul>
        <li>ex_luma_rebuild() - Add RGB support</li>
        <li>ex_retinex() - Support for single channel clips</li>
        <li>ex_retinex() - Argument to disable highlight compression</li>
    </ul>
<p><b>v3.5.1d</b> (01-06-2022)</p>
    <ul>
        <li>Update function definitions</li>
        <li>Rename 'device_id' arg to 'gpuid'</li>
        <li>Allow CPU processing for prefilters via gpuid=-1</li>
        <li>Update UHD downscale coefficients</li>
        <li>'Str=1.0' is inclusive for ex_luma_rebuild() (only does a range conversion)</li>
        <li>ex_retinex() - Default UV to 3, for when used as stand-alone</li>
        <li>ex_retinex() - Add proper greyscale conversion</li>
        <li>ex_BM3D() - Add 'gpuid' argument</li>
        <li>ex_KNLMeansCL() - Change 'device_id' to 'gpuid'</li>
    </ul>
<p><b>v3.5.0d</b> (17-04-2022)</p>
    <ul>
        <li>Change 'search' and 'thSCD1' Defaults</li>
        <li>ex_Luma_Rebuild() - Add 'tv_out' and 'bits' args</li>
        <li>ex_retinex() - Change pmax to not thresholded max for lvl=3</li>
    </ul>
<p><b>v3.4.9d</b> (01-04-2022)</p>
    <ul>
        <li>Tweak some defaults; searchr, DCTR, pelsearch, plevel, pglobal, searchparam and searchparamr</li>
        <li>Force input to frame based also for pel > 2</li>
        <li>Fix pelclip height for interlaced sources</li>
        <li>Retrieve prefilter '_ColorRange' instead of using input's</li>
        <li>Use lvl=3 for ex_retinex() prefiltering if '_SceneRange' is present</li>
        <li>ex_retinex() - Add 'tv_out' arg when output is not for prefiltering use cases</li>
        <li>ex_retinex() - Add 'lvl=3' mode, will use scene based accumulated min and max stats</li>
    </ul>
<p><b>v3.4.8d</b> (09-03-2022)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Rebase to latest LSFPlus</li>
        <li>Fine tune function definitions</li>
        <li>ex_luma_rebuild() - Add selective propCopy and update 'Str' and 'c' defaults</li>
        <li>ex_KNLMeansCL - Add 'DCT' arg and add propCopy</li>
        <li>ex_KNLMeansCL/ex_DGDenoise - Default 'DCT' to true</li>
    </ul>
<p><b>v3.4.7d</b> (15-02-2022)</p>
    <ul>
        <li>Adjust defaults for internal ex_luma_rebuild()</li>
        <li>Subpixel=3 (now Default) is blackmanresize(taps=8), nnedi3 is now subpixel=4</li>
        <li>Fine tuned prefiltering settings and ex_BM3D() uses CUDA back again</li>
        <li>ex_BM3D() - Add 'preset' arg and add additional arguments to BM3D_CUDA and BM3D_CPU calls</li>
        <li>ex_DGDenoise() - Add LFR and DCT args</li>
        <li>ex_KNLMeansCL() - Turn 'LFR' to float and rebase with ex_LFR()</li>
    </ul>
<p><b>v3.4.6d</b> (08-02-2022)</p>
    <ul>
        <li>Fix typo in ex_KNLMeansCL()</li>
        <li>Reimplement back ex_KNLMeansCL() as prefilter=5</li>
        <li>Shift ex_DGDenoise() to prefilter=7</li>
        <li>Add post-blur to prefilter=5 and prefilter=7</li>
        <li>Default prefilter=6 (ex_BM3D) to CPU mode (CUDA is bugged)</li>
    </ul>
<p><b>v3.4.5d</b> (08-02-2022)</p>
    <ul>
        <li>ex_DGDEnoise() - New GPU based denoiser wrapper</li>
        <li>ex_KNLMeansCL() - Add 'wref' arg and limit 's' to 8</li>
        <li>Replace ex_KNLMeansCL() with ex_DGDenoise() as prefilter=5</li>
        <li>Optimize 'thSADR' and 'thSADC' Defaults</li>
        <li>LSFmod() - Change 'smode' to 4 for HD</li>
        <li>ex_Luma_Rebuild() - Fix 'show' setting</li>
        <li>ex_retinex() - frameprops passthrough</li>
        <li>ex_BM3D() - Add better matrix detection for the format conversions</li>
        <li>ex_BM3D() - Default chroma sigma to 1 when not used otherwise garbage output</li>
    </ul>
<p><b>v3.4.4d</b> (28-01-2022)</p>
    <ul>
        <li>Add 'IQMT' as degrain mode</li>
        <li>Add range arg to nnedi3</li>
        <li>Rebase LSFmod to latest version</li>
    </ul>
<p><b>v3.4.3d</b> (23-01-2022)</p>
    <ul>
        <li>Removed 'trymany' and 'divide' arguments</li>
        <li>Changed a few defaults; revert 'overlap', tune 'sharp', 'rfilter' and scaleCSAD</li>
        <li>Add a low frequency sharpened prefilter when LFR is enabled</li>
        <li>Optimize/simplify ex_KNLMeansCL() 'LFR'  algorithm</li>
        <li>Add a stronger LFR for ex_KNLMeansCL prefilter</li>
        <li>Fix issue when subpixel=3 was used (limit 'sharp' to 2 in MSuper)</li>
        <li>ex_minblur()/ex_sbr() - Fixed last call clip order to properly inherit frameprops</li>
    </ul>
<p><b>v3.4.2d</b> (10-01-2022)</p>
    <ul>
        <li>Add function definitions</li>
        <li>Fix for ex_luma_rebuild() plot</li>
    </ul>
<p><b>v3.4.1d</b> (08-01-2022)</p>
    <ul>
        <li>Default overlap to blksize/4 when refinemotion is used. (Slight +detail retention when motion and +performance)</li>
        <li>Rebase to latest ExTools. Affected 'fulls' args in prefilter=0 and prefilter=4</li>
        <li>ex_luma_rebuild() - Add 'show' argument to show curve plot</li>
    </ul>
<p><b>v3.4.0d</b> (14-12-2021)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Fix for default LFR value on UHD clips</li>
        <li>Optimized tv to pc luma range for HBD inputs and Str=0</li>
    </ul>
<p><b>v3.3.9d</b> (03-12-2021)</p>
    <ul>
        <li>Recursion for MDegrain</li>
        <li>Defaults when input is single plane or plane=0</li>
        <li>Clean Asserts and allow blksize of 24</li>
        <li>Prefilter UHD clips in its halved version (if UHDHalf=true, default)</li>
        <li>New prefilter=3 for ex_FluxSmoothST(), following modes are shifted up in number</li>
        <li>Fix super_render when reading Globals</li>
        <li>ex_Luma_Rebuild() use internal scale_inputs when tv_range=false (faster) + ditch 'fulls'</li>
        <li>ex_retinex() use internal scale_inputs when tv_range=false (faster) + ditch 'fulls'</li>
        <li>ex_retinex() replace old YPlaneMin/Max with PlaneMinMaxStats</li>
        <li>ex_BM3D() switch 'fulls' arg with 'tv_range'</li>
        <li>ex_BM3D() new arg 'OPP' to filter in OPP space as originally intended</li>
    </ul>
<p><b>v3.3.8d</b> (14-11-2021)</p>
    <ul>
        <li>Optimize nnedi3 for subpixel=3</li>
        <li>Rename srfilter to rfilter</li>
        <li>Final tweaks to DCTFlicker</li>
    </ul>
<p><b>v3.3.7d</b> (13-11-2021)</p>
    <ul>
        <li>ex_MinBlur() 'th' arg. </li>
        <li>Add 'smart2' and 'smart3' modes</li>
        <li>Use 8-bit for subpixel=3.</li>
    </ul>
<p><b>v3.3.6d</b> (12-11-2021)</p>
    <ul>
        <li>Remove 'fulls' arg, now it's derived from frameprops or overriden by tv_range arg</li>
        <li>Fill in appropiate values for 'fulld'</li>
        <li>Increase blksize limit to 64</li>
        <li>Improve DCTFlicker filtering</li>
        <li>Default DCTFlicker to false</li>
    </ul>
<p><b>v3.3.5d</b> (05-11-2021)</p>
    <ul>
        <li>Small optimization to ex_sbr() and ex_MinBlur()</li>
        <li>Add "FluxSmoothT" degrain mode</li>
        <li>Repurpose 'LFR' argument to frequency values (100 ~ 500)</li>
        <li>Rework nnedi3 multithreading arguments (requires SysInfo)</li>
        <li>Fix 'mfilter' for tr > 6</li>
        <li>Replace non-MDegrain LFR process code with that of MDegrain (faster)</li>
        <li>Add 'DCTFlicker' argument, to 'calm' restored low frequency detail</li>
        <li>Fix show panel when input is 32-bit float</li>
        <li>Helper functions - 32-bit support. Preparing for SMDegrain 32-bit support</li>
    </ul>
<p><b>v3.3.4d</b> (10-10-2021)</p>
    <ul>
        <li>Implement back recursion for "medianT" mode</li>
        <li>'LFR' setting, to restore lost low-frequency details</li>
        <li>Fix UHDhalf chroma placement (assumes 'top_left')</li>
        <li>ex_KNLMeansCL() - Update passing more arguments including 'lores' to restore low-frequency details</li>
        <li>Tune prefilter=4 (ex_KNLMeansCL()) for a bit more sharpness</li>
        <li>Implement mfilter contrasharpening fix to defined CClip as well</li>
        <li>ex_retinex() - use clip instead of scale for NaN blocks bug</li>
    </ul>
<p><b>v3.3.3d</b> (08-10-2021)</p>
    <ul>
        <li>More denoising modes</li>
        <li>Fix mfilter for Contrasharpening and non MDegrain modes</li>
        <li>ex_retinex() - convert to function objects</li>
        <li>ex_retinex() - aminorate black clipping issue</li>
        <li>Add dependency list</li>
    </ul>
<p><b>v3.3.2d</b> (23-09-2021)</p>
    <ul>
        <li>Add recursion mode when using alternative denoisers</li>
        <li>Export in above cases the MC clip directly instead of vectors for temporal limiting contrasharpening</li>
        <li>Let more room (overshoot) for not heavy grain contrasharpening when using TemporalSoften and ex_contrasharpening</li>
    </ul>
<p><b>v3.3.1d</b> (22-09-2021)</p>
    <ul>
        <li>Updated ex_gaussianblur() call in ex_retinex()</li>
        <li>Updated LSFmod call to accept temporal limiting if limitS=true and LRad if isHD</li>
        <li>New 'mode' arg to select MC denoiser of choice from TemporalSoften (for very grainy sources) and ex_median() modes. Might be faster than MDegrain for comparable results</li>
    </ul>
<p><b>v3.3.0d</b> (15-09-2021)</p>
    <ul>
        <li>Reordered Defaults</li>
        <li>limitS, new setting for spatial/temporal contrasharpening limiting</li>
        <li>Relaxed supersampling in LSFmod for more performance</li>
        <li>ex_MinBlur() and ex_sbr() Expr optimizations</li>
        <li>ex_retinex(), 'lo' and 'hi' arguments for post normalization in fixed mode (lvl=1)</li>
    </ul>
<p><b>v3.2.9d</b> (09-09-2021)</p>
    <ul>
        <li>Optimize + improve ex_retinex() with 'level' modes</li>
    </ul>
<p><b>v3.2.8d</b> (07-09-2021)</p>
    <ul>
        <li>Fine tune ex_retinex()</li>
        <li>ex_retinex() add missing "fulls"</li>
        <li>Bugfix for fulls in ex_BM3D()</li>
    </ul>
<p><b>v3.2.7d</b> (01-09-2021)</p>
    <ul>
        <li>ex_retinex(). Reworked luma rebuild logic with FrameProps</li>
        <li>Make ex_retinex() more temporal stable</li>
        <li>Optimize ex_retinex()</li>
        <li>Optimize ex_MinBlur()</li>
    </ul>
<p><b>v3.2.6d</b> (27-08-2021)</p>
    <ul>
        <li>'UHDhalf' and 'Interlaced' logic fixed</li>
    </ul>
<p><b>v3.2.5d</b> (25-08-2021)</p>
    <ul>
        <li>Add UHDhalf argument</li>
        <li>ex_MinBlur() optimizations</li>
        <li>Moved ex_ContraSharpening() to SharpenersPack</li>
        <li>ex_MinBlur() corner case bugfixes</li>
    </ul>
<p><b>v3.2.4d</b> (12-08-2021)</p>
    <ul>
        <li>ex_ContraSharpening() - Revert to removegrain(20)</li>
        <li>Rebase to latest ExTools</li>
        <li>Fix ex_BM3D() issue when 32-bit</li>
        <li>Fix 'threads' issue</li>
        <li>Remove masktools2 dependency</li>
    </ul>
<p><b>v3.2.3d</b> (04-08-2021)</p>
    <ul>
        <li>Add BM3D as prefilter</li>
        <li>Fix contrasharpening for HD</li>
        <li>Fix Thread var when argument is empty</li>
        <li>Use BilinearResize for UHD (vector scaling)</li>
    </ul>
<p><b>v3.2.2d</b> (22-06-2021)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Add 'fulls' arg</li>
    </ul>
<p><b>v3.2.1d</b> (18-06-2021)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Add 'tv_range' arg</li>
        <li>Enable 'Str' as default (str=2)</li>
    </ul>
<p><b>v3.2.0d</b> (11-06-2021)</p>
    <ul>
        <li>Resume from v3.1.2.111s (continuation mod from real.finder)</li>
        <li>Code sanitation (remove old avisynth support -pre AVS+-, DitherTools support and YUY2 support)</li>
        <li>Ported masktools2 to ExTools</li>
        <li>Merged back prefilters from function based to SMDegrain¡s in-code</li>
        <li>Change DCT and subpixel defaults</li>
        <li>Add internal scaleCSAD defaults</li>
        <li>Add UHD optimization via MScaleVect</li>
        <li>Remove 'bits' arg from MScaleVect</li>
        <li>ex_sbr()/ex_MinBlur() optimizations</li>
        <li>ex_Luma_Rebuild() optimizations and cleanup</li>
    </ul>
<p><b>v3.1.2d</b> (21-07-2015)</p>
    <ul>
        <li>Fixed regression where external prefilters wouldn't be parsed for luma expansion</li>
    </ul>
<p><b>v3.1.1d</b> (16-07-2015)</p>
    <ul>
        <li>Workaround to force KNLMeansCL use discrete video card (now required)</li>
    </ul>
<p><b>v3.1d</b> (14-07-2015)</p>
    <ul>
        <li>New prefilter mode 4 for grainy sources. GPU based spatio-temporal KNLmeans</li>
        <li>Added dither output mode "Random Dither".</li>
        <li>Added "slices" option from Dither</li>
        <li>Added soft=-2 (automatic) to internal lsfmod</li>
        <li>Added assert for chroma denoise when luma only motion vectors (mvtools bug)</li>
        <li>Improved lsb_in code (now using sub/add method)</li>
        <li>Removed vpad/hpad=0 optimization preset for HD</li>
        <li>Fixed prefilter=3 code for lsb_in YUY2</li>
        <li>More fixes to Show Panel...</li>
        <li>Updated and fixed documentation (notes on YUY2 support)</li>
    </ul>
<p><b>v3.0d</b> (27-03-2015)</p>
    <ul>
        <li>Adjusted SD<>HD discretion</li>
        <li>Added mfilter (Motion Filter) new feature</li>
        <li>subpixel=3 (nnedi3); removed qual=2 due to possible blending bug (quote by cretindesalpes), this also boosts speed</li>
        <li>Lowered the defaults for less aggressive denoise (still somewhat high)</li>
        <li>Fixed chroma not showing in debug (show) mode when lsb=true and prefilter=3 were paired</li>
        <li>Fixed long lasting issues in Show Panel for certain not mod height resolutions</li>
        <li>Now prefilter=0 is minblur(0), lighter denoising than prefilter=1, default is now -1 (off)</li>
        <li>Documentation update (plugin updates, notes, links, examples, etc)</li>
    </ul>
<p><b>v2.2d</b> (05-03-2013)</p>
    <ul>
        <li>Removed one residual variable in Contrasharpening function</li>
        <li>Fixed a regression at v2.0 for Interlaced YUY2 sources by changing wrong variable ifC to if0, and...</li>
        <li>...adding a missing weave() to the last MergeChroma() call</li>
        <li>Dropped Dither support. (Will still work/not work as before, but lack of official support renders it to a YMMV condition)</li>
    </ul>
<p><b>v2.1d</b> (09-09-2012)</p>
    <ul>
        <li>Fixed Refinemotion Globals Input labels</li>
        <li>Fixed ContrasharpeningHD Vectors for Interlaced HD sources</li>
        <li>Added ability to import Global Vectors even when "tr" is lower than parent instance "tr" (credit to cretindesalpes)</li>
        <li>Expanded support for Interlaced Denoising "tr" up to 64 (credit to cretindesalpes)</li>
        <li>Cosmetics</li>
    </ul>
<p><b>v2.0d</b>  (07-06-2012)</p>
    <ul>
        <li>Fixed and optimized chroma handling for lsb_in, contrasharpening and YUY2 content v.1.95</li>
        <li>Enhanced Chroma bypass on the sharpening stage</li>
        <li>Merged ContraHD() internally for Contrasharpening in HD sources</li>
        <li>Dropped QTGMC support on import/export motion vectors (small value for increased confusion)</li>
        <li>Fixed Median code for planar inputs in MinBlur() (needs RemoveGrainHD, dropped medianblur requirement)</li>
        <li>Defaulted truemotion to false for HD inputs</li>
        <li>Code Optimization and Clean up</li>
        <li>Others</li>
    </ul>
<p><b>v1.9d</b>  (23-03-2012)</p>
    <ul>
        <li>Added truemotion parameter (default=true), change it to false (as in MCTemporalDenoise()), so low frequency detail won't be lost (walls...), although it could leave more noise on high frequency details</li>
        <li>Added thSADC, and thSCD1/thSCD2 parameters for finer control</li>
        <li>Tweaked prefilter=3 dfttest sigmas for better low frequency detail protection</li>
        <li>Detached explanation and converted to html. Updated and extended the contents as well</li>
        <li>Fine tuned and robustized the Show Panel</li>
        <li>Optimized and organized code, more precisely the contrasharpening part</li>
        <li>Fixed a few ternary checks for when Globals=3</li>
        <li>Others</li>
    </ul>
<p><b>v1.8d</b>  (18-01-2012)</p>
    <ul>
        <li>Added automatic dark protection for prefilter=3 (dfttest performs badly in darks) v1.71d and extended its dark protection v1.8</li>
        <li>Fixed chroma variable when chroma=false, from 2 (copy chroma) to 1 (discard chroma) v1.71d</li>
        <li>Explanation and cosmetics v1.71d</li>
        <li>Added acknowledgments and updated explanation</li>
        <li>Added brackets to all functions (it has been reported to cause threading problems under certain circumstances) (<a href="https://forum.doom9.org/showthread.php?p=1515886" target="_blank">https://forum.doom9.org/showthread.php?p=1515886)</a></li>
        <li>Reworked and fixed the parameters panel. Now you have a color guide to have an idea on what to tweak depending on selected mode in Show. For strings: "Speed", "Memory" and "Quality"</li>
        <li>Optimized lsb_in for HD resolutions which was causing memory hogs</li>
        <li>Fixed contrasharpening for YUY2 sources when lsb=true</li>
        <li>Fixed some inconsistencies for YUY2 sources when prefilter=3</li>
    </ul>
<p><b>v1.7d</b>  (11-01-2012)</p>
    <ul>
        <li>Fixed and extended introduction explanation v.1.61d</li>
        <li>Fixed some issues for Globals=1 (Read) in relation to lsb_in and luma expansion auto-prefilter v.1.61d</li>
        <li>Added mild gauss blur prefilter option as prefilter=1. Consequent modes are displaced v.1.61d</li>
        <li>Changed prefilter 1 and 2 to Minblur (Gauss/Median combination) v.1.63d</li>
        <li>Updated MinBlur function v.1.62d and v.1.66</li>
        <li>Code tidied up v.1.62d
        <li>Updated luma expansion, now you can enhance darks (with 'Str' and 'Amp') in the same step as the TV->PC conversion stage, thus +optimized, +quality. v.1.63d by cretindesalpes (<a href="https://forum.doom9.org/showthread.php?p=1548318" target="_blank">https://forum.doom9.org/showthread.php?p=1548318)</a></li>
        <li>Removed pre_custom. Now use prefilter to load a prefiltered clip, as well as modes 0~3</li>
        <li>Added Show parameter. Now you can see the used and default parameters along the prefilter clip as well</li>
        <li>Fixed one note related to prefilter clip input for interlaced content</li>
    </ul>
<p><b>v1.6d</b>  (24-12-2011) (first open release)</p>
    <ul>
        <li>Fixed and extended introduction explanation</li>
        <li>Fixed Ditherpost for interlaced sources</li>
        <li>Fixed a broken reference for reading MRecalculate globals when tr>3</li>
        <li>Fixed a Globals=1 MSuper automatization</li>
        <li>Fixed a plane processing bypass when chroma=false</li>
        <li>Added LSFmod as optional contrasharpening (slower, but biased contrasharpening and probably better depending on source)</li>
        <li>Added default luma expansion auto-prefilter for motion search (16% more values)</li>
        <li>Added YUY2 support</li>
        <li>Added the 'mode' parameter of Ditherpost()</li>
        <li>Added support for interlaced temporal radius up to 6</li>
    </ul>
<p><b>v1.5d</b>  (14-10-2011)</p>
    <ul>
        <li>Changed "srchSuper" Global variable to "QTGMC_srchSuper", compatible with QTGMC. Anyhow you may probably want to create a new super clip. Test it out! v.1.41d</li>
        <li>Introduction spelling and presentation v.1.42d</li>
        <li>Added lsb and lsb_in for prefilter=2 (dfttest) v.1.43d & v.1.44d</li>
        <li>Some better definitions for the settings help v.1.45d</li>
        <li>pelclip is now subpixel = 3 ('sharp' parameter before) v.1.45d</li>
        <li>Other minor tweaks v.1.45d</li>
        <li>Fixed an important issue when using prefilter with subpixel=3 ('pelclip' parameter before)</li>
        <li>Optimizations in Ditherpost for chroma</li>
        <li>Changed rfilter (hierarchical levels smoothing/scaling) from default 2 to 4. Better results in my judge</li>
        <li>Some more little tweaks in code and introduction</li>
    </ul>
<p><b>v1.4d</b>  (16-09-2011)</p>
    <ul>
        <li>Added pelclip option for top quality subpixel interpolation when pel > 1</li>
        <li>Changed QTGMCV parameter to Globals, and added a bunch of new features like vectors output from <var>SMDegrain()</var></li>
        <li>Big introduction and code optimization tweaks</li>
    </ul>
<p><b>v1.3d</b>  (14-09-2011)</p>
    <ul>
        <li>Fixed an important issue on the Interlaced parameter and improved overall handling (v.1.21d & v.1.3d)</li>
    </ul>
<p><b>v1.2d</b>  (13-09-2011)</p>
    <ul>
        <li>Added Interlaced parameter, for processing interlaced sources</li>
        <li>Some introduction and code optimization tweaks (v.1.12d & v.1.2d)</li>
    </ul>
<p><b>v1.1d</b>  (12-09-2011)</p>
    <ul>
        <li>Implemented MDegrainN for tr > 3, from the MVTools2 mod of Dither</li>
        <li>Minor introduction and code optimization tweaks</li>
    </ul>
<p><b>v1.0d</b>  (09-09-2011)</p>
    <ul>
        <li>Added CClip parameter. Reference an earlier stage of your processing chain as your sharp version for the contrasharpening</li>
    </ul>
<p><b>v0.9d</b>  (09-09-2011)</p>
    <ul>
        <li>Added QTGMCV parameter, for reusing vectors from QTGMC bob deinterlacer</li>
    </ul>
<p><b>v0.8d</b>  (05-09-2011)</p>
    <ul>
        <li>Fixed a few things related to the lsb_in option</li>
        <li>Minor introduction and code optimization tweaks</li>
    </ul>
<p><b>v0.7d</b>  (05-09-2011)</p>
    <ul>
        <li>Implemented "fake" lsb_in option. Output will have slightly more quality (if any), and will compress better. (Experimental)</li>
        <li>Fixed a not passed argument in the hpad, vpad parameters</li>
    </ul>
<p><b>v0.6d</b>  (04-09-2011)</p>
    <ul>
        <li>Minor introduction and code optimization tweaks</li>
    </ul>
<p><b>v0.5d</b>  (19-07-2011)</p>
    <ul>
        <li>Added dfttest option for preblur (now prefilter) option. Slower but better due to its internal deblock+denoise operation, plus sharper results</li>
        <li>Added pre_custom option for the prefilter process, define here a denoised clip as your prefiltered version</li>
        <li>Updated the introduction help</li>
    </ul>
<p><b>v0.4d</b>  (03-06-2011)</p>
    <ul>
        <li>Added preblur option for slight vector blurring where motionmatch is bad                     (<a href="https://forum.doom9.org/showthread.php?t=161594" target="_blank">https://forum.doom9.org/showthread.php?t=161594)</a></li>
        <li>Added RefineMotion parameter for better motion vectors. Based off Killer()                   (<a href="https://forum.doom9.org/showthread.php?p=1266572" target="_blank">https://forum.doom9.org/showthread.php?p=1266572)</a></li>
        <li>Added parameters "lsb" and "lsb_out", for the MVTools2 mod version of cretindesalpes' Dither (<a href="https://forum.doom9.org/showthread.php?p=1386559" target="_blank">https://forum.doom9.org/showthread.php?p=1386559)</a></li>
        <li>Other minor aesthetics and performance adjustments</li>
    </ul>
<p><b>v0.3d</b>  (04-03-2011)</p>
    <ul>
        <li>First Mod version</li>
        <li>Fixed plane (for MDegrain) and added chroma (for MAnalyse) parameters</li>
    </ul>
<p><b>v0.2</b>  (24-01-2010)</p>
    <ul>
        <li>Added introductory section</li>
        <li>Added more parameters</li>
    </ul>
<p><b>v0.1</b></p>
    <ul>
        <li>Basic working version</li>
        <li>Not released</li>
    </ul>
</body>
</html>