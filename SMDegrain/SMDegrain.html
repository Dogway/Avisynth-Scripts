<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="Avisynth Video Filtering" />
<title>Simple MDegrain Mod&nbsp;&mdash;&nbsp;SMDegrain()</title>
<link rel="stylesheet" type="text/css" href="avisynth.css" />
</head>

<body>

<h1>Simple MDegrain Mod&nbsp;&mdash;&nbsp;SMDegrain()</h1>

<p>&nbsp;</p>
<h2>Abstract</h2>

<p>
<b>Author: </b>Dogway<br/>
<b>Version: </b>v3.5.6d<br/>
<b>Download: </b><a href="https://github.com/Dogway/Avisynth-Scripts/tree/master/SMDegrain%20" target="_blank">https://github.com/Dogway/Avisynth-Scripts/SMDegrain</a><br/>
<b>Discussion: </b><a href="https://forum.doom9.org/showthread.php?p=1972585" target="_blank">https://forum.doom9.org/showthread.php?p=1972585</a><br/>
<b>Category: </b>Temporal Denoiser Script Function<br/>
<b>Date:</b> 30-November-2022
</p>
<p>&nbsp;</p>
<h2><a id="up"></a>Table of contents</h2>
<ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#aknowledgements">Aknowledgements</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#parameters">Parameters Description:</a> <a href="#basic">Basic</a>, <a href="#advanced">Advanced</a></li>
<li><a href="#finalnotes">Final Notes</a></li>
<li><a href="#examples">Example Scripts</a></li>
<li><a href="#changelog">Changelog</a></li>
</ul>
<p>&nbsp;</p>
<h2><a id="dependencies"></a>Dependencies&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<b>Required<br/></b>
<ul>
<table>
  <tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/ExTools.avsi" target="_blank">ExTools</a></b></li></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v9.3 or higher)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/MVTools" target="_blank">MVTools2</a></b></li></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v2.7.45 or higher)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/ResizersPack.avsi" target="_blank">ResizersPack</a></b></li></td><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(v10.1 or higher)</td></tr>
  </tr>
</table>
</ul>
<b>Optional<br/></b>
<ul>
<table>
  <tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/MIX%20mods/LSFplus.avsi" target="_blank">LSFplus</a></b></li></td><td>&nbsp;&nbsp;(v5.5 or higher)</td><td>&nbsp;&nbsp;(for Contrasharp or LFR)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/MIX%20mods/SharpenersPack.avsi" target="_blank">SharpenersPack</a></b></li></td><td>&nbsp;&nbsp;(v4.4 or higher)</td><td>&nbsp;&nbsp;(for Contrasharp or LFR)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/GradePack.avsi" target="_blank">GradePack</a></b></li></td><td>&nbsp;&nbsp;(v8.0 or higher)</td><td>&nbsp;&nbsp;(for Str=0.1 to 1.0 ~ex_retinex()~ or show)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/ScenesPack.avsi" target="_blank">ScenesPack</a></b></li></td><td>&nbsp;&nbsp;(v4.2 or higher)</td><td>&nbsp;&nbsp;(for Str=0.1 to 1.0 ~ex_retinex()~ if '_SceneRange' frameprops exist)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts/blob/master/MasksPack.avsi" target="_blank">MasksPack</a></b></li></td><td>&nbsp;&nbsp;(v6.6 or higher)</td><td>&nbsp;&nbsp;(for show)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/RgTools" target="_blank">RgTools</a></b></li></td><td>&nbsp;&nbsp;(v1.2 or higher)</td><td>&nbsp;&nbsp;(for Contrasharp or prefilter=0~3)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/Dfttest" target="_blank">DFTTest</a></b></li></td><td>&nbsp;&nbsp;(v1.9.7 or higher)</td><td>&nbsp;&nbsp;(for prefilter=4)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/KNLMeansCL" target="_blank">KNLMeansCL</a></b></li></td><td>&nbsp;&nbsp;(v1.1.1e or higher)</td><td>&nbsp;&nbsp;(for prefilter=5)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/DGDecNV" target="_blank">DGDecNV</a></b></li></td><td>&nbsp;&nbsp;(v246 or higher)</td><td>&nbsp;&nbsp;(for prefilter=6)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/BM3DCUDA" target="_blank">BM3D</a></b></li></td><td>&nbsp;&nbsp;(test9 or higher)</td><td>&nbsp;&nbsp;(for prefilter=7)</td></tr>
    <tr><td><li><b><a href="https://github.com/Dogway/Avisynth-Scripts" target="_blank">TransformsPack</a></b></li></td><td>&nbsp;&nbsp;(v1.0 RC60 or higher)</td><td>&nbsp;&nbsp;(for prefilter=6 or prefilter=7)</td></tr>
    <tr><td><li><b><a href="https://github.com/HomeOfAviSynthPlusEvolution/neo_TMedian" target="_blank">neo_tmedian</a></b></li></td><td>&nbsp;&nbsp;(r2 or higher)</td><td>&nbsp;&nbsp;(for mode="medianT")</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/NNEDI3CL" target="_blank">NNEDI3CL</a></b></li></td><td>&nbsp;&nbsp;(v1.0.5 or higher)</td><td>&nbsp;&nbsp;(for subpixel=4)</td></tr>
    <tr><td><li><b><a href="http://avisynth.nl/index.php/Average" target="_blank">Average</a></b></li></td><td>&nbsp;&nbsp;(v0.95 or higher)</td><td>&nbsp;&nbsp;(for mfilter + (Contrasharp or mode!=MDegrain) )</td></tr>
  </tr>
</table>
</ul>
<p>&nbsp;</p>
<h2><a id="aknowledgements"></a>Aknowledgements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<a href="http://forum.doom9.org/showthread.php?t=152326" target="_blank">Original SMDegrain()</a> by Caroliano<br/><br/>
This function uses code from Didée, and cretindesalpes' creations,
and has parts inspired by LaTo's functions (Show panel, etc)
and Jawed's Killer() function, as well as relying on third-party tools for certain features.<br/><br/>
Special thanks go to: cretindesalpes, Didée, Gavino, Sagekilla, and MVtools people.
<p>&nbsp;</p>
<h2><a id="introduction"></a>Introduction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
SMDegrain is not a magic function, but rather a convenient one ("magic" if any comes from the internal mvtools plugin). It just takes the reiterative code blocks needed for mvtools+mdegrain denoising and wraps them into this function. It has internal switches for when you deal with interlaced or YUY2 content, so all you need is to enable the parameter in the function argument, saving you from writting long lines of code and preventing from easy-to-commit mistakes. YUY2 is automatically detected so it even doesn't need to be actively enabled. Besides that it adds some small and well founded enhancements listed below, like ability for the so much discussed <var>prefilter</var>s, slightly better motion vectors (thanks to an internal TV->PC luma expansion), option for nnedi3 <var>subpixel</var> accuracy, <var>globals</var> import/export, some dark luma enhancement parameters (for better motion vectors, not the actual clip), <var>show</var> panel, and <var>contrasharp</var> option, among others:<br/>
<br/>
<b>Frame properties support:</b> Reads frame properties for details on luma range, bitdepth or source matrix.<br/>
<b>High bitdepth denoising:</b> This was the first MDegrain wrapper to support HBD (High Bitdepth) MDegrain denoising, first via the Dither tools pack, and now with Avisynth+ internal HBD support.<br/>
<b>Higher temporal radius (tr>3):</b> First implemented via cretindesalpes' mvtools2 mod. Now it's already in mvtools2 master (pinterf branch) for a hack-free higher temporal radius.<br/>
<b>Contrasharpening:</b> The pretty much standarized sharpening method created by Didée is blended into the function, so you can easily use it in HBD pipelines. An strength biased method is also possible. A <var>CClip</var> parameter is also supplied so you can choose another source to sharpen from, other than the default <var>SMDegrain()</var> input.<br/>
<b>Interlaced support:</b> It supports <var>interlaced</var> sources, for YUY2 color spaces and most parameters as well.<br/>
<b>UHD optimized:</b> UHD denoising is optimized via motion vector scaling providing much higher performance by default, disable with <var>UHDhalf</var> argument.<br/>
<b>Extended Subpixel Accuracy:</b> nnedi3 is added as the 4th option for this setting, not strictly necessary in most cases, but if you are a quality mad try to set it on.<br/>
<b>Better Motion Vectors:</b> An internal conversion from TV levels (16-235) to PC levels (0-255) and a dark zone luma expansion is done to the clip where the motion analysis will be performed on, so you can get much better motion vectors<br/>
<b>Prefilters:</b> An easy parameter to load generalist <var>prefilter</var>s that perform well in most situations. It also accepts loading your personal <var>prefilter</var>ed clips.<br/>
<b>Degrain modes:</b> As a bonus you can try other temporal denoisers (from the ex_median() function) with <var>mode</var> so you can test temporal medians from a simple medianT to a ML3Dex algorithm in a motion compensated fashion.<br/>
<b>Smear protection:</b> Smearing of low contrast shading is a known side-effect of MDegrain, as a solution the <var>LFR</var> argument was added to recover low frequency details along <var>DCTFlicker</var> to temporally calm down the recovered frequencies.<br/>
<b>Motion Filters:</b> It will allow you to filter those parts where <var>SMDegrain()</var> couldn't find a matching block, or in other words motion areas where <var>SMDegrain()</var> couldn't denoise. One use for it would be spatial denoisers or deblockers since motion areas are prone to heavy blocking and artifacts.<br/>
<b>Motion Vectors Globals Input/Output:</b> Reuse motion vectors <var>globals</var> for faster processing, or just use <var>SMDegrain()</var> as a shortcut for creating nice quality motion vectors.<br/>
<b>RefineMotion Option (MRecalculate):</b> Performs finer block matching refinement, unless you are very performance deprived you should use this as default for a quality boost.<br/>
<b>Show Panel:</b> Everything is off by default, but some settings change in context (i.e. when in HD). Check what is happening behind the scenes and have a fast look at all your settings.<br/>
<b>Robust:</b> Everything listed above works together with each other indistinctly (interoperability). In the process some error proof, bugfixes and bug workarounds were implemented or at least warned so you know that most of what is done is reliable, bug free, carefree and optimized. The general idea is to serve as an user friendly front end for vanilla mvtools2+mdegrain or as the original script creator entitled <i>"To make your scripts shorter and less geeky"</i>. Most parameters are turned off or defaulted to mvtools2 defaults or close. Features are based on popular general conceived good practices and time tested procedures.<br/>
<br/>
Parameters are arranged in 2 blocks.<br/>
<br/>
<b><a href="#basic">Basic:</a></b> For people who just need the most basic parameters because either they don't have the time, knowledge or interest into looking for complex settings. Or they are content with defaults (pretty much mvtools defaults)<br/>
<b><a href="#advanced">Advanced:</a></b> If you run into some problems, are nitpicking or just want to fine tune your settings according to the source, have a look at this block, it contains the rest and bulk of the function parameters.<br/>
<br/>
<br/>
Temporal denoising is a widespread procedure for noise cleaning in most type of video sources. The only limitation for <var>SMDegrain()</var> being when there are (very) high levels of grain, in which case you would need to rely on more "creative" and source centric solutions (see <a href="http://forum.doom9.org/showthread.php?p=1544619#post1544619" target="_blank">this</a> and <var>prefilter</var> notes), but those are the rare cases.<br/>
<br/>
To picture what the function does, a simple <var>SMDegrain()</var> call matches the next code (for SD resolutions):<br/>
<br/>
<pre>
super_search = ex_Luma_Rebuild(S0=5.0,c=0.0312, bits=8).MSuper(rfilter=3,sharp=3)

bv2 = super_search.MAnalyse(isb = true,  delta = 2, overlap = 4, search = 2)
bv1 = super_search.MAnalyse(isb = true,  delta = 1, overlap = 4, search = 2)
fv1 = super_search.MAnalyse(isb = false, delta = 1, overlap = 4, search = 2)
fv2 = super_search.MAnalyse(isb = false, delta = 2, overlap = 4, search = 2)

MDegrain2(MSuper(levels=1), bv1, fv1, bv2, fv2, thSAD=300, thSADC=57, thSCD1=365, thSCD2=130)</pre><br/>
<br/>
As you see no wizardry. The only changes made are the TV->PC luma expansion (ex_Luma_Rebuild(S0=5.0,c=0.0312) so you have more range to detect motion vectors, the rfilter=3 for a bit more quality super search, the changed default of <var>overlap</var> from 0 to 4 and <var>thSAD</var> and <var>thSADC</var> from 400 to 300 and 57 respectively for safer results and search from 0 to 2 which has a higher performance/quality ratio. Nothing else. The problem is that as soon you want to change a little thing like say temporal radius it requires you to edit in more than a few places, so this is very annoying and so forth the main reason for <var>SMDegrain()</var>.<br/>

<p>&nbsp;</p>
<h2><a id="parameters"></a>Parameters&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<br/>
<p><i>SMDegrain (clip input, int <a href="#tr">"tr"</a>, int <a href="#thSAD">"thSAD"</a>, int <a href="#thSAD">"thSADC"</a>, bool <a href="#RefineMotion">"RefineMotion"</a>, val <a href="#contrasharp">"contrasharp"</a>, clip <a href="#CClip">"CClip"</a>, bool <a href="#interlaced">"interlaced"</a>, int <a href="#plane">"plane"</a>, int <a href="#Globals">"Globals"</a>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <a href="#pel">"pel"</a>, int <a href="#subpixel">"subpixel"</a>, val <a href="#prefilter">"prefilter"</a>, clip <a href="#mfilter">"mfilter"</a>, int <a href="#blksize">"blksize"</a>, int <a href="#overlap">"overlap"</a>, int <a href="#search">"search"</a>, bool <a href="#Truemotion">"truemotion"</a>, int <a href="#limit">"limit"</a>, int <a href="#limit">"limitc"</a>, int <a href="#thSCD1">"thSCD1"</a>, int <a href="#thSCD2">"thSCD2"</a>,     \<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool <a href="#chroma">"chroma"</a>, int <a href="#hpad">"hpad"</a>, int <a href="#hpad">"vpad"</a>, int <a href="#mode">"mode"</a>, val <a href="#Show">"Show"</a>, float <a href="#Str">"Str"</a>, float <a href="#Amp">"Amp"</a>)</i></p><br/>
<br/><br/>
<h3><a id="basic"></a>Basic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="tr"></a>tr</h4>
<i>[int: 1, "2", 3, 4, 5, 6, ...]</i><br/>
<br/>
Temporal radius. Select between <i>MDegrain</i> 1, 2, 3, 4, 5, 6 or higher. The higher generally better, but also much slower and improvements get less drastic.<br/>
This can be considered the strength of the denoising. Limit is <var>tr=</var>128, 64 for interlaced.<br/>
<br/>
<h4><a id="thSAD"></a>thSAD, thSADC</h4>
<i>[int:"300"], [int:"226"] (for HD)</i><br/>
<br/>
<i>"Sum of Absolute Differences"</i> threshold. This is the spatial difference threshold where the motion search will consider whether to denoise given the next formula: <a href="http://forum.doom9.org/showthread.php?p=1562037#post1562037" target="_blank">Denoise_Weight = max( 0, 1 - 2*blockSAD² / (thSAD² + blockSAD²) )</a><br/>
This spatial difference will be compared in blocks (<var>blksize</var>). If your noise is not getting into consideration for the denoising try raising this value, or reduce its SAD with previous <var>prefilter</var>ing.<br/>
You can alternatively raise the block size (<var>blksize</var>), which will likely even blocks SAD. Low values can result in staggered/blotchy denoising, large values can result in ghosting and artifacts. Values in the range 200~600 are usual.<br/>
<var>thSADC</var> is the same logic applied to chroma <var>plane</var>s, since there are less differences on the chroma planes it uses by default <var>thSAD</var>/2 for safer chroma results.<br/>
<br/>
<br/>
<h4><a id="contrasharp"></a>Contrasharp</h4>

<i>[bool: true, "false"] or [int: 0 ~ 100 ]</i><br/>
<br/>
Contrasharpening is a technique that compares the differences between the clip before blurring (original) and after blurring (filtered), and sharpens locally with consequent strength.<br/>
By default the before "sharp" clip is the one used as input for <var>SMDegrain()</var>, the "after" clip is the denoised clip. Independently a "before" clip can be specified with the <var>CClip</var> parameter (See <a href="#CClip">below</a>)<br/>
<br/>
<var>Contrasharp</var> when set to "true", will use Didée's <i>Contrasharpening()</i> function (or the modded version <i>ContraHD()</i> for HD sources) which:<br/>
  <i>"Sharpens the denoised clip, but doesn't add more to any pixel than what was removed previously"</i><br/>
   In the practice you will get a slightly sharper result than the source, which is welcome.<br/>
In the other hand if your parameter input is an integer, <i>LSFmod()</i> will be used instead. It will be much slower, but maybe better for certain sources.<br/>
Its value will serve as a <var>contrasharp</var>ening multiplier, use one around 50 for similar strength as <i>Contrasharpening()</i>.<br/>
The drawbacks for LSFmod (integer inputs) are that they are no-suitable for HD sources and no support for planar (YUY2) inputs.
<br/>
<h4><a id="RefineMotion"></a>RefineMotion</h4>

<i>[bool: true, "false"]</i><br/>
<br/>
Refines and recalculates motion data of previously estimated (by <i>MAnalyse</i>) motion vectors.<br/>
Turn it on for better motion vectors, specially when dealing with ghosting issues, small details or lineart fading and whatnot.<br/>
&nbsp;&nbsp;*<i>It won't enhance much if you use a <var>prefilter</var> (in case you use it) so strong that blurs too much or kills all the details you are aiming to protect in first place.</i><br/>
<br/>
<h4><a id="plane"></a>plane</h4>

<i>[int: 0, 1, 2, 3, "4"]</i><br/>
<br/>
Select the planes you wish to process:<br/>
<ul>
    <li>0 - luma only</li>
    <li>1 - chroma U</li>
    <li>2 - chroma V</li>
    <li>3 - both chromas</li>
    <li>4 - all (Default)</li>
</ul>
<br/>
&nbsp;&nbsp;*<i>Keep in mind that <var>plane</var>=4 (2 and 3 as well) can sometimes create chroma smearing. In such case I recommend denoising chroma <var>planes</var> in the spatial domain.</i><br/>
<br/>
<h4><a id="interlaced"></a>Interlaced</h4>

<i>[bool: true, "false"]</i><br/>
<br/>
If you want to denoise an <var>interlaced</var> source set this parameter to true. Output will also be <var>interlaced</var>.

<br/><br/><br/><br/>
<h3><a id="advanced"></a>Advanced&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h3>
<br/>
<h4><a id="pel"></a>pel</h4>
<i>[int: 1, "2", 4]</i><br/>
<br/>
Accuracy of the motion estimation.
<ul>
    <li>1: means a precision to the pixel. (Default 1 for HD material)<br/>
    <li>2: means a precision to half a pixel. (Default)
    <li>4: means a precision to quarter a pixel, produced by spatial interpolation (more accurate but slower and not always better due to big level scale step).
</ul>
<br/>
<h4><a id="subpixel"></a>subpixel</h4>
<i>[int: 0, 1, "2", 3]</i><br/>
<br/>
Subpixel accuracy. It chooses an interpolation method for <var>pel=</var>2 or 4. This is the 'sharp' parameter in <i>msuper()</i>,<br/>
although it isn't related to output sharpness but better accuracy for the motion estimation.<br/>
<ul>
    <li>subpixel = 0 for soft interpolation (bilinear)</li>
    <li>subpixel = 1 for bicubic interpolation (4 tap Catmull-Rom)</li>
    <li>subpixel = 2 for sharper Wiener interpolation (6 tap, similar to Lanczos) (Default)</li>
    <li>subpixel = 3 for blackman taps=6 high quality subpixel interpolation</li>
    <li>subpixel = 4 for nnedi3 high quality subpixel interpolation</li>
</ul>
For <var>subpixel=</var>4 you will need nnedi3 (gpuid=-1) or NNEDI3CL (gpuid=0) plugin. Very useful when used along <var>pel=</var>4 on very small sources, although overkill and unnecesary in most cases.<br/>
<br/>
<h4><a id="prefilter"></a>prefilter</h4>
<i>[int: "-1", 0, 1, 2, 3, 4, 5, 6, 7] or [clip: - ]</i><br/>
<br/>
<ul>
    <li>-1 = off (Default)</li>
    <li>0 = light controlled gauss blur</li>
    <li>1 = mild median/gauss blur</li>
    <li>2 = strong median/gauss blur</li>
    <li>3 = FluxSmoothST (spatio-temporal median filter)</li>
    <li>4 = dfttest (spatial)</li>
    <li>5 = KNLmeansCL (spatio-temporal non-local means OpenCL GPU filter)</li>
    <li>6 = BM3D (spatio-temporal BM3D GPU filter)</li>
    <li>7 = DGDenoise (spatio-temporal non-local means Cuda GPU filter)</li>
    <li>variable = <var>prefilter</var>ed clip input variable</li>
</ul>
<br/>
Denoises a version of the clip that will be used to obtain the motion vectors.<br/>
Useful for very damaged/grainy sources. This will help to get better motion vectors.<br/>
For sources with Gibbs noise, especially on anime, try <var>prefilter=</var>1 or 2 or better yet strong median filters (through clip input)<br/>
in order to soothe the high SAD of sharp edges. For blocky sources, or a general more quality/safer <var>prefilter</var> use option 3 (<i>dfttest</i>)*<br/>
<var>prefilter=</var>4 is aimed at grainy sources, it also helps to stabilize film wobble artifacts. I expanded the filter to work on YUY2 sources<br/>
and chroma planes (unsupported natively). Requires the Dither tools.<br/>
&nbsp;*By default dfttest outputs a sstring txt file to your script folder, you can delete it. This doesn't happen when using the modded dfttest (version 1.9.2 or higher) of the Dither tools.<br/>
For HD sources <var>prefilter=</var>2 makes more sense than 1, because it uses a wider denoising window.<br/>
<br/>
If instead you want to use your own <var>prefilter</var> denoiser, just define it in a variable and reference it here. Remember to:<br/>
<ul>
    <li>Feed always 8 bit clips.</li>
    <li>Input in fields for <var>interlaced</var> content <i>*(read below)</i></li>
    <li>Feed here planar ( by using <i>Interleaved2Planar()</i> ) YUY2 clips (not interleaved) when working with YUY2 sources.</li>
</ul>
You will likely want to use spatial denoisers like median filters (removegrain=17, medianblur, etc).<br/>
For very grainy or fizz grain noise you can try <var>prefilter=</var>4 as described above, other methods previosuly recommended are <var>prefilter</var>ing in temporal,<br/>
one example try adding a new <var>SMDegrain()</var> line again but without globals. Use <var>lsb_in</var>, <var>lsb_out</var> according so results are smooth.<br/>
You can even use <var>SMDegrain()</var> as a prefilter for <var>SMDegrain()</var> in very temporal unstable sources.<br/>
Another trick for fizz grain is to serve a <var>prefilter</var>ed clip where bright values are more denoised than dark values,<br/>
you can do this through luma masks with MasksPack LumaMask() function.<br/>
<br/>
Remember how <var>interlaced</var> sources must be <var>prefilter</var>ed (when you are serving it as your own custom <var>prefilter</var>):<br/>
For interlaced content use: <i>separatefields().spatial_prefilters_here()</i><br/>
For temporal filters odd and even frames must be processed separately: <i>separatefields().interleave(selecteven().TempPrefilt(),selectodd().TempPrefilt())</i><br/>
<br/>
<var>SMDegrain()</var> (its core: mdegrain in fact) is likely to produce blending artifacts or oversmooth/smearing in dark areas specially on cartoons, to tackle this see <a href="#RefineMotion"><var>RefineMotion</var></a><br/>
or expand the luma range in the darks. For this there are many options, you can use your preferred gamma enhancer and input it as the <var>prefilter</var>,<br/>
or use the examples below for linear brightening (ExTools) and input it as a <var>prefilter</var> as well. Or at last and the recommended solution,<br/>
to use the built-in <var>Str</var> (strength) and <var>Amp</var> (amplitude) parameters for a curve type dark enhancement, check the effects by enabling <var>Show</var><br/>
and changing your previewing conditions to PC levels.<br/>
<br/>
For brightening dark values with a simple gamma function<br/>
<pre>moncurve_r(1.4,0)</pre>
<br/>
Or excluding brighter parts<br/>
<pre>ex_contrast(-0.50, pivot=175)</pre>
<br/>
Which is similar to
<pre>ex_Luma_Rebuild(3.5, 0.1, tv_out=true)</pre>
<br/>
<br/>
Good resources for custom <var>prefilter</var> code:<br/>
<ul>
    <li><a href="http://forum.doom9.org/showthread.php?t=162813" target="_blank">http://forum.doom9.org/showthread.php?t=162813</a></li>
    <li><a href="http://forum.doom9.org/showthread.php?t=132310" target="_blank">http://forum.doom9.org/showthread.php?t=132310</a></li>
    <li><a href="http://forum.doom9.org/showthread.php?t=133977" target="_blank">http://forum.doom9.org/showthread.php?t=133977</a></li>
</li>
</ul>
<br/>Notes:
To sum it up; generally in denoising, temporal filters are always preferred due to its natural look (versus spatial filters).<br/>
But more often than not for good results <var>prefilter</var>ing plays a key role on the output quality, and setting it up nicely can be looked as an art by itself.<br/>
<br/>
If there's a reached point where no <var>prefilter</var>ing, nor <var>thSAD</var> tweaking, etc, makes able to denoise a certain motion part/area/scene,<br/>
then this is due to the motion vectors preventing them from being "denoised" (also read "artifacted"), in which case you will need to rely on alternative solutions (motion compensation, filters like MCTemporalDenoise(), TemporalDegrain(), <a href="http://forum.doom9.org/showthread.php?p=1544619#post1544619" target="_blank">Multilevel mdegrain</a>, etc) or just use plain spatial filters with motion masks.<br/>
Creating these discerning masks for static and motion scenes and combining them is a research task on the end user side.<br/>
<br/>
<h4><a id="mfilter"></a>mfilter</h4>
<i>[clip: - ]</i><br/>
<br/>
As with <var>prefilter</var>, in mfilter (Motion Filter) you can add a clip variable. This clip will be passed through those areas where smdegrain() couldn't find a matching block, normally high motion areas.<br/>
One use for it would be to to use spatial filters, like deblockers or blurring filters that mimic motion blur.<br/>
<br/>
<h4><a id="Str"></a>Str</h4>
<i>[float: 0.0 ~ 8.0]  Default: 5.0</i><br/>
<br/>
With this parameter you control the strength of the brightening of the <var>prefilter</var> clip. This is good when problems with<br/>
dark areas arise (check the <a href="#prefilter">above</a> explanation). The benefit of using this and not an external function is because this<br/>
is done in the same stage as the TV->PC range conversion thus more memory friendly and less quantization artifacts.<br/>
<br/>
<h4><a id="Amp"></a>Amp</h4>
<i>[float: 0.0 ~ 1.0]  Default: 0.0312</i><br/>
<br/>
Use this together with <var>Str</var> (active when <var>Str</var> is different from 1.0). This defines the amplitude of the brightening in the luma range, for example by using 1.0 all the<br/>
luma range will be used and the brightening will find its peak at luma value 128 in the original. Default is 0.0625 (1.0/16) which just sits over luma value 16 (256/16)<br/>
This and the <var>Str</var> parameters are extrapolated arguments of a cretindesalpes' function, you can find a graph and more insight explanations at the original <a href="http://forum.doom9.org/showthread.php?p=1548318#post1548318" target="_blank">post</a>.<br/>
Check these 2 parameters effects by enabling <var>Show</var>.<br/>
<br/>
<h4><a id="blksize"></a>blksize</h4>
<i>[int: 4, "8", 16]</i><br/>
<br/>
Size of a block (horizontal). (Default 16 for HD material)<br/>
Larger blocks are less sensitive to noise, are faster, but also less accurate.<br/>
<br/>
<h4><a id="overlap"></a>overlap</h4>
<i>[int: "<var>blksize</var>/2"]</i><br/>
<br/>
Must be *even* and *less* than block size. Common <var>overlap</var> values: <var>blksize</var>/4 or <var>blksize</var>/2.<br/>
The greater <var>overlap</var>, the more blocks number, and the lesser the processing speed.<br/>
<br/>
<h4><a id="search"></a>Search</h4>
<i>[int: 0, 1, "2", 3, 4, 5, 6, 7]</i><br/>
<br/>
    <ul>
    <li>0 = 'OneTimeSearch'</li>
    <li>1 = 'NStepSearch'</li>
    <li>2 = Logarithmic (Default)</li>
    <li>3 = Exhaustive</li>
    <li>4 = Hexagon (Default when Refinemotion=true)</li>
    <li>5 = Uneven Multi Hexagon (UMH)</li>
    <li>6 = pure Horizontal exhaustive search</li>
    <li>7 = pure Vertical exhaustive search</li></ul>
See details at <a href="http://avisynth.nl/index.php/MVTools" target="_blank">MVTools2</a> documentation.<br/>
<br/>
<h4><a id="Truemotion"></a>Truemotion</h4>
<i>[bool: "true", false] * "false" for HD</i><br/>
<br/>
<var>Truemotion</var> is a preset of some parameters values. It allows easy to switch default values of all "true motion" parameters at once.<br/>
Set it 'true' for true motion search (high vector coherence), set it 'false' to search motion vectors with best SAD.<br/>
Default is 'true' (as in MVtools2 default, and contrary to MCTemporalDenoise()).

By turning it off it could protect better low frequency details (shading) when in motion (i.e. walls, grounds, clouds texture, motion blur, etc),<br/>
and also protect from tiny details loss but it could leave more noise unfiltered.<br/>
Default is 'true' for smoother/cleaner (more temporal coherence) high frequency details or lineart. For HD sources where the main problems are just excessive grain,<br/>
I have defaulted it to false, this is not only faster but honors detail accuracy (the main existing point for HD sources) and overall object shading.<br/>
<br/>
<h4><a id="chroma"></a>Chroma</h4>
<i>[bool: "true", false]</i><br/>
<br/>
Takes chroma <var>plane</var>s into consideration for calculating the motion vectors.<br/>
Turn it off for more speed with little cost in quality, or when your chroma is not reliable enough for motion estimation.<br/>
&nbsp;&nbsp;*<i>Whatch out if you turn this off when processing chroma planes (aka luma vectors when chroma denoising), it has shown problems in <a href="http://forum.doom9.org/showthread.php?p=1551305#post1551305" target="_blank">previous tests</a>.</i><br/>
<br/>
<br/>
<h4><a id="hpad"></a>Hpad, Vpad</h4>
<i>[int: "<var>blksize</var>"]</i><br/>
<br/>
It is horizontal/vertical padding added internally to source frame (both left and right, and top and bottom).<br/>
Small padding is added for more correct motion estimation near frame borders.<br/>
Try to have clean borders in your source (no NAB*/black borders) to start with before tweaking this setting.<br/>
If necessary, crop beforehand ideally in multiples of 16. Turn it to 0 if you are running out of resources in your system.<br/>
*<i>Nominal Analog Blanking</i><br/>
<br/>
<br/>
<h4><a id="thSCD1"></a>thSCD1</h4>
<i>[int: "400"] *int(pow((<var>blksize</var>*2.5),2))</i><br/>
<br/>
Threshold which decides whether a block has changed between the previous frame and the current one. So it is one of the thresholds used to tweak the scene changes detection engine. Raising it will lower the number of blocks detected as changed. It may be useful for noisy or flickered video. To fix blending on scene changes on dark scenes, try first the <var>Str</var> and <var>Amp</var> parameters.<br/>
<br/>
<br/>
<h4><a id="thSCD2"></a>thSCD2</h4>
<i>[int: 0~"130"~255]</i><br/>
<br/>
Threshold which sets how many blocks have to change for the frame to be considered as a scene change.<br/>
<br/>
<br/>
<h4><a id="limit"></a>limit,limitC</h4>
<i>[int: 1 ~ "255"]</i><br/>
<br/>
Maximal change of pixel luma/chroma (post-process like DeGrainMedian plugin<br/>
and LimitChange function of SSETools plugin, to prevent some artifacts)<br/>
<br/>
<br/>
<h4><a id="CClip"></a>CClip</h4>
<i>[clip: - ]</i><br/>
<br/>
Define here a variable name referencing an earlier stage of your processing chain as the sharp version for the <var>contrasharp</var>ening to compare against.<br/>
Just keep in mind video resolution must be the same size and the features comparable.<br/>
<br/>
    <ul><li>If <var>contrasharp</var> is not declared, by default it will use the <i>contrasharpening()</i> function, add <var>contrasharp=</var>'an integer' to force <i>LSFmod</i> instead.</li>
    <li>For <var>interlaced</var> sources input must also be <var>interlaced</var>.</li>
    <li>You can reference either 8 or 16bit sharp clips independently.</li></ul>
<br/>
<h4><a id="Globals"></a>Globals</h4>
<i>[int: "0", 1, 2, 3 ]</i><br/>
<br/>
With this parameter you can, among other things, load pre-processed motion vectors (<var>Globals=</var>1), so you save doing this step again.<br/>
<br/>
The integers define what do you want to do with the global variables. Default is 0.<br/>
<br/>
 <ul>
    <li>0: Don't read nor output globals (Just process) (Default)</li>
    <li>1: Read globals --> Process</li>
    <li>2: Process      --> Output globals</li>
    <li>3: Output globals only (Don't process clip)</li></ul>
<br/>
Some parameters MUST MATCH those from the processed vectors stage (e.g. <var>Globals=</var>2 or 3) and the read vectors stage (e.g. <var>Globals=</var>1).
<var>pel=</var>, <var>subpixel=</var>, <var>chroma=</var> and <var>vpad/hpad</var>.
Other than that the only settings that work when reading (<var>Globals=</var>1) are: <var>tr=</var>, <var>thSAD=</var>, <var>plane</var>, <var>limit</var>, <var>limitc</var>, <var>contrasharp</var>, <var>CClip</var> and the <var>interlaced</var> parameters. Others are ignored.<br/>
Global names that can be reused are: <var>Super</var>, <var>bv1</var>, <var>fv1</var>, <var>bv2</var>, <var>fv2</var>, <var>bv3</var>, <var>fv3</var>, <var>bv4</var>, <var>fv4</var>, <var>bv6</var>, <var>fv6</var>, <var>vmulti</var>.<br/>
<br/>
e.g.:<pre>
                         SMDegrain(tr=3,thSAD=400,globals=3)    # Outputs vectors

                         SMDegrain(tr=2,thSAD=200,globals=1)    # You can use a same or <b>lower</b> "tr" or "thSAD" if you want</pre>
or<pre>

                         SMDegrain(tr=3,thSAD=400,globals=3)    # Outputs vectors

                         Super = MSuper(levels=1)               # Add this line just before if you have some processing between Globals Output and Input.
                         MDegrain3(Super, bv1, fv1, bv2, fv2, bv3, fv3, thSAD=400)</pre><br/>
<br/>
<br/>
<h4><a id="Show"></a>Show</h4>
<i>[bool: true, "false" ] or [string: "Speed", "Memory", "Quality" ]</i><br/>
<br/>
This will show the <var>prefilter</var>ed clip to be used for the motion search to the left(<--), and the used parameters list to the right (-->)<br/>
<br/>
If you set <var>Show</var> to a string as indicated above, related parameters will be highlighted to guide you on<br/>
correctly tweaking the function. This is loosely based, so it doesn't exclude you from reading carefully every parameter explanation.<br/>
<br/>
Even when you are not using any <var>prefilter</var>ing, the clip to be used for the motion search where you obtain the motion vectors,<br/>
will be converted from TV levels to PC levels, the only exception being when using <var>Globals=</var>1 (Read) in which case the "<var>prefilter</var>ed" clip<br/>
will be exactly the same as input clip (that is no luma conversion, although constrained to 8 bit). Additionally you can tweak the dark expansion with<br/>
<var>Str</var> and <var>Amp</var> parameters and check the effects in the left panel, but be aware to change your viewing conditions as it is in PC levels.<br/>
<br/>
The left panel preserves its properties so you can crop out the right panel and use it as a <var>prefilter</var> clip of any <i>msuper()</i>.<br/>
Therefore if you are not processing chroma for motion analysis(<var>chroma=</var>false) the <var>prefilter</var>ed clip will be green, don't panic, this is correct, this happens when the<br/>
U and V <var>plane</var>s are set to a value of 0 which is a dummy value meaning nothing or "discard". In this regard for previewing tasks with <var>prefilter</var>ings<br/>
or just the <var>Str</var> and <var>Amp</var> effect simply set <var>chroma</var> to true temporally. For YUY2 sources set <i>Planar2Interleaved()</i> after cropping for previewing.<br/>
<p>&nbsp;</p>
<h2><a id="finalnotes"></a>Final Notes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
If there is an important parameter not implemented,<br/>
you have any issue or found a bug, please don't hesitate<br/>
and ask in the main Doom9 thread:<br/><br/>
(<a href="https://forum.doom9.org/showthread.php?p=1972585" target="_blank">https://forum.doom9.org/showthread.php?p=1972585</a>)<br/>
<p>&nbsp;</p>
<h2><a id="examples"></a>Example Scripts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<br/>
A basic yet very functional call for light grain (mvtools2+ExTools only needed)
<pre>SMDegrain(tr=1,thSAD=300,contrasharp=true)</pre>
<br/>
A typical more elaborated call compatible with official mvtools2 (mvtools2+ExTools only needed)
<pre>SMDegrain(tr=2,thSAD=300,interlaced=true,prefilter=1,contrasharp=true)</pre>
<br/>
The next is a personal preference. Turned all chroma off for safeness (on SD chroma is rarely temporal-reliable enough) and speed.
<pre>SMDegrain(tr=2,thSAD=300,contrasharp=true,refinemotion=true,chroma=false,plane=0)</pre>
<br/>
This is a good example to show that <var>interlaced</var> YUY2 sources can be processed seamlessly.
<pre># mod4 (modulus 4) interlaced YUY2 source
SMDegrain(tr=1,thSAD=250,interlaced=true,contrasharp=true)</pre>
<br/>
HD sources are detected automatically, and as so settings are optimized for speed; <var>pel=</var>1, <var>blksize=</var>16, <var>overlap=</var>8, <var>truemotion=</var>false
<pre># HD source (from 1100px wide or 600px high up)
SMDegrain(tr=2,thSAD=180,prefilter=2,contrasharp=30,refinemotion=true,chroma=false,plane=0)</pre>
<br/>
Tackling a grainy source:
<pre>
pre=fluxsmootht(3).removegrain(11)
SMDegrain(tr=6,thSAD=500,contrasharp=40,prefilter=pre,str=1.2,refinemotion=true)</pre>

OR

<pre>SMDegrain(tr=5,thSAD=500,contrasharp=40,prefilter=4,str=1.2,refinemotion=true)
</pre>
<br/>
How to reference a prior state of the script for the <var>contrasharp</var>ening process.
<pre>sharp_ref=last
dfttest(tbsize=1,sigma=10)

SMDegrain(tr=3,thSAD=300,CClip=sharp_ref)</pre>
<br/>
<br/>
How to degrain an HDR PQ encoded clip.
<pre>pre=DGHDRtoSDR(mode="pq",white=ceil(59.49080238715383))
pre=pre.ex_Luma_Rebuild(5, 0.03, tv_out=false)

SMDegrain(tr=3,thSAD=300,prefilter=pre)</pre>
<br/>
(Re)using motion vectors <var>globals</var>
<pre>SMDegrain(tr=1,thSAD=400,prefilter=3,str=1.4,globals=3)    # Output vectors only
MFlowFps(Super, bv1, fv1, num=60,den=1)</pre>
<br/>
<p>&nbsp;</p>
<h2><a id="changelog"></a>Changelog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#up"><b>▲</b></a></h2>
<p><b>v3.5.6d</b> (30-11-2022)</p>
    <ul>
        <li>Fix pixel center shift deviation in nnedi3 (subpixel=4) for high pel</li>
        <li>Swap prefilter 6 and 7 order for more coherence</li>
        <li>Tweak mode="dfttest" internal 'tmode' arg to work with odd 'tr'</li>
    </ul>
<p><b>v3.5.5d</b> (20-09-2022)</p>
    <ul>
        <li>Add 'DFTTest' as mode</li>
        <li>Update Documentation (WIP)</li>
        <li>Cosmetics</li>
    </ul>
<p><b>v3.5.4d</b> (02-08-2022)</p>
    <ul>
        <li>Replaced NNEDI3CL() with nnedi3wrap() so you can switch to CPU or GPU nnedi3 via 'gpuid' arg</li>
        <li>Since ResizersPack is now mandatory, nmod() was used where appropiate</li>
        <li>Fixed dimension references when UHDHalf is used</li>
        <li>Changed Str=1 to go directly to ConvertBits()</li>
        <li>Fixed 'show' panel for UHD and increased curve precision in 'show'</li>
        <li>ex_retinex() - Fixed normalization in HBD for lvl=3</li>
        <li>ex_retinex() - Expanded mask terminator</li>
    </ul>
<p><b>v3.5.3d</b> (08-07-2022)</p>
    <ul>
        <li>Replace nnedi3 calls (CPU based) with NNEDI3CL (GPU) when subpixel=4</li>
    </ul>
<p><b>v3.5.2d</b> (28-06-2022)</p>
    <ul>
        <li>ex_luma_rebuild() - Add RGB support</li>
        <li>ex_retinex() - Support for single channel clips</li>
        <li>ex_retinex() - Argument to disable highlight compression</li>
    </ul>
<p><b>v3.5.1d</b> (01-06-2022)</p>
    <ul>
        <li>Update function definitions</li>
        <li>Rename 'device_id' arg to 'gpuid'</li>
        <li>Allow CPU processing for prefilters via gpuid=-1</li>
        <li>Update UHD downscale coefficients</li>
        <li>'Str=1.0' is inclusive for ex_luma_rebuild() (only does a range conversion)</li>
        <li>ex_retinex() - Default UV to 3, for when used as stand-alone</li>
        <li>ex_retinex() - Add proper greyscale conversion</li>
        <li>ex_BM3D() - Add 'gpuid' argument</li>
        <li>ex_KNLMeansCL() - Change 'device_id' to 'gpuid'</li>
    </ul>
<p><b>v3.5.0d</b> (17-04-2022)</p>
    <ul>
        <li>Change 'search' and 'thSCD1' Defaults</li>
        <li>ex_Luma_Rebuild() - Add 'tv_out' and 'bits' args</li>
        <li>ex_retinex() - Change pmax to not thresholded max for lvl=3</li>
    </ul>
<p><b>v3.4.9d</b> (01-04-2022)</p>
    <ul>
        <li>Tweak some defaults; searchr, DCTR, pelsearch, plevel, pglobal, searchparam and searchparamr</li>
        <li>Force input to frame based also for pel > 2</li>
        <li>Fix pelclip height for interlaced sources</li>
        <li>Retrieve prefilter '_ColorRange' instead of using input's</li>
        <li>Use lvl=3 for ex_retinex() prefiltering if '_SceneRange' is present</li>
        <li>ex_retinex() - Add 'tv_out' arg when output is not for prefiltering use cases</li>
        <li>ex_retinex() - Add 'lvl=3' mode, will use scene based accumulated min and max stats</li>
    </ul>
<p><b>v3.4.8d</b> (09-03-2022)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Rebase to latest LSFPlus</li>
        <li>Fine tune function definitions</li>
        <li>ex_luma_rebuild() - Add selective propCopy and update 'Str' and 'c' defaults</li>
        <li>ex_KNLMeansCL - Add 'DCT' arg and add propCopy</li>
        <li>ex_KNLMeansCL/ex_DGDenoise - Default 'DCT' to true</li>
    </ul>
<p><b>v3.4.7d</b> (15-02-2022)</p>
    <ul>
        <li>Adjust defaults for internal ex_luma_rebuild()</li>
        <li>Subpixel=3 (now Default) is blackmanresize(taps=8), nnedi3 is now subpixel=4</li>
        <li>Fine tuned prefiltering settings and ex_BM3D() uses CUDA back again</li>
        <li>ex_BM3D() - Add 'preset' arg and add additional arguments to BM3D_CUDA and BM3D_CPU calls</li>
        <li>ex_DGDenoise() - Add LFR and DCT args</li>
        <li>ex_KNLMeansCL() - Turn 'LFR' to float and rebase with ex_LFR()</li>
    </ul>
<p><b>v3.4.6d</b> (08-02-2022)</p>
    <ul>
        <li>Fix typo in ex_KNLMeansCL()</li>
        <li>Reimplement back ex_KNLMeansCL() as prefilter=5</li>
        <li>Shift ex_DGDenoise() to prefilter=7</li>
        <li>Add post-blur to prefilter=5 and prefilter=7</li>
        <li>Default prefilter=6 (ex_BM3D) to CPU mode (CUDA is bugged)</li>
    </ul>
<p><b>v3.4.5d</b> (08-02-2022)</p>
    <ul>
        <li>ex_DGDEnoise() - New GPU based denoiser wrapper</li>
        <li>ex_KNLMeansCL() - Add 'wref' arg and limit 's' to 8</li>
        <li>Replace ex_KNLMeansCL() with ex_DGDenoise() as prefilter=5</li>
        <li>Optimize 'thSADR' and 'thSADC' Defaults</li>
        <li>LSFmod() - Change 'smode' to 4 for HD</li>
        <li>ex_Luma_Rebuild() - Fix 'show' setting</li>
        <li>ex_retinex() - frameprops passthrough</li>
        <li>ex_BM3D() - Add better matrix detection for the format conversions</li>
        <li>ex_BM3D() - Default chroma sigma to 1 when not used otherwise garbage output</li>
    </ul>
<p><b>v3.4.4d</b> (28-01-2022)</p>
    <ul>
        <li>Add 'IQMT' as degrain mode</li>
        <li>Add range arg to nnedi3</li>
        <li>Rebase LSFmod to latest version</li>
    </ul>
<p><b>v3.4.3d</b> (23-01-2022)</p>
    <ul>
        <li>Removed 'trymany' and 'divide' arguments</li>
        <li>Changed a few defaults; revert 'overlap', tune 'sharp', 'rfilter' and scaleCSAD</li>
        <li>Add a low frequency sharpened prefilter when LFR is enabled</li>
        <li>Optimize/simplify ex_KNLMeansCL() 'LFR'  algorithm</li>
        <li>Add a stronger LFR for ex_KNLMeansCL prefilter</li>
        <li>Fix issue when subpixel=3 was used (limit 'sharp' to 2 in MSuper)</li>
        <li>ex_minblur()/ex_sbr() - Fixed last call clip order to properly inherit frameprops</li>
    </ul>
<p><b>v3.4.2d</b> (10-01-2022)</p>
    <ul>
        <li>Add function definitions</li>
        <li>Fix for ex_luma_rebuild() plot</li>
    </ul>
<p><b>v3.4.1d</b> (08-01-2022)</p>
    <ul>
        <li>Default overlap to blksize/4 when refinemotion is used. (Slight +detail retention when motion and +performance)</li>
        <li>Rebase to latest ExTools. Affected 'fulls' args in prefilter=0 and prefilter=4</li>
        <li>ex_luma_rebuild() - Add 'show' argument to show curve plot</li>
    </ul>
<p><b>v3.4.0d</b> (14-12-2021)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Fix for default LFR value on UHD clips</li>
        <li>Optimized tv to pc luma range for HBD inputs and Str=0</li>
    </ul>
<p><b>v3.3.9d</b> (03-12-2021)</p>
    <ul>
        <li>Recursion for MDegrain</li>
        <li>Defaults when input is single plane or plane=0</li>
        <li>Clean Asserts and allow blksize of 24</li>
        <li>Prefilter UHD clips in its halved version (if UHDHalf=true, default)</li>
        <li>New prefilter=3 for ex_FluxSmoothST(), following modes are shifted up in number</li>
        <li>Fix super_render when reading Globals</li>
        <li>ex_Luma_Rebuild() use internal scale_inputs when tv_range=false (faster) + ditch 'fulls'</li>
        <li>ex_retinex() use internal scale_inputs when tv_range=false (faster) + ditch 'fulls'</li>
        <li>ex_retinex() replace old YPlaneMin/Max with PlaneMinMaxStats</li>
        <li>ex_BM3D() switch 'fulls' arg with 'tv_range'</li>
        <li>ex_BM3D() new arg 'OPP' to filter in OPP space as originally intended</li>
    </ul>
<p><b>v3.3.8d</b> (14-11-2021)</p>
    <ul>
        <li>Optimize nnedi3 for subpixel=3</li>
        <li>Rename srfilter to rfilter</li>
        <li>Final tweaks to DCTFlicker</li>
    </ul>
<p><b>v3.3.7d</b> (13-11-2021)</p>
    <ul>
        <li>ex_MinBlur() 'th' arg. </li>
        <li>Add 'smart2' and 'smart3' modes</li>
        <li>Use 8-bit for subpixel=3.</li>
    </ul>
<p><b>v3.3.6d</b> (12-11-2021)</p>
    <ul>
        <li>Remove 'fulls' arg, now it's derived from frameprops or overriden by tv_range arg</li>
        <li>Fill in appropiate values for 'fulld'</li>
        <li>Increase blksize limit to 64</li>
        <li>Improve DCTFlicker filtering</li>
        <li>Default DCTFlicker to false</li>
    </ul>
<p><b>v3.3.5d</b> (05-11-2021)</p>
    <ul>
        <li>Small optimization to ex_sbr() and ex_MinBlur()</li>
        <li>Add "FluxSmoothT" degrain mode</li>
        <li>Repurpose 'LFR' argument to frequency values (100 ~ 500)</li>
        <li>Rework nnedi3 multithreading arguments (requires SysInfo)</li>
        <li>Fix 'mfilter' for tr > 6</li>
        <li>Replace non-MDegrain LFR process code with that of MDegrain (faster)</li>
        <li>Add 'DCTFlicker' argument, to 'calm' restored low frequency detail</li>
        <li>Fix show panel when input is 32-bit float</li>
        <li>Helper functions - 32-bit support. Preparing for SMDegrain 32-bit support</li>
    </ul>
<p><b>v3.3.4d</b> (10-10-2021)</p>
    <ul>
        <li>Implement back recursion for "medianT" mode</li>
        <li>'LFR' setting, to restore lost low-frequency details</li>
        <li>Fix UHDhalf chroma placement (assumes 'top_left')</li>
        <li>ex_KNLMeansCL() - Update passing more arguments including 'lores' to restore low-frequency details</li>
        <li>Tune prefilter=4 (ex_KNLMeansCL()) for a bit more sharpness</li>
        <li>Implement mfilter contrasharpening fix to defined CClip as well</li>
        <li>ex_retinex() - use clip instead of scale for NaN blocks bug</li>
    </ul>
<p><b>v3.3.3d</b> (08-10-2021)</p>
    <ul>
        <li>More denoising modes</li>
        <li>Fix mfilter for Contrasharpening and non MDegrain modes</li>
        <li>ex_retinex() - convert to function objects</li>
        <li>ex_retinex() - aminorate black clipping issue</li>
        <li>Add dependency list</li>
    </ul>
<p><b>v3.3.2d</b> (23-09-2021)</p>
    <ul>
        <li>Add recursion mode when using alternative denoisers</li>
        <li>Export in above cases the MC clip directly instead of vectors for temporal limiting contrasharpening</li>
        <li>Let more room (overshoot) for not heavy grain contrasharpening when using TemporalSoften and ex_contrasharpening</li>
    </ul>
<p><b>v3.3.1d</b> (22-09-2021)</p>
    <ul>
        <li>Updated ex_gaussianblur() call in ex_retinex()</li>
        <li>Updated LSFmod call to accept temporal limiting if limitS=true and LRad if isHD</li>
        <li>New 'mode' arg to select MC denoiser of choice from TemporalSoften (for very grainy sources) and ex_median() modes. Might be faster than MDegrain for comparable results</li>
    </ul>
<p><b>v3.3.0d</b> (15-09-2021)</p>
    <ul>
        <li>Reordered Defaults</li>
        <li>limitS, new setting for spatial/temporal contrasharpening limiting</li>
        <li>Relaxed supersampling in LSFmod for more performance</li>
        <li>ex_MinBlur() and ex_sbr() Expr optimizations</li>
        <li>ex_retinex(), 'lo' and 'hi' arguments for post normalization in fixed mode (lvl=1)</li>
    </ul>
<p><b>v3.2.9d</b> (09-09-2021)</p>
    <ul>
        <li>Optimize + improve ex_retinex() with 'level' modes</li>
    </ul>
<p><b>v3.2.8d</b> (07-09-2021)</p>
    <ul>
        <li>Fine tune ex_retinex()</li>
        <li>ex_retinex() add missing "fulls"</li>
        <li>Bugfix for fulls in ex_BM3D()</li>
    </ul>
<p><b>v3.2.7d</b> (01-09-2021)</p>
    <ul>
        <li>ex_retinex(). Reworked luma rebuild logic with FrameProps</li>
        <li>Make ex_retinex() more temporal stable</li>
        <li>Optimize ex_retinex()</li>
        <li>Optimize ex_MinBlur()</li>
    </ul>
<p><b>v3.2.6d</b> (27-08-2021)</p>
    <ul>
        <li>'UHDhalf' and 'Interlaced' logic fixed</li>
    </ul>
<p><b>v3.2.5d</b> (25-08-2021)</p>
    <ul>
        <li>Add UHDhalf argument</li>
        <li>ex_MinBlur() optimizations</li>
        <li>Moved ex_ContraSharpening() to SharpenersPack</li>
        <li>ex_MinBlur() corner case bugfixes</li>
    </ul>
<p><b>v3.2.4d</b> (12-08-2021)</p>
    <ul>
        <li>ex_ContraSharpening() - Revert to removegrain(20)</li>
        <li>Rebase to latest ExTools</li>
        <li>Fix ex_BM3D() issue when 32-bit</li>
        <li>Fix 'threads' issue</li>
        <li>Remove masktools2 dependency</li>
    </ul>
<p><b>v3.2.3d</b> (04-08-2021)</p>
    <ul>
        <li>Add BM3D as prefilter</li>
        <li>Fix contrasharpening for HD</li>
        <li>Fix Thread var when argument is empty</li>
        <li>Use BilinearResize for UHD (vector scaling)</li>
    </ul>
<p><b>v3.2.2d</b> (22-06-2021)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Add 'fulls' arg</li>
    </ul>
<p><b>v3.2.1d</b> (18-06-2021)</p>
    <ul>
        <li>Rebase to latest ExTools</li>
        <li>Add 'tv_range' arg</li>
        <li>Enable 'Str' as default (str=2)</li>
    </ul>
<p><b>v3.2.0d</b> (11-06-2021)</p>
    <ul>
        <li>Resume from v3.1.2.111s (continuation mod from real.finder)</li>
        <li>Code sanitation (remove old avisynth support -pre AVS+-, DitherTools support and YUY2 support)</li>
        <li>Ported masktools2 to ExTools</li>
        <li>Merged back prefilters from function based to SMDegrain¡s in-code</li>
        <li>Change DCT and subpixel defaults</li>
        <li>Add internal scaleCSAD defaults</li>
        <li>Add UHD optimization via MScaleVect</li>
        <li>Remove 'bits' arg from MScaleVect</li>
        <li>ex_sbr()/ex_MinBlur() optimizations</li>
        <li>ex_Luma_Rebuild() optimizations and cleanup</li>
    </ul>
<p><b>v3.1.2d</b> (21-07-2015)</p>
    <ul>
        <li>Fixed regression where external prefilters wouldn't be parsed for luma expansion</li>
    </ul>
<p><b>v3.1.1d</b> (16-07-2015)</p>
    <ul>
        <li>Workaround to force KNLMeansCL use discrete video card (now required)</li>
    </ul>
<p><b>v3.1d</b> (14-07-2015)</p>
    <ul>
        <li>New prefilter mode 4 for grainy sources. GPU based spatio-temporal KNLmeans</li>
        <li>Added dither output mode "Random Dither".</li>
        <li>Added "slices" option from Dither</li>
        <li>Added soft=-2 (automatic) to internal lsfmod</li>
        <li>Added assert for chroma denoise when luma only motion vectors (mvtools bug)</li>
        <li>Improved lsb_in code (now using sub/add method)</li>
        <li>Removed vpad/hpad=0 optimization preset for HD</li>
        <li>Fixed prefilter=3 code for lsb_in YUY2</li>
        <li>More fixes to Show Panel...</li>
        <li>Updated and fixed documentation (notes on YUY2 support)</li>
    </ul>
<p><b>v3.0d</b> (27-03-2015)</p>
    <ul>
        <li>Adjusted SD<>HD discretion</li>
        <li>Added mfilter (Motion Filter) new feature</li>
        <li>subpixel=3 (nnedi3); removed qual=2 due to possible blending bug (quote by cretindesalpes), this also boosts speed</li>
        <li>Lowered the defaults for less aggressive denoise (still somewhat high)</li>
        <li>Fixed chroma not showing in debug (show) mode when lsb=true and prefilter=3 were paired</li>
        <li>Fixed long lasting issues in Show Panel for certain not mod height resolutions</li>
        <li>Now prefilter=0 is minblur(0), lighter denoising than prefilter=1, default is now -1 (off)</li>
        <li>Documentation update (plugin updates, notes, links, examples, etc)</li>
    </ul>
<p><b>v2.2d</b> (05-03-2013)</p>
    <ul>
        <li>Removed one residual variable in Contrasharpening function</li>
        <li>Fixed a regression at v2.0 for Interlaced YUY2 sources by changing wrong variable ifC to if0, and...</li>
        <li>...adding a missing weave() to the last MergeChroma() call</li>
        <li>Dropped Dither support. (Will still work/not work as before, but lack of official support renders it to a YMMV condition)</li>
    </ul>
<p><b>v2.1d</b> (09-09-2012)</p>
    <ul>
        <li>Fixed Refinemotion Globals Input labels</li>
        <li>Fixed ContrasharpeningHD Vectors for Interlaced HD sources</li>
        <li>Added ability to import Global Vectors even when "tr" is lower than parent instance "tr" (credit to cretindesalpes)</li>
        <li>Expanded support for Interlaced Denoising "tr" up to 64 (credit to cretindesalpes)</li>
        <li>Cosmetics</li>
    </ul>
<p><b>v2.0d</b>  (07-06-2012)</p>
    <ul>
        <li>Fixed and optimized chroma handling for lsb_in, contrasharpening and YUY2 content v.1.95</li>
        <li>Enhanced Chroma bypass on the sharpening stage</li>
        <li>Merged ContraHD() internally for Contrasharpening in HD sources</li>
        <li>Dropped QTGMC support on import/export motion vectors (small value for increased confusion)</li>
        <li>Fixed Median code for planar inputs in MinBlur() (needs RemoveGrainHD, dropped medianblur requirement)</li>
        <li>Defaulted truemotion to false for HD inputs</li>
        <li>Code Optimization and Clean up</li>
        <li>Others</li>
    </ul>
<p><b>v1.9d</b>  (23-03-2012)</p>
    <ul>
        <li>Added truemotion parameter (default=true), change it to false (as in MCTemporalDenoise()), so low frequency detail won't be lost (walls...), although it could leave more noise on high frequency details</li>
        <li>Added thSADC, and thSCD1/thSCD2 parameters for finer control</li>
        <li>Tweaked prefilter=3 dfttest sigmas for better low frequency detail protection</li>
        <li>Detached explanation and converted to html. Updated and extended the contents as well</li>
        <li>Fine tuned and robustized the Show Panel</li>
        <li>Optimized and organized code, more precisely the contrasharpening part</li>
        <li>Fixed a few ternary checks for when Globals=3</li>
        <li>Others</li>
    </ul>
<p><b>v1.8d</b>  (18-01-2012)</p>
    <ul>
        <li>Added automatic dark protection for prefilter=3 (dfttest performs badly in darks) v1.71d and extended its dark protection v1.8</li>
        <li>Fixed chroma variable when chroma=false, from 2 (copy chroma) to 1 (discard chroma) v1.71d</li>
        <li>Explanation and cosmetics v1.71d</li>
        <li>Added acknowledgments and updated explanation</li>
        <li>Added brackets to all functions (it has been reported to cause threading problems under certain circumstances) (<a href="http://forum.doom9.org/showthread.php?p=1515886#post1515886" target="_blank">http://forum.doom9.org/showthread.php?p=1515886#post1515886)</a></li>
        <li>Reworked and fixed the parameters panel. Now you have a color guide to have an idea on what to tweak depending on selected mode in Show. For strings: "Speed", "Memory" and "Quality"</li>
        <li>Optimized lsb_in for HD resolutions which was causing memory hogs</li>
        <li>Fixed contrasharpening for YUY2 sources when lsb=true</li>
        <li>Fixed some inconsistencies for YUY2 sources when prefilter=3</li>
    </ul>
<p><b>v1.7d</b>  (11-01-2012)</p>
    <ul>
        <li>Fixed and extended introduction explanation v.1.61d</li>
        <li>Fixed some issues for Globals=1 (Read) in relation to lsb_in and luma expansion auto-prefilter v.1.61d</li>
        <li>Added mild gauss blur prefilter option as prefilter=1. Consequent modes are displaced v.1.61d</li>
        <li>Changed prefilter 1 and 2 to Minblur (Gauss/Median combination) v.1.63d</li>
        <li>Updated MinBlur function v.1.62d and v.1.66</li>
        <li>Code tidied up v.1.62d
        <li>Updated luma expansion, now you can enhance darks (with 'Str' and 'Amp') in the same step as the TV->PC conversion stage, thus +optimized, +quality. v.1.63d by cretindesalpes (<a href="http://forum.doom9.org/showthread.php?p=1548318#post1548318" target="_blank">http://forum.doom9.org/showthread.php?p=1548318#post1548318)</a></li>
        <li>Removed pre_custom. Now use prefilter to load a prefiltered clip, as well as modes 0~3</li>
        <li>Added Show parameter. Now you can see the used and default parameters along the prefilter clip as well</li>
        <li>Fixed one note related to prefilter clip input for interlaced content</li>
    </ul>
<p><b>v1.6d</b>  (24-12-2011) (first open release)</p>
    <ul>
        <li>Fixed and extended introduction explanation</li>
        <li>Fixed Ditherpost for interlaced sources</li>
        <li>Fixed a broken reference for reading MRecalculate globals when tr>3</li>
        <li>Fixed a Globals=1 MSuper automatization</li>
        <li>Fixed a plane processing bypass when chroma=false</li>
        <li>Added LSFmod as optional contrasharpening (slower, but biased contrasharpening and probably better depending on source)</li>
        <li>Added default luma expansion auto-prefilter for motion search (16% more values)</li>
        <li>Added YUY2 support</li>
        <li>Added the 'mode' parameter of Ditherpost()</li>
        <li>Added support for interlaced temporal radius up to 6</li>
    </ul>
<p><b>v1.5d</b>  (14-10-2011)</p>
    <ul>
        <li>Changed "srchSuper" Global variable to "QTGMC_srchSuper", compatible with QTGMC. Anyhow you may probably want to create a new super clip. Test it out! v.1.41d</li>
        <li>Introduction spelling and presentation v.1.42d</li>
        <li>Added lsb and lsb_in for prefilter=2 (dfttest) v.1.43d & v.1.44d</li>
        <li>Some better definitions for the settings help v.1.45d</li>
        <li>pelclip is now subpixel = 3 ('sharp' parameter before) v.1.45d</li>
        <li>Other minor tweaks v.1.45d</li>
        <li>Fixed an important issue when using prefilter with subpixel=3 ('pelclip' parameter before)</li>
        <li>Optimizations in Ditherpost for chroma</li>
        <li>Changed rfilter (hierarchical levels smoothing/scaling) from default 2 to 4. Better results in my judge</li>
        <li>Some more little tweaks in code and introduction</li>
    </ul>
<p><b>v1.4d</b>  (16-09-2011)</p>
    <ul>
        <li>Added pelclip option for top quality subpixel interpolation when pel > 1</li>
        <li>Changed QTGMCV parameter to Globals, and added a bunch of new features like vectors output from <var>SMDegrain()</var></li>
        <li>Big introduction and code optimization tweaks</li>
    </ul>
<p><b>v1.3d</b>  (14-09-2011)</p>
    <ul>
        <li>Fixed an important issue on the Interlaced parameter and improved overall handling (v.1.21d & v.1.3d)</li>
    </ul>
<p><b>v1.2d</b>  (13-09-2011)</p>
    <ul>
        <li>Added Interlaced parameter, for processing interlaced sources</li>
        <li>Some introduction and code optimization tweaks (v.1.12d & v.1.2d)</li>
    </ul>
<p><b>v1.1d</b>  (12-09-2011)</p>
    <ul>
        <li>Implemented MDegrainN for tr > 3, from the MVTools2 mod of Dither</li>
        <li>Minor introduction and code optimization tweaks</li>
    </ul>
<p><b>v1.0d</b>  (09-09-2011)</p>
    <ul>
        <li>Added CClip parameter. Reference an earlier stage of your processing chain as your sharp version for the contrasharpening</li>
    </ul>
<p><b>v0.9d</b>  (09-09-2011)</p>
    <ul>
        <li>Added QTGMCV parameter, for reusing vectors from QTGMC bob deinterlacer</li>
    </ul>
<p><b>v0.8d</b>  (05-09-2011)</p>
    <ul>
        <li>Fixed a few things related to the lsb_in option</li>
        <li>Minor introduction and code optimization tweaks</li>
    </ul>
<p><b>v0.7d</b>  (05-09-2011)</p>
    <ul>
        <li>Implemented "fake" lsb_in option. Output will have slightly more quality (if any), and will compress better. (Experimental)</li>
        <li>Fixed a not passed argument in the hpad, vpad parameters</li>
    </ul>
<p><b>v0.6d</b>  (04-09-2011)</p>
    <ul>
        <li>Minor introduction and code optimization tweaks</li>
    </ul>
<p><b>v0.5d</b>  (19-07-2011)</p>
    <ul>
        <li>Added dfttest option for preblur (now prefilter) option. Slower but better due to its internal deblock+denoise operation, plus sharper results</li>
        <li>Added pre_custom option for the prefilter process, define here a denoised clip as your prefiltered version</li>
        <li>Updated the introduction help</li>
    </ul>
<p><b>v0.4d</b>  (03-06-2011)</p>
    <ul>
        <li>Added preblur option for slight vector blurring where motionmatch is bad                     (<a href="http://forum.doom9.org/showthread.php?t=161594" target="_blank">http://forum.doom9.org/showthread.php?t=161594)</a></li>
        <li>Added RefineMotion parameter for better motion vectors. Based off Killer()                   (<a href="http://forum.doom9.org/showthread.php?p=1266572#post1266572" target="_blank">http://forum.doom9.org/showthread.php?p=1266572#post1266572)</a></li>
        <li>Added parameters "lsb" and "lsb_out", for the MVTools2 mod version of cretindesalpes' Dither (<a href="http://forum.doom9.org/showthread.php?p=1386559#post1386559" target="_blank">http://forum.doom9.org/showthread.php?p=1386559#post1386559)</a></li>
        <li>Other minor aesthetics and performance adjustments</li>
    </ul>
<p><b>v0.3d</b>  (04-03-2011)</p>
    <ul>
        <li>First Mod version</li>
        <li>Fixed plane (for MDegrain) and added chroma (for MAnalyse) parameters</li>
    </ul>
<p><b>v0.2</b>  (24-01-2010)</p>
    <ul>
        <li>Added introductory section</li>
        <li>Added more parameters</li>
    </ul>
<p><b>v0.1</b></p>
    <ul>
        <li>Basic working version</li>
        <li>Not released</li>
    </ul>
</body>
</html>