###########################################################
###                                                      ##
###                                                      ##
###    Transforms Pack v1.0 RC30  (26-12-2021)           ##
###                                                      ##
###   https://forum.doom9.org/showthread.php?t=182825    ##
###   https://forum.doom9.org/showthread.php?t=182881    ##
###                                                      ##
###                             by Dogway (Jose Linares) ##
###                                                      ##
###########################################################
###
### Pack of tools for proper color managing AviSynth+.
### From function transforms like performant piecewise gamma functions,
### to color gamut converters and a list of building block functions
### for matrix operations.
###
### All of them converge in ConvertFormat(). A simple and accurate to use
### All-In-One (AIO) filter to scale, convert and transform colors.
###
### ConvertFormat() supports color space, color model, transfer function, color range,
### chroma placement and chroma subsampling conversion among other features
### like chroma reconstruction, 'no ring' scaling, luma space scaling, and no-moirée scaling.
###
### ConvertFormat() replaces my old filter LinearResizer() (Dither Tools based)
### and is clearly inspired by cretindesalpes' fmtconv and avsresize's z_ConvertFormat().
###
###
### Dependencies: AviSynth+ 3.7.1 test34 and over
###
####################################


function Display_Referred (clip clp, string "source", string "disp_ref", string "kernel", bool "gamut", bool "gamma", string "LUT", bool "tv_range", float "b", float "c", float "p") {

    rgb        = isRGB(clp)
    bi         = BitsPerComponent(clp)
    propIDs    = color_propGet(clp)
    fs         = !propIDs[6]

    gamut      = Default (gamut, true)        # convert gamut
    gamma      = Default (gamma, true)        # convert gamma
    source     = Default (source, propIDs[2]) # Source Color Space
    disp_ref   = Default (disp_ref,   "sRGB") # Display Referred Color Space
    kernel     = Default (kernel,  "Bicubic")
    LUT        = Default (LUT, Undefined())   # Display LUT (the path string of your monitor .cube 3D LUT, if calibrated)
    tv         = Default (tv_range, !fs )
    b          = Default (b, 0.00)
    c          = Default (c, 0.75)            # Precise Bicubic
    p          = Default (p, 0.25)

    Assert(IsVersionOrGreater(3,7,1), "Display_Referred: Update AviSynth+ version")

    bi < 32 ? clp.ConvertBits(16, fulls=fs) : clp

    src   = Color_Fuzzy_search (source)
    tgt   = Color_Fuzzy_search (disp_ref)
    s_gam = moncurve_coef (src[0]) # Primaries derived gamma
    t_gam = moncurve_coef (tgt[0])
    gamut = gamut && src[0] != tgt[0]

    rgb ? ConvertToPlanarRGB(src[0])                                       : \
          YUV_to_RGB(src[0], tv_range_in=tv, kernel=kernel, b=b, c=c, p=p)

    moncurve_f(s_gam[0], s_gam[1],tv,false)

    if (gamut) {
    mata = RGB_to_XYZ  (src[0],         list=true)
    matw = c_adaptation(src[0], tgt[0], list=true)
    matb = XYZ_to_RGB  (tgt[0],         list=true)
    MatrixClip( MatrixDot(MatrixDot(mata, matw), matb) ) }

    Defined(LUT) || gamma ? moncurve_r(t_gam[0], t_gam[1],false,false) : \
                    gamut ? moncurve_r(s_gam[0], s_gam[1],false,false) : last

    Defined(LUT) ? Cube(LUT, 4, true) : last

    ConvertBits(8, dither=1, fulls=false)  }



# Matches 'a' to 'b' clip format (size, length, color model, Jab, bitdepth)
function MatchClip (clip a, clip b, string "kernel", string "matrix", bool "props", bool "length", bool "fast") {

    krn    = Default (kernel, "Spline16")
    fst    = Default (fast,         true)
    fp     = Default (props,        true)
    mfc    = Default (length,      false) # Match also framecount

    YUY2   = b.IsYUY2()
    rgbb   = b.isRGB()             rgba    = a.isRGB()
    w      = b.width()             wa      = a.width()
    h      = b.height()            ha      = a.height()
    fc     = b.FrameCount()        fca     = a.FrameCount()
    p_type = b.PixelType()         p_typea = a.PixelType()
    bib    = b.BitsPerComponent()  bia     = a.BitsPerComponent()

    propIDs = color_propGet(b)

    fs      = propNumElements(a,"_ColorRange")  > 0 ? \
              propGetInt     (a,"_ColorRange") == 0 : rgba

    fd      = propIDs[6]

    isUHD   = (w  > 2599 ||  h  > 1499)
    isUHDa  = (wa > 2599 ||  ha > 1499)

    mat     = Default(matrix, propIDs[2])
    mat     = ReplaceStr(mat, "Rec", "")


        a
        yv411  = b.isYV411()      yv411a = a.isYV411()
        yv444  = b.is444()        yv444a = a.is444()
        !yv411 && bib > bia ? ConvertBits(bib, fulls=fs, fulld=fs) : last

    if (!fst) {

        ConvertFormat(w, h, fmt_in=p_typea, fmt_out=p_type, cs_in=mat, cs_out="", kernel=krn, tv_range_in=!fs, tv_range_out=!fd, fulls=fs, fulld=fd, show=false)

    } else {

        rgbp   = rgbb && b.isPlanar()
        isScl  = w != wa || h != ha
        mod    = rgba && rgbb || isy(a) && isy(b) ? 1 : 2

        fmt    = Format_fuzzy_search(b, p_type,  bib)
        fmta   = Format_fuzzy_search(a, p_typea, bia)
        bc     = bicubic_coeffs(krn)
        krn    = bc[1]>=0. ? "Bicubic" : krn

        cplace  = rgbb || yv444  || yv411  ? "MPEG1" : isUHD  ? "top_left" : "MPEG2"
        cplacea = rgba || yv444a || yv411a ? "MPEG1" : isUHDa ? "top_left" : "MPEG2"
        not42   = LeftStr(fmta[1],2) != "42"

        # Match dimensions
        isScl ? w > h ? RatioResize(w,mode="adjust2w",kernel=krn,mod=mod,b=bc[0],c=bc[1]) : \
                        RatioResize(h,mode="adjust2h",kernel=krn,mod=mod,b=bc[0],c=bc[1]) : last
                        PadResize(w,h,mode="dilate",             mod=mod)

        # ConvertBackToYUY2 bug: https://forum.doom9.org/showthread.php?p=1038027#post1038027
        isy(b) ? rgba ? DotClip([0.298903,0.586620,0.114477]) : ConvertToY(mat)                                                                                         : \
        rgbb   ? rgbp ? Eval(  "ConvertToPlanarRGB            (mat,interlaced=false"+(yv411a || rgba ? ")" : ",ChromaInPlacement=cplacea,       chromaresample=krn)"))  : \
                        Eval(  "ConvertTo"   +string(fmt[3])+"(mat,interlaced=false"+(yv411a || rgba ? ")" : ",ChromaInPlacement=cplacea,       chromaresample=krn)"))  : \
        yv411         ? Eval(  "ConvertToYV411                (false,mat,"          +(not42 ? ""   :        """ChromaInPlacement=cplacea, """)+"chromaresample=krn)")   : \
        YUY2  && rgba ? Eval("""ConvertBackToYUY2             (      mat                                                                                        """)    : \
                        Eval(  "ConvertToYUV"+string(fmt[1])+"(false,mat"           +(not42 ? ""   :         ",ChromaInPlacement=cplacea")+(yv444 ? ")" : ",chromaresample=krn, ChromaOutPlacement=cplace)"))
    }

    clr = !rgbb ? fd ? $008080 : $108080 : \
                  fd ? $000000 : $101010

    !yv411 ? bia > bib ? ConvertBits(bib, dither=1, fulls=fd, fulld=fd)          : \
                         ConvertBits(bib,           fulls=fd, fulld=fd)          : last
     mfc   ? fca > fc  ? Trim(last, fc-1) : last+BlankClip(b,fc-1,color_yuv=clr) : last

    # Planar to Interleaved
    YUY2 && !rgba  ? ConvertToYUY2()               : last

    # Frame Properties
    if (fst && fp) {
    ID = Color_Fuzzy_search(mat)
                PropCopy(b)
    fd !=  fs ? PropSet("_ColorRange", fd ? 1 : 0) : last # Overrides the Convertto props
                PropSet("_Matrix",          ID[1])        # Overrides the Convertto props
                PropSet("_Primaries",       ID[2]) } }    # Disable this line and above when convertto supports writing to RGB frameprops (currently RGB is hardcoded to _Matrix 0 and _Primaries 2 -undefined-)





###
### ConvertFormat()
###
###
### Similar to avsresize's z_ConvertFormat() but more flexible, more options and more features:
### More color models and color space conversions, chroma reconstruction, scale_space, noring, mod size, ratio resize, kernel/matrix aliases (supports any resizer), presets, show settings, etc
###
### Dependencies: AviSynth+ 3.7.1 and over
###               ExTools
###               GradePack  (for show=true and 'sigmoid' scaling)
###               MasksPack  (for show=true)
###               KNLMeansCL (for UVRecon=true)
###               nnedi3     (for UVRecon=true)
###               SysInfo    (for UVRecon=true)
###               Optional resizer plugins (check links)
###
### Example 1 - Limited YUV to full RGB:
###     ConvertFormat(1,1,"YUV","RGB")
###
### Example 2 - Scale HD Rec.709 YUV to SD Rec.601 YUV:
###     ConvertFormat(720,0) # 0 stands for automatic size given width/height ratio
###     or
###     ConvertFormat(preset="DVD-NTSC")
###
### Example 3 - YUV420 to YUV444 and scale up by 2 with chroma reconstruction and noring (cs_out to "" or "none" to skip color space autoconversion):
###     ConvertFormat(2,fmt_out="44",cs_out="",kernel="FSRCC",noring=true,UVRecon=true,cplace_in="MPEG2")
###
### Example 4 - Scale down by 2 with no moirée in sigmoid space:
###     ConvertFormat(0.5,scale_space="sigmoid",kernel="RobiSharp",nomoiree=true)
###
### Example 5 - Scale width to 1280 and height to half:
###     ConvertFormat(1280,0.5)
###
### Example 6 - Convert from YUV444 to YUV422 and TV range to PC range:
###     ConvertFormat(1,1,fmt_out="422",tv_range_out=false,cplace_out="MPEG2")
###
### Example 7: High quality JPEG decoding and conversion to RGB
###   MP_Pipeline("""
###   ### platform: win32
###   JPEGSource("source.jpg",rec=3)
###   ### ###
###   """)
###   ConvertBits(16)
###   Implicit:
###       ConvertFormat(1,1,"YUV","RGB","jpeg","sRGB",UVRecon=true)
###   Explicit:
###       ConvertFormat(1,1,"YUV","RGB","jpeg","sRGB",false,false,true,cplace_in="MPEG1",UVRecon=true)
###   ConvertBits(8, dither=1)
###
####################################


# List of Color Models:
# Color Models -not to be confused with Color Spaces- describe the geometry coordinates of the color gamut container and hence its relation (or correlation) with the other channels. They are typically designed or tailored to certain Color Spaces, but not necesarily bound to them like RGB or YCbCr which support many different Color Spaces and thus are nicked Color Absolute Models
#
# With *: Color Appearance Models (CAM) (Perceptually Uniform to various degrees)
# With +: HDR aware
# With -: Implemented
#
# CMYK         - Color model used in print industry
#-RGB+         - RGB color model for channels Red, Green, and Blue. Normally found in interleaved packing format. AviSynth works best with planar RGB so a conversion is first needed.
#-YCbCr        - Color format roughly based on human perception of luma and chroma contribution. Uses 3 planes for Luma, opposing blue-yellow, and opposing red-green.
#-YUVr         - "YUV RCT". Same as YUV but fully reversible to RGB
# sYUV         - "Sharp YUV". Same as YUV but luma-weighted chroma subsampling, retaining chroma fidelity.
#-YcCbcCrc     - YCbCr Constant Luminance (CL). Better decorrelation than YCbCr.
# xvYCC        - Expanded Gamut YCbCr. For newer TV systems it was/is a model that allowed the color gamut (typically Rec709) to be stored in the full range while luma in the narrow range.
#-OPP          -
#-YCoCg        - Better luma/chroma decorrelation and compression efficiency than YCbCr
#-YCoCgR       - Same as YCoCg but losslessly reversible to RGB
#-XYZ          -
#-YDzDx+       - HDR version of XYZ. Requires at least 10-bit for no visible quantization.
# YCxCz        - Color Space for image fidelity metrics. It's a first step space, you have to "filter" it and then convert to Lab to retrieve error delta.
# DCI XYZ      - XYZ space in DCI illuminant. In effect it's just a container for DCI-P3 in XYZ coordinates for delivery to theaters.
# Yxy/xyY      - Chroma normalized XYZ space which gives full luma/chroma decorrelation. Not apt for HDR.
#-HSV          - Cylindrical representation of RGB. Not recommended as it doesn't take into account human luminance perception
#-Duv*         -
# HunterLab*   - A more perceptually uniform version of CIELab
#-CIELab*      - Derived from CIEXYZ, one of the first approaches to a perceptually uniform color model. You can derive it's Delta E with the next equation: DE = (DL^2 + Da^2 + Db^2)/2  = ( (Ly-Lx)^2 + (ay-ax)^2 + (by-bx)^2)/2
# CIELch(ab)*  - HCL (polar coordinates or cylindrical) version of CIELab
# CIEsLab*     - CIE simple Lab
# R-Lab*       - Ruderman Lab space, using log luma and different weights for ab
#-CIELuv*      -
# CIELch(uv)*  - HCL (polar coordinates or cylindrical) version of CIELuv
# HSLuv*       - A cylindrical HSL type adaptation of CIELuv
# LogLuv*+     - HDR version of CIEluv, that uses log to encode HDR values in a 15-bit container
# Y''U''V''*+  - HDR version of CIEluv by Poynton. Improves on LogLuv by using a PQ transfer which just needs 12-bits
# CIEDuDv*+    - or YDuDv. HDR version of CIE Luv. Requires only 8-bit for no visible quantization.
# CIECAM97s*   -
# JzAzBz*+     - A uniform color space designed for HDR color.
# JzCzhz*+     - HCL (polar coordinates or cylindrical) version of JzAzBz
#-IPT*         - Intensity Protanope Tritanope. A more uniform color space in SDR colors. There's a version called hdrIPT
# ICaCb+       - Precursor and arguably better color model than ICtCp which based on this
# ICtCp+       - BT.2100 (HDR + Rec.2020) version of IPT. HDR version of YcCbcCrc but with Constant Intensity this time.
# ITP*+        - Perceptually uniform color space version of ICtCp, used extensively in error metrics by scaling Ct by 0.5. This transformation is the basis of the Rec.2124 wide gamut color difference metric D.itp (simple scaled Euclidean distance: 720*sqrt(Di^2+D(t*0.5)^2+Dp^2) )
# IPTPQc2*+    - Improved HDR10 version of ICtCp. Since it's a propietary space no much information is known.
# CIECAM02*    - Improves on CIECAM97s and can be made uniform with CAM02-UCS.
# CIECAM02Jch* -
# OSA*         -
# CAM16*       - Not yet a CIE standard. Improves on CIECAM02 and can be made uniform with CAM16-UCS, which works "out-of-the-box" for euclidean distance metrics.
#-Oklab*       - An uniform (UCS) space for SDR color. Simple to compute yet powerful. Takes CAM16 lightness and chroma, and IPT for hue.
#-OkLch*       - The cylindrical form of Oklab
# iCAM         - An image (not only color) appearance metric model to not only compute perceived difference in lightness, hue or chroma, but also contrast, sharpness or graininess. Involves converting to IPT, low-pass filtering in linear space, convert to non-linearity, then to Jch model and QM if necessary for the metrics.


# Resizer Plugins:
#
# SimpleResize (2 tap lin) (8-bit)            (dw) https://avisynth.nl/index.php/SimpleResize (same than Area and ~SSIM but without pixel centering, very fast)
# Box/Area Average                            (dw) https://github.com/EleonoreMizo/fmtconv
# SSIM                                        (dw) https://github.com/mysteryx93/AviSynthShader/releases
# DPID                                        (dw) https://github.com/Asd-g/AviSynth-DPID
# SincLin2ResizeMT                            (up) https://github.com/jpsdr/ResampleMT/releases (like a sharper lanczos)
# Spline100/Spline144                         (up) https://github.com/EleonoreMizo/fmtconv
# SinPowResizeMT                              (dw) https://github.com/jpsdr/ResampleMT/releases
# Jinc (EWA Lanczos)                          (up) https://github.com/Asd-g/AviSynth-JincResize/releases
# FCBI (Fast Curve Based Interp) (8-bit)      (up) https://github.com/chikuzen/FCBI/releases
# SuperResXBR                                 (up) https://github.com/mysteryx93/AviSynthShader/releases
# AiUpscale/FSRCNN (FastSuperResolutionConvo) (up) https://github.com/Alexkral/AviSynthAiUpscale/tree/master/Shaders (lineart / photo folders)
# KrigBilateral                               (up) https://github.com/Alexkral/AviSynthAiUpscale/tree/master/Shaders/KrigBilateral

# Internal:
# Point / Nearest       (actually slower than bicubic!)
# Bilinear / Triangular
# Bicubic / Cubic
# Spline / Cubic Polynomials
# Sinc     is a box-windowed      sinc filter (2 lobes).
# Lanczos  is a Lanczos-windowed  sinc filter (3 lobes).
# Blackman is a Blackman-windowed sinc filter (3 lobes). (improved lanczos with less ringing)

# Missing. ref: https://github.com/mpv-player/mpv/blob/master/video/out/filter_kernels.c
#          ref: https://artoriuz.github.io/blog/mpv_upscaling.html
# Bartlett          is a Bartlett-windowed sinc filter (3 lobes).
# Hann(ing)         is a Hanning-windowed  sinc filter (3 lobes).
# Hamming           is a Hamming-windowed  sinc filter (3 lobes).
# Welch             is a Welch-windowed    sinc filter (parabolic window, 3 lobes).
# Cosine            is a Cosine-windowed   sinc filter (3 lobes).
# Bessel            is a unnormalized      sinc filter (3 lobes).
# Ginseng           is a Jinc-windowed     sinc filter (3 lobes).
# Jinc              is a Box-windowed      jinc filter (3 lobes). Not separable so usually slower than sinc, cubic, etc
# ewa_hanning       is a Hanning-windowed  jinc filter (3 lobes).
# ewa_ginseng       is a sinc-windowed     jinc filter (3 lobes).
# -ewa_lanczos      is a lanczos-windowed  jinc filter (3 lobes).
# -ewa_lanczossharp is a lanczos-windowed  jinc filter (3.238 lobes). Slightly sharpened as per calculations by Nicolas Robidoux. 3.2383154841662362, jinc, .blur = 0.9812505644269356
# -ewa_lanczossoft  is a lanczos-windowed  jinc filter (3.238 lobes). Softened instead. This one makes hash patterns disappear completely. 3.2383154841662362, jinc, .blur = 1.015
# -Haasnsoft        is a Hanning-windowed  jinc filter (3.238 lobes). Removes almost all aliasing. Blur value to match orthogonal and diagonal contributions. 3.2383154841662362, jinc, .blur = 1.11
# Tukey             is a Hanning-windowed  jinc filter taper = 0.5
# Quadratic/Quadric like Cubic but 66% faster (2 taps/lobes?)
# RAVU / RAISR      similar to XBR and nnedi3
# NGU               Next Generation Upscaler. madVR edge directed NN algo (closed source, similar to FSRCNN)
# Sphinx            Continuation of Sinc and Jinc. interpolating all three dimensions at the same time using a carefully constructed filter that has a perfectly spherical frequency response. 1.4302966531242027, sphinx window.
# ICBI              (Iterative Curve Based Interpolation) is a single image superresolution technique described in Fast artifact-free image interpolation by Andrea Giachetti and Nicola Asuni, presented at BMVC 2008

function ConvertFormat (clip clp, val "width", val    "height", string   "fmt_in", string  "fmt_out", string   "cs_in", string   "cs_out", string      "OETF", string   "EOTF", string "D_in", string "D_out", bool "tv_in", bool "tv_out", string "cplace_in", string "cplace_out", \
                         string "scale_space", string "kernel", string "kernel_c", float  "src_left", float  "src_top", float "src_width", float "src_height",                                                                                                                       \
                                 float    "p", int       "mod", bool   "nomoiree", bool     "noring", bool   "UVrecon", bool     "show") {

    clp
    wu         = !Defined(width)
    hu         = !Defined(height)
    w          = width ()
    h          = height()
    fc         = FrameCount() < 2
    p_type     = PixelType()
    bdpth      = BitsPerComponent()
    lut1       = bdpth == 32 ? 0 : 1
    lut2       = bdpth  < 16 ? 2 : 0
    propIDs    = color_propGet()


    nw         = Default (width,   1)             # 0.0 to 10.0 is a multiplier. 12 to inf is absolute target width
    nh         = Default (height, nw)             # 0.0 to 10.0 is a multiplier. 12 to inf is absolute target height
    i_fmt      = Format_fuzzy_search (Default (fmt_in,  p_type), bdpth)
    o_fmt      = Format_fuzzy_search (Default (fmt_out, p_type), bdpth)
    isRGBi     = i_fmt[0]=="RGB"
    isRGBo     = o_fmt[0]=="RGB"

    isRGBi ? ConvertToPlanarRGB() : last

    mod        = Default (mod, isRGBo ? 1 : 2) # mod size for resizing. ie: 1, 2, 4, 8, 16...

    Assert(isFloat(nw) || isFloat(nh), "ConvertFormat: Width/Height type not supported.") # isFloat(int) also returns true, so good for 'number' type evaluation
    nw         = isInt(nw) && nw<=10 ? float(nw) : isFloat(nw) && nw>10. ? int(nw) : nw
    nh         = isInt(nh) && nh<=10 ? float(nh) : isFloat(nh) && nh>10. ? int(nh) : nh
    nw         =  nw<=10. ? w*nw : nw            nw     = round(nw/mod)*mod
    nh         =  nh<=10. ? h*nh : nh            nh     = round(nh/mod)*mod

    nw         =  nw == 0 || wu ? round((w*(nh/float(h)))/mod)*mod : nw
    nh         =  nh == 0 || hu ? round((h*(nw/float(w)))/mod)*mod : nh

    isUHD      = ( w > 2599 ||   h > 1499)     isnUHD = (nw > 2599 ||  nh > 1499)
    isHD       = ( w > 1099 ||   h > 599 )     isnHD  = (nw > 1099 ||  nh > 599 )

    wr         = float(nw) / w                 hr     = float(nh) / h     # for nomoiree
    rat        = max(abs(wr - 1),abs(hr - 1)) == abs(wr - 1) ? wr : hr    # for nomoiree

    # DEFAULTS
    Und        = Undefined()
       cs_in_d = Defined (cs_in)
      cs_out_d = Defined (cs_out)
    cs_in      = Default (cs_in_d  ? cs_in ==""  ? Und   : cs_in : cs_in,                          fc ? "jpeg" : propIDs[2])
       cs_inFA = Color_Fuzzy_search (cs_in)
       cs_inF  = cs_inFA[0]
    cs_out     = Default (cs_out_d ? cs_out =="" ? cs_in : cs_out : cs_out, cs_in_d ? cs_in : (cs_in == "jpeg" || cs_in == "jpg" || cs_inF == "sRGB") && isRGBo ? "sRGB" : isnUHD ? "2020" : isnHD ? "709" : "601")
      cs_outFA = Color_Fuzzy_search (cs_out)
      cs_outF  = cs_outFA[0]
    OETF       = Default (Defined(OETF) ? OETF =="" ? Und  : OETF : OETF,  cs_in_d  ? cs_in ==""  ? propIDs[5] : cs_in : propIDs[5])
    EOTF       = Default (Defined(EOTF) ? EOTF =="" ? OETF : EOTF : EOTF,  cs_out) # By default derived from space.
          OETF = Color_Fuzzy_search (OETF)[0]
          EOTF = Color_Fuzzy_search (EOTF)[0]
       tv_in_d = Defined (tv_in)
    tv_in      = Default (tv_in,                    !(isRGBi || cs_inF =="sRGB" || cs_in =="jpeg" || cs_in =="jpg") && propIDs[6] )
    tv_out     = Default (tv_out, tv_in_d ? tv_in : !(isRGBo || cs_outF=="sRGB" || cs_out=="jpeg" || cs_out=="jpg") )
    kernel     = Default (kernel,   (w>nw||h>nh)?"Didee":"Precise")
    kernel_c   = Default (kernel_c, kernel)
    space      = Default (scale_space, "gamma")  # resizing space: "gamma", "linear", "sigmoid" or "log" for quasi-log. Assumes gamma encoded input.
    cplace_in  = Default (cplace_in,   "")       # Assumes default from format
    cplace_out = Default (cplace_out,  "")       # Assumes default from format
    D_in       = Default (Defined(D_in)  ? D_in  =="" ? Und  : D_in  : D_in , cs_in_d  ? cs_in ==""  ? propIDs[2] : cs_in : propIDs[2])
    D_out      = Default (Defined(D_out) ? D_out =="" ? D_in : D_out : D_out, D_in) # By default same as input, change based on space?
        D_in   = Color_Fuzzy_search (D_in )[0]
        D_outA = Color_Fuzzy_search (D_out)
        D_out  = D_outA[0]
    p          = Default (p,          9)
    src_left   = Default (src_left, 0.0)
    src_top    = Default (src_top,  0.0)
    src_width  = Default (src_width,  w)
    src_height = Default (src_height, h)
    noring     = Default (noring,  false)
    nomoir     = Default (nomoiree,false)
    recon      = Default (UVrecon, false)
    fs         = !tv_in  # needs to be reassesed in the pipeline
    dg         = Default (show,    false)


#    PRESETS
#                                DoVi/DVp5/DVp7     PQ10/UHD       HLG10         HD    DVD-NTSC    DVD-PAL        DV    CRT-NTSC    CRT-PAL     Master     Archival      Grade     Theater    JPEG2000    JPG_old      JPG
#    fmt_out       = Select (num,     "IPTPQc2",     "YCbCr",    "YCbCr",   "YCbCr",    "YCbCr",   "YCbCr",  "YCbCr",     "YIQ",     "YUV",     "RGB",       "RGB",      "RGB",     "YUVr",     "YUVr",  "YCbCr",   "sYCC") # sYCC is basically sRGB (prims, transfer, range) over YCbCr, but uses true Rec709 derived matrix coeffs, not from 470M
#    prims         = Select (num,        "2020",      "2020",     "2020",     "709",     "170M",   "470BG",        4,    "170M",   "470BG",  "DCIXYZ",       "AP0",      "AP1",   "DCIXYZ",     "sRGB",   "170M",   "sRGB")
#    Jab           = Select (num,         "420",       "420",      "420",     "420",      "420",     "420",    "410",     "411",     "411",     "444",       "444",      "444",      "444",      "444",    "420",    "422")
#    tv_out        = Select (num,         false,        true,       true,      true,       true,      true,    false,      true,      true,     false,       false,      false,      false,      false,    false,    false)
#    cplace_out    = Select (num,    "top_left",  "top_left", "top_left",   "MPEG2",    "MPEG2",   "MPEG2",     "DV",   "MPEG1",   "MPEG1",        "",          "",         "",         "",         "",  "MPEG1",  "MPEG1")
#    D_out         = Select (num,         "D65",       "D65",      "D65",     "D65",      "D65",     "D65",        4,     "601",     "601",       "E",       "D60",      "D60",        "E",      "D65",    "D65",    "D65")
#    EOTF          = Select (num,          "PQ",        "PQ",      "HLG",    "1886",     "170M",     "470",        4,    "170M",    "170M",     "DCI",    "linear",  "ACESCCt",      "DCI",     "sRGB",   "170M",   "sRGB")
#    PAR           = Select (num,             1,           1,          1,         1,      "601",     "470",        4,     "601",     "601",         1,           1,          1,          1,          1,        1,        1)
#    cdc           = Select (num,        "H265",      "H265",     "H265",    "H264",     "H262",    "H262",   "H261",        "",        "",    "TIFF",       "PIZ",      "PIZ","MJPEG2000", "JPEG2000",    "JPG",    "JPG")
#    cont          = Select (num,          "TS",        "TS",       "TS",      "TS",      "VOB",     "VOB",  "MPEG2",        "",        "",    "TIFF",       "EXR",      "EXR",      "mj2",      "jp2",    "JPG",    "JPG")
#    bit           = Select (num,            12,          10,         10,         8,          8,         8,        8,        "",        "",        16,          16,         32,         12,          8,        8,        8)



    ############ Data extraction and normalization + Asserts ############

                 Assert(IsVersionOrGreater(3,7,1), "ConvertFormat: Update AviSynth+ version")
    !(space=="sigmoid" || space=="gamma" || space=="linear" || space=="log") ? \
                 Assert(false, "ConvertFormat: Invalid space type.")         : nop()


    cs_in    = cs_inF
    cs_out   = cs_outF
    space    = space  != "" && space  != "none" ? space : "gamma"

    isGamma  = OETF      !=  EOTF
    isSpace  = cs_in     !=  cs_out
    isFrmt   = i_fmt[0]  !=  o_fmt[0]
    isIllu   = D_in      !=  D_out
    isScale  = nw!=w     ||  nh!=h
    isJab    = i_fmt[1]  !=  o_fmt[1]
    isChP    = cplace_in != cplace_out

    coef_i   =           Matrix_coef(cs_in)
    coef_o   = isSpace ? Matrix_coef(cs_out) : coef_i
    s_gam    =           moncurve_coef (OETF)
    t_gam    = isGamma ? moncurve_coef (EOTF) : s_gam
    kernel   = kernel == "Bilcubic" ? w*h < nw*nh ? "BilcubicU" : "BilcubicD" : kernel
    bc       = bicubic_coeffs(kernel)
    bc_b     = bc[1]>=0.?bc[0]:1/3.
    bc_c     = bc[1]>=0.?bc[1]:1/3.
    kernel   = bc[1]>=0. ? "Bicubic" : kernel

    i_type4  = i_fmt[1] == "444"         o_type4  = o_fmt[1] == "444"
    i_type2  = i_fmt[1] == "422"         o_type2  = o_fmt[1] == "422"
    i_type1  = i_fmt[1] == "411"         o_type1  = o_fmt[1] == "411"
    i_type10 = i_fmt[1] == "410"         o_type10 = o_fmt[1] == "410"

    cow      = i_type4 ?  w : i_type1 || i_type10 ? round( w/4.0) : round( w/2.0)
    coh      = i_type4 ||     i_type1 || i_type2  ?             h : round( h/2.0)
    cnw      = o_type4 ? nw : o_type1 || o_type10 ? round(nw/4.0) : round(nw/2.0)
    cnh      = o_type4 ||     o_type1 || o_type2  ?            nh : round(nh/2.0)

     i_type1  || o_type1        ? Assert(bdpth == 8, "ConvertFormat: Unsupported Pixel Type: HBD YUV411")          : nop()
     i_type10 || o_type10       ? Assert(false,      "ConvertFormat: Unsupported Pixel Type: YUV410")              : nop()
     !isRGBi                    ? Assert( h%2==0,    "ConvertFormat: Clip Height is not mod2" )                    : nop()
     i_type2||i_fmt[1]=="420"   ? Assert( w%2==0,    "ConvertFormat: Clip Width is not mod2" )                     : nop()
     i_type1                    ? Assert( w%4==0,    "ConvertFormat: Clip Width is not mod4" )                     : nop()
     o_type1                    ? Assert(nw%4==0,    "ConvertFormat: Target Width is not mod4" )                   : nop()
    !(isRGBo ||  o_type4 || (cnw>cow || cnh>coh))                                                                  ? \
                                  Assert(!recon,     "ConvertFormat: Invalid settings for chroma reconstruction.") : nop()


    resampler = Format( kernel == "nnedi3"       ?"nnedi3_resize16({nw},{nh}"                                : \
                        kernel == "Bicubic"      ?  "BicubicResize({nw},{nh},b={bc_b},c={bc_c}"              : \
                        kernel == "Spline100"    ? """fmtc_resample({nw},{nh},kernel="Spline",taps=5"""      : \
                        kernel == "Spline144"    ? """fmtc_resample({nw},{nh},kernel="Spline",taps=6"""      : \
                        kernel == "SincLin"      || kernel == "SincLin2ResizeMT"                             ? \
                                                 "SincLin2ResizeMT({nw},{nh},taps=16"                        : \
                        kernel == "SinPow"      || kernel == "SinPowResizeMT"                                ? \
                                                 "SinPowResizeMT({nw},{nh}"                                  : \
                        kernel == "ResizeShader" || kernel == "SSIM"                                         ? \
                                                   """ResizeShader({nw},{nh},kernel="SSIM",b=0.1"""          : \
                        kernel == "Gauss"        ?    "GaussResize({nw},{nh},p=p"                            : \
                        kernel == "Nearest" || kernel == "NearestNeighbour" || kernel == "NN"                ? \
                                                      "GaussResize({nw},{nh},p=100"                          : \
                        kernel == "Average"      || kernel == "Box"       || kernel == "Area"                ? \
                                                     """fmtc_resample({nw},{nh},kernel="box" """             : \
                        kernel == "Sinc"         ?     "SincResize({nw},{nh},taps=2"                         : \
                        kernel == "DPID"         ?     "DPID({nw},{nh}"                                      : \
                        kernel == "EWA"          || kernel == "Jinc"      || kernel == "ewa_lanczos"         ? \
                                                       "JincResize({nw},{nh},tap=3"                          : \
                        kernel == "EWASharp"     || kernel == "JincSharp" || kernel == "ewa_lanczossharp"    ? \
                                                       "JincResize({nw},{nh},tap=3,blur=0.9812505644269356"  : \
                        kernel == "EWASoft"      || kernel == "JincSoft"  || kernel == "ewa_lanczossoft"     ? \
                                                       "JincResize({nw},{nh},tap=3,blur=1.015"               : \
                        kernel == "Haasn"        || kernel == "HaasnSoft" || kernel == "ewa_haasn"           ? \
                                                       "JincResize({nw},{nh},tap=3,blur=1.11"                : \
                        kernel == "FCBI"         ? "FCBI().BicubicResize({nw},{nh},b=-0.5,c=0.25"            : \
                        kernel == "SuperResXBR"  || kernel == "XBR"                                          ? \
                                                         "SuperResXBR(factor=2)."                              \
                                                   +"BicubicResize({nw},{nh},b=-0.5,c=0.25"                  : \
                        kernel == "Krig"         || kernel == "KrigBilateral"                                ? \
                                    "KrigBilateral().BicubicResize({nw},{nh},b=-0.5,c=0.25"                  : \
                        kernel == "FSRCC"        || kernel == "AiUpscale"                                    ? \
                                             """AiUpscale(2,Luma="Medium",Chroma="Spline36",Mode="Photo")."""  \
                                                   +"BicubicResize({nw},{nh},b=-0.5,c=0.25"                  : \
                        kernel +                           "Resize({nw},{nh}"                                 )


    src_nul = kernel == "ResizeShader" || kernel == "SSIM"
    src_box = kernel == "Average" || kernel == "Box" || kernel == "Area" || kernel == "Spline100" || kernel == "Spline144"
    src_wh  = src_box ? Format(",sw={src_width},sh={src_height}") : Format(",src_width={src_width},src_height={src_height}")
    src_whc = src_box ? Format(",sw={cow},     sh={coh}")         : Format(",src_width={cow},      src_height={coh}")
    fmtcb   = Format(".ConvertBits({bdpth},fulls={fs})")
    src_nr  = Format(",src_left={src_left},src_top={src_top}"+src_wh+")") # take into account cplace
    src_c   = src_nul ? "" : src_box ? Format(",sx={src_left},sy={src_top}"+src_wh+")"+fmtcb) : src_nr # take into account cplace
    Ynr     = Format(".Repair(BicubicResize(Y,{nw},{nh},0,0"+src_nr+",1)")  # noring uses Hermite kernel. Check here if I need -1 for chroma

    cplace  = chroma_placement(w, h, nw, nh, cs_in, cs_out, i_fmt[0], o_fmt[0], i_fmt[1], o_fmt[1], cplace_in, cplace_out )


    cplaceY  = (src_nul ? ""     : ",src_left=" +string(src_left)+",src_top="+string(src_top) + src_wh ) + ")" + fmtcb
    point    = kernel=="Point" ? "+1.0" : ""
    c_point  = kernel=="Point" ? i_type4 ?  1.0 : i_type1 || i_type10 ? round( 1*4.0) : round( 1*2.0) : 0
    c_point  = c_point *(float(cow)/cnw)  # chroma scaled
    src_left = i_type4 ?  src_left : i_type1 || i_type10 ? round( src_left*4.0) : round( src_left*2.0)
    src_left = src_left*(float(cow)/cnw)  # chroma scaled
    src_top  = i_type4 || i_type1 || i_type2  ? src_top  : round( src_top *2.0)
    src_top  = src_top *(float(coh)/cnh)  # chroma scaled

    cplaceH  = (src_box ? ",sx=" : ",src_left=")+string(cplace[0]+src_left+c_point)
    cplaceV  = (src_box ? ",sy=" :  ",src_top=")+string(cplace[1]+src_top)
    cplaceC  = (src_nul ? "" : (cplaceH + cplaceV + src_whc)) + ")" + fmtcb


    c_kernel = InternalFunctionExists(kernel+"resize") || FindStr(LCase(kernel), "nearest") > 0 ? kernel : "bicubic"
    c_recon  = """threads = SI_LogicalCores()
                  cores   = SI_PhysicalCores()
                  c_cplace= chroma_placement(w*2, h*2, fcnw, fcnh, cs_in, cs_out, i_fmt[0], o_fmt[0], i_fmt[1], o_fmt[1], cplace_in, cplace_out )
                  ref     =   Y.KNLMeansCL(0, 16, 0, pow(1.464968620512209618455732713658, 6.4), "auto", wref=1)
                  Luma    = ref.ConvertBits(8,dither=-1,fulls=fs).nnedi3_rpow2(rfactor=2, nns=1, qual=1, etype=1, nsize=0, threads=cores, prefetch=(threads+cores)/2).ConvertBits(bi,fulls=fs)
                  Uu      =  Cb.ConvertBits(8,dither=-1,fulls=fs).nnedi3_rpow2(rfactor=2, nns=1, qual=1, etype=1, nsize=0, threads=cores, prefetch=(threads+cores)/2, fwidth=w*2, fheight=h*2, ep0=bc_b, ep1=bc_c, cshift=kernel+"resize", cresize=true, mpeg2=cplace_in=="MPEG2").ConvertBits(bi,fulls=fs)
                  Vu      =  Cr.ConvertBits(8,dither=-1,fulls=fs).nnedi3_rpow2(rfactor=2, nns=1, qual=1, etype=1, nsize=0, threads=cores, prefetch=(threads+cores)/2, fwidth=w*2, fheight=h*2, ep0=bc_b, ep1=bc_c, cshift=kernel+"resize", cresize=true, mpeg2=cplace_in=="MPEG2").ConvertBits(bi,fulls=fs)
                  Unew    = Uu.KNLMeansCL(0, 16, 0, 6.4, "auto", wref=0, rclip=Luma).BicubicResize(fcnw, fcnh, b=-0.5, c=0.25, src_left=c_cplace[0]+src_left, src_top=c_cplace[1]+src_top)
                  Vnew    = Vu.KNLMeansCL(0, 16, 0, 6.4, "auto", wref=0, rclip=Luma).BicubicResize(fcnw, fcnh, b=-0.5, c=0.25, src_left=c_cplace[0]+src_left, src_top=c_cplace[1]+src_top)
                  Cb      = ex_makeadddiff(Unew, Removegrain(Unew, 19), Uu.BicubicResize(fcnw, fcnh, b=-0.5, c=0.25, src_left=c_cplace[0]+src_left, src_top=c_cplace[1]+src_top))
                  Cr      = ex_makeadddiff(Vnew, Removegrain(Vnew, 19), Vu.BicubicResize(fcnw, fcnh, b=-0.5, c=0.25, src_left=c_cplace[0]+src_left, src_top=c_cplace[1]+src_top))"""




    # Only scaling (or change in range, or gamma, or chroma placement, or subpixel shift, or odd cropping)
    if (!isSpace && !isIllu && !isFrmt && !isJab) {

        UVr = isRGBi ? 3 : 1
        space == "linear"  ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, UVr)                                     : \
        space == "sigmoid" ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, UVr).ex_contrast(-1.15,0,191,false,UVr)  : \
        space == "log"     ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, UVr).ACEScct_f(UV=UVr)                   : \
                   isGamma ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, UVr)                                     : last

        if (isRGBi && !recon) {

            nomoir ? ex_blur((1. / rat) / 2., mode="gaussian") : last
            Ynr   = ReplaceStr(Ynr, "(Y,", "(")
            Eval("" + resampler + cplaceY + (noring ? Ynr : ""))

        } else {

            Y   = ExtractY()
            Cb  = ExtractU()
            Cr  = ExtractV()

            if (recon) {

                Eval(ReplaceStr(c_recon, "fcn", "cn"))

            } else {

                str  = ReplaceStr(ReplaceStr(resampler, "("+string(nw), "("+string(cnw)), ","+string(nh), ","+string(cnh))
                str  = (cnw==cow && cnh==coh) ? Format("PointResize({cnw},{cnh}") : str # if chroma is not scaled (or scaled down to original) then use point as its faster and lossless
                Cb   = Eval("Cb." + str + cplaceC)
                Cr   = Eval("Cr." + str + cplaceC)
            }

            Ynr  = ReplaceStr(Ynr, "(Y,", "(")
            Y    = nomoir ? Y.ex_blur((1. / rat) / 2., mode="gaussian") : Y
            Y    = Eval("Y." + resampler + cplaceY + (noring ? Ynr : ""))


            CombinePlanes(Y, Cb, Cr, planes="YUV", pixel_type="YUV"+i_fmt[1]+i_fmt[2])
        }

        space == "linear"  ?                                   moncurve_r(t_gam[0], t_gam[1], false, tv_out, UVr) : \
        space == "sigmoid" ? ex_contrast(1.15,0,191,false,UVr).moncurve_r(t_gam[0], t_gam[1], false, tv_out, UVr) : \
        space == "log"     ? ACEScct_r(UV=UVr).                moncurve_r(t_gam[0], t_gam[1], false, tv_out, UVr) : \
                   isGamma ?                                   moncurve_r(t_gam[0], t_gam[1], false, tv_out, UVr) : last

        tv_in != tv_out ? space == "gamma"    ?     SMPTE_legal(tv_out,3,  3) : \
                          isScale && !isRGBi  ?     SMPTE_legal(tv_out,1,  3) : \
                         !isScale && !isGamma ? clp.SMPTE_legal(tv_out,UVr,3) : last : last

    } else {

        if (!isRGBi) {


        if (isScale && (isRGBo || !isSpace && !isIllu)) {

            space == "linear"  ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, 1)                                  : \
            space == "sigmoid" ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, 1).ex_contrast(-1.15,0,191,false,1) : \
            space == "log"     ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, 1).ACEScct_f(UV=1)                  : \
                                 last
        }

        Y   = ExtractY()
        Cb  = ExtractU()
        Cr  = ExtractV()

        fcnw = (isSpace || isIllu) && !isRGBo ? w : cnw
        fcnh = (isSpace || isIllu) && !isRGBo ? h : cnh


        if (recon && !i_type4) {

            Eval(c_recon)

        } else {

            str  = ReplaceStr(ReplaceStr(resampler, "("+string(nw), "("+string(fcnw)), ","+string(nh), ","+string(fcnh))
            str  = (fcnw==cow && fcnh==coh) ? Format("PointResize({fcnw},{fcnh}") : str # if chroma is not scaled (or scaled down to original) then use point as its faster and lossless
            Cb   = Eval("Cb." + str + cplaceC)
            Cr   = Eval("Cr." + str + cplaceC)
            }


        if (isScale && (isRGBo || !isSpace && !isIllu)) {

            Y     = nomoir ? Y.ex_blur((1. / rat) / 2., mode="gaussian") : Y
            Y     = Eval("Y." + resampler + src_c + (noring ? Ynr : ""))
            Y     = space == "linear"                  ? Y.                                moncurve_r(s_gam[0], s_gam[1], false, !(isRGBo || !tv_out), 1) : \
                    space == "sigmoid"                 ? Y.ex_contrast(1.15,0,191,false,1).moncurve_r(s_gam[0], s_gam[1], false, !(isRGBo || !tv_out), 1) : \
                    space == "log"                     ? Y.ACEScct_r(UV=1).                moncurve_r(s_gam[0], s_gam[1], false, !(isRGBo || !tv_out), 1) : \
                                                         Y
            }


        if (!isRGBo && !isSpace && !isIllu) {

            CombinePlanes(Y, Cb, Cr, planes="YUV", pixel_type="YUV"+o_fmt[1]+o_fmt[2])
            tv_in != tv_out ? space == "gamma" ? SMPTE_legal(tv_out,3,  3) : \
                              isScale          ? SMPTE_legal(tv_out,1,  3) : \
                             !isScale          ? SMPTE_legal(tv_out,UVr,3) : last : last
            }


        if (isRGBo || isSpace || isIllu) {

            if (i_fmt[0]=="YcCbcCrc" || cs_in == "Rec2020CL") {

                RGB = YcCbcCrc_to_RGB( Y, Cb, Cr, cs_in, coef_i, !(isScale || !tv_in), !(isSpace || !tv_out), fs)

                R = RGB[0]  G = RGB[1]  B = RGB[2]

            } else if (i_fmt[0]=="YCoCg") {

            } else if (i_fmt[0]=="YCoCgR") {

            } else if (i_fmt[0]=="YUVr") {

            } else if (i_fmt[0]=="OkLab") {

            } else if (i_fmt[0]=="HSV") {

            } else if (i_fmt[0]=="OPP") {

            } else if (i_fmt[0]=="ICtCp") {

            } else if (i_fmt[0]=="YCbCr") {

                scale_y   = tv_in && (isSpace || isIllu || !tv_out) ? (255 / 219.) : !tv_in && !(isSpace || isIllu || !tv_out) ? (219 / 255.) : 1.0
                scale_uv  = tv_in && (isSpace || isIllu || !tv_out) ? (255 / 112.) : !tv_in && !(isSpace || isIllu || !tv_out) ? (224 / 128.) : 2.0

                Kr = 1. - coef_i[0]
                Kb = 1. - coef_i[2]

                m0 = scale_y     m1 = 0.0                                       m2 = scale_uv * Kr
                m3 = scale_y     m4 = scale_uv * ( -Kb * coef_i[2] / coef_i[1]) m5 = scale_uv * ( -Kr * coef_i[0] / coef_i[1])
                m6 = scale_y     m7 = scale_uv * Kb                             m8 = 0.0

                range_PC = scale_y == 255/219. ? "ymin - " : ""
                range_TV = scale_y == 219/255. ? "ymin + " : ""
                UVf      = bdpth < 32          ? "range_half - " : ""

                R = Expr(Y,     Cr, ex_dlut("x "+range_PC+" "+string(m0)+" * "+range_TV+"                            y "+UVf + string(m2)+" * + ", bdpth, !tv_in), optSingleMode=false, lut=lut2)
                G = Expr(Y, Cb, Cr, ex_dlut("x "+range_PC+" "+string(m0)+" * "+range_TV+" y "+UVf + string(m4)+" * + z "+UVf + string(m5)+" * + ", bdpth, !tv_in), optSingleMode=true , lut=   0)
                B = Expr(Y, Cb,     ex_dlut("x "+range_PC+" "+string(m0)+" * "+range_TV+" y "+UVf + string(m7)+" * +                            ", bdpth, !tv_in), optSingleMode=false, lut=lut2)

            }

        !isSpace && !isIllu ? CombinePlanes(R, G, B, planes="RGB", pixel_type=o_fmt[3]+o_fmt[2]) : last } }

    if (isRGBi) {

        isSpace || isIllu || isGamma ? moncurve_f(s_gam[0], s_gam[1], tv_in, false, 3) : last
        R = ExtractR()
        G = ExtractG()
        B = ExtractB()

    } else if (isSpace || isIllu || isGamma) {

        R = R.moncurve_f(s_gam[0], s_gam[1], false, false, 1)
        G = G.moncurve_f(s_gam[0], s_gam[1], false, false, 1)
        B = B.moncurve_f(s_gam[0], s_gam[1], false, false, 1)
     }

    if (isSpace || isIllu || isGamma) {

        mata = RGB_to_XYZ  (cs_in,         list=true)
        matw = c_adaptation(D_in, D_out,   list=true)
        matb = XYZ_to_RGB  (cs_out,        list=true)
        mat  = MatrixDot(MatrixDot(mata, matw), matb)

        Ro = "x "+string(mat[0])+" * y "+string(mat[3])+" * + z "+string(mat[6])+" * +"
        Go = "x "+string(mat[1])+" * y "+string(mat[4])+" * + z "+string(mat[7])+" * +"
        Bo = "x "+string(mat[2])+" * y "+string(mat[5])+" * + z "+string(mat[8])+" * +"

        if (!isRGBo) {
        Ro = Expr(R, G, B, Ro, optSingleMode=true)
        Go = Expr(R, G, B, Go, optSingleMode=true)
        Bo = Expr(R, G, B, Bo, optSingleMode=true)
        R = Ro  G = Go  B = Bo
        } else { Expr(R, G, B, Ro, Go, Bo, Format=o_fmt[3]+o_fmt[2], optSingleMode=true) }


    if (isRGBi && isRGBo && isScale) {


        RGB  = space == "linear"  ? isSpace || isIllu || isGamma ?                             last : moncurve_f(s_gam[0], s_gam[1], false, false, 3)                                    : \
               space == "sigmoid" ? isSpace || isIllu || isGamma ? ex_contrast(-1.15,0,191,false,3) : moncurve_f(s_gam[0], s_gam[1], false, false, 3).ex_contrast(-1.15,0,191,false,3)   : \
               space == "log"     ? isSpace || isIllu || isGamma ? ACEScct_f(UV=3)                  : moncurve_f(s_gam[0], s_gam[1], false, false, 3).ACEScct_f(UV=3)                    : \
               isSpace || isIllu  ?                                                                   moncurve_r(t_gam[0], t_gam[1], false, tv_out, 3)                                   : \
                                    last

        RGB   = nomoir ? RGB.ex_blur((1. / rat) / 2.,mode="gaussian") : RGB
        RGBnr = ReplaceStr(Ynr, "(Y,", "(RGB,")
        RGB   = Eval("RGB." + resampler + src_c + (noring ? RGBnr : ""))

               space == "linear"  ? RGB.                                moncurve_r(t_gam[0], t_gam[1], false, tv_out, 3) : \
               space == "sigmoid" ? RGB.ex_contrast(1.15,0,191,false,3).moncurve_r(t_gam[0], t_gam[1], false, tv_out, 3) : \
               space == "log"     ? RGB.ACEScct_r(UV=3).                moncurve_r(t_gam[0], t_gam[1], false, tv_out, 3) : \
                                    RGB

        } else if (isRGBo) {

               moncurve_r(t_gam[0], t_gam[1], false, tv_out, 3)
        } }

    if (!isRGBo && (isSpace || isIllu) || isRGBi && isFrmt) {

        R = isSpace || isIllu || isGamma ? R.moncurve_r(t_gam[0], t_gam[1], isRGBi && !isSpace && !isIllu && tv_in, false, 1) : R
        G = isSpace || isIllu || isGamma ? G.moncurve_r(t_gam[0], t_gam[1], isRGBi && !isSpace && !isIllu && tv_in, false, 1) : G
        B = isSpace || isIllu || isGamma ? B.moncurve_r(t_gam[0], t_gam[1], isRGBi && !isSpace && !isIllu && tv_in, false, 1) : B

        if (o_fmt[0]=="YcCbcCrc" || cs_out == "Rec2020CL") {

            YCbCr = RGB_to_YcCbcCrc( R, G, B, cs_out, coef_o, !(isSpace || isIllu || !tv_in), tv_out, fs)

            Y  = YCbCr[0]  Cb = YCbCr[1]  Cr = YCbCr[2]

            } else if (o_fmt[0]=="YCoCg") {

            } else if (o_fmt[0]=="YCoCgR") {

            } else if (o_fmt[0]=="YUVr") {

            } else if (o_fmt[0]=="OkLab") {

            } else if (o_fmt[0]=="HSV") {

            } else if (o_fmt[0]=="OPP") {

            } else if (o_fmt[0]=="ICtCp") {

            } else if (o_fmt[0]=="YCbCr") {

            scale_y   = !(isSpace || isIllu || !tv_in) && (isScale || !tv_out) ? ( 255 / 219.) : (isSpace || isIllu || !tv_in) && !(isScale || !tv_out) ? ( 219 / 255.) : 1.0
            scale_uv  = !(isSpace || isIllu || !tv_in) && (isScale || !tv_out) ? ( 255 / 112.) : (isSpace || isIllu || !tv_in) && !(isScale || !tv_out) ? ( 112 / 255.) : 0.5

            Kr = 1. - coef_o[0]
            Kb = 1. - coef_o[2]

            m0 = scale_y  *   coef_o[0]       m1 = scale_y  *   coef_o[1]         m2 = scale_y  *   coef_o[2]
            m3 = scale_uv * (-coef_o[0] / Kb) m4 = scale_uv * (-coef_o[1] / Kb)   m5 = scale_uv
            m6 = scale_uv                     m7 = scale_uv * (-coef_o[1] / Kr)   m8 = scale_uv * (-coef_o[2] / Kr)

            rangeY_TV = scale_y==219/255. ? "ymin +" : \
                        scale_y==255/219. ? "ymin -" : ""
            rangeC_TV = bdpth < 32        ? "range_half +" : ""

            Y  = Expr(R, G, B, ex_dlut("x "+rangeY_TV+" "+string(m0)+" * y "+rangeY_TV+" "+string(m1)+" * + z "+rangeY_TV+" "+string(m2)+" * + ",              bdpth, !tv_in), optSingleMode=true)
            Cb = Expr(R, G, B, ex_dlut("x "+rangeY_TV+" "+string(m3)+" * y "+rangeY_TV+" "+string(m4)+" * + z "+rangeY_TV+" "+string(m5)+" * + "+rangeC_TV+"", bdpth, !tv_in), optSingleMode=true)
            Cr = Expr(R, G, B, ex_dlut("x "+rangeY_TV+" "+string(m6)+" * y "+rangeY_TV+" "+string(m7)+" * + z "+rangeY_TV+" "+string(m8)+" * + "+rangeC_TV+"", bdpth, !tv_in), optSingleMode=true)

        }

        if (isScale) {

            Y    = space == "linear"  ? Y.moncurve_f(t_gam[0], t_gam[1], false, false, 1)                                  : \
                   space == "sigmoid" ? Y.moncurve_f(t_gam[0], t_gam[1], false, false, 1).ex_contrast(-1.15,0,191,false,1) : \
                   space == "log"     ? Y.moncurve_f(t_gam[0], t_gam[1], false, false, 1).ACEScct_f(UV=1)                  : \
                                        Y
            }

        str  = ReplaceStr(ReplaceStr(resampler, "("+string(nw), "("+string(cnw)), ","+string(nh), ","+string(cnh))
        str  = (cnw==cow && cnh==coh) ? Format("PointResize({cnw},{cnh}") : str # if chroma is not scaled (or scaled down to original) then use point as its faster and lossless
        Cb   = Eval("Cb." + str + cplaceY)
        Cr   = Eval("Cr." + str + cplaceY)

        if (isScale) {
            Y    = nomoir ? Y.ex_blur((1. / rat) / 2., mode="gaussian") : Y
            Y    = Eval("Y." + resampler + src_c + (noring ? Ynr : ""))

            Y    = space == "linear"  ? Y.                                moncurve_r(t_gam[0], t_gam[1], false, tv_out, 1) : \
                   space == "sigmoid" ? Y.ex_contrast(1.15,0,191,false,1).moncurve_r(t_gam[0], t_gam[1], false, tv_out, 1) : \
                   space == "log"     ? Y.ACEScct_r(UV=1).                moncurve_r(t_gam[0], t_gam[1], false, tv_out, 1) : \
                   tv_out             ? Y.SMPTE_legal(tv_out,3,1)                                                          : \
                                        Y
            }

        CombinePlanes(Y, Cb, Cr, planes="YUV", pixel_type="YUV"+o_fmt[1]+o_fmt[2])

        } }

        # Frame Properties

        isSpace || isFrmt ? PropSet("_Matrix", isRGBo?0:o_fmt[4]==-1?cs_outFA[1]:o_fmt[4])       : last # Yes, again, hardcoding matrix for RGB to 0
        isSpace           ? PropSet("_Primaries",o_fmt[5]==0||o_fmt[5]==-1?cs_outFA[2]:o_fmt[5]) : last # Same here
        isIllu            ? PropSet("_Illuminant",                        D_outA[3])             : last
        isGamma           ? PropSet("_Transfer",        Color_Fuzzy_search(EOTF)[4])             : last
        tv_in != tv_out   ? PropSet("_ColorRange",      tv_out?1:0)                              : last
        isChP             ? PropSet("_ChromaLocation",  cplace[2])                               : last

        # Show panel
        if (dg) {
            i_jab  = i_fmt[1]
            i_fmt  = i_fmt[0]
            o_jab  = o_fmt[1]
            o_fmt  = o_fmt[0]
            c_col  = cplace[0]
            c_cot  = cplace[1]
            tv_in  = tv_in  ? "Lim" : "Full"
            tv_out = tv_out ? "Lim" : "Full"
            msize  = min(nw,nh)

            bg     = BoxMask(0,round(msize/1.6),0,round(msize/1.3),invert=true)
            ex_blend(bg,"multiply",opacity=0.5)

            Subtitle(" ConvertFormat() 1.0 RC30",               size=msize/16,lsp=4,text_color=$00aef0,font="Segoe UI")
            Subtitle("\n\n SETTINGS:",                          size=msize/25,lsp=4)
            Subtitle(Format("\n\n\n\n\n "       \
                           +"width:\n "         \
                           +"height:\n "        \
                           +"model:\n "         \
                           +"OETF/EOTF:\n "     \
                           +"colorspace:\n "    \
                           +"D in/out:\n "      \
                           +"jab:\n "           \
                           +"range:\n "         \
                           +"cplacement:\n "    \
                           +"clocation:\n "     \
                           +"kernel:\n "        \
                           +"noring:\n "        \
                           +"nomoiree:\n "      \
                           +"UVrecon:"),                        size=msize/25,lsp=4)
            Subtitle(Format("\n\n\n\n IN\n "    \
                           +"{w} \n "           \
                           +"{h} \n "           \
                           +"{i_fmt} \n "       \
                           +"{OETF} \n "        \
                           +"{cs_in} \n "       \
                           +"{D_in} \n "        \
                           +"{i_jab} \n "       \
                           +"{tv_in} \n "       \
                           +"{cplace_in} \n "   \
                           +string(c_col,"%1.3f")+" \n "\
                           +"{kernel} \n "      \
                           +"{noring} \n "      \
                           +"{nomoir} \n "      \
                           +"{recon}"),            x=msize/4,   size=msize/25,lsp=4)
            Subtitle(Format("\n\n\n\n OUT\n "   \
                           +"{nw} \n "          \
                           +"{nh} \n "          \
                           +"{o_fmt} \n "       \
                           +"{EOTF} \n "        \
                           +"{cs_out} \n "      \
                           +"{D_out} \n "       \
                           +"{o_jab} \n "       \
                           +"{tv_out} \n "      \
                           +"{cplace_out} \n "  \
                           +string(c_cot,"%1.3f")),x=msize/2.25,size=msize/25,lsp=4)
    } }







####### FORMAT CONVERSION FUNCTIONS #######



# YCbCr to RGB standalone function
function YUV_to_RGB (clip yuv, string "matrix", bool "tv_range_in", bool "tv_range_out", string "kernel", float "b", float "c", float "p", string "cplace", bool "UVrecon", bool "fulls") {

    matrix     = Default (matrix, "709")
    kernel     = Default (kernel, "Bicubic")
    tv_in      = Default (tv_range_in, !(matrix=="JPEG" || matrix=="JPG"))
    tv_out     = Default (tv_range_out, false)
    cplace     = Default (cplace, "")
    recon      = Default (UVrecon, false)
    b          = Default (b, 0.0)
    c          = Default (c, 0.75)               # Precise Bicubic
    p          = Default (p, 0.25)
    fs         = Default (fulls, false)

    Assert(IsVersionOrGreater(3,7,1), "YUV_to_RGB: Update AviSynth+ version")
    Assert(isRGB(yuv)==false,         "YUV_to_RGB: Only YUV format supported")

    bdpth    = BitsPerComponent(yuv)
    lut      = bdpth < 16 ? 2 : 0
    p_type   = Format_fuzzy_search(yuv, PixelType(yuv), bdpth)
    matrix   = Color_Fuzzy_search (matrix)
    coef     = Matrix_coef(matrix[0])
    bc       = bicubic_coeffs(kernel)
    bc_b     = string(bc[1]>=0.?bc[0]:b)
    bc_c     = string(bc[1]>=0.?bc[1]:c)
    kernel   = bc[1]>=0. ? "Bicubic" : kernel

    p_type4  = p_type[1] == "444"
    p_type2  = p_type[1] == "422"
    p_type1  = p_type[1] == "411"
    p_type10 = p_type[1] == "410"

    w  = width (yuv)
    h  = height(yuv)
    nw = p_type4 ? w : p_type1 || p_type10 ? round(w/4.0) : round(w/2.0)
    nh = p_type4 ||    p_type1 || p_type2  ?            h : round(h/2.0)

    cplace  = chroma_placement(w, h, w, h, matrix[0], matrix[0], "YUV", "RGB", p_type[1], "444", cplace, "center" )

     p_type1             ? Assert(bdpth == 8, "YUV_to_RGB: Unsupported Pixel Type: HBD YUV411") : nop()
                           Assert(!p_type10,  "YUV_to_RGB: Unsupported Pixel Type: YUV410")

                           Assert(h%2==0,     "YUV_to_RGB: Height is not mod2" )
    !p_type1 || !p_type4 ? Assert(w%2==0,     "YUV_to_RGB: Width is not mod2" )                : nop()
     p_type1             ? Assert(w%4==0,     "YUV_to_RGB: Width is not mod4" )                : nop()

    point   = kernel=="Point" ? "+1.0" : ""
    cplaceH = ",src_left="+string(cplace[0])+point
    cplaceV = ",src_top ="+string(cplace[1])

    resampler = kernel == "nnedi3" ? "nnedi3_resize16(" + String(w) + "," + String(h) + cplaceH + cplaceV +")"                       : \
                kernel == "bicubic"?   "BicubicResize(" + String(w) + "," + String(h) + cplaceH + cplaceV +",b="+bc_b+",c="+bc_c+")" : \
                kernel == "gauss"  ?     "GaussResize(" + String(w) + "," + String(h) + cplaceH + cplaceV +",p=p)"                   : \
                                     kernel + "Resize(" + String(w) + "," + String(h) + cplaceH + cplaceV +")"

    Y   = ExtractY(yuv)
    Uor = ExtractU(yuv)
    Vor = ExtractV(yuv)

    # feisty2's ChromaReconstructor_faster v3.0 HBD mod

    if (recon && !p_type4) {

        cores   = SI_PhysicalCores()
        threads = SI_LogicalCores()

        ref     =   Y.KNLMeansCL(0, 16, 0, pow(1.464968620512209618455732713658, 6.4), "auto", wref=1)
        Luma    = ref.ConvertBits(8,dither=-1,fulls=fs).nnedi3_rpow2(rfactor=2, nns=1, qual=1, etype=1, nsize=0, threads=cores, prefetch=(threads+cores)/2).ConvertBits(bi,fulls=fs)
        Uu      = Uor.ConvertBits(8,dither=-1,fulls=fs).nnedi3_rpow2(rfactor=2, nns=1, qual=1, etype=1, nsize=0, threads=cores, prefetch=(threads+cores)/2, fwidth=w*2, fheight=h*2, ep0=0.0, ep1=0.75, cshift="bicubicresize",mpeg2=false).ConvertBits(bi,fulls=fs)
        Vu      = Vor.ConvertBits(8,dither=-1,fulls=fs).nnedi3_rpow2(rfactor=2, nns=1, qual=1, etype=1, nsize=0, threads=cores, prefetch=(threads+cores)/2, fwidth=w*2, fheight=h*2, ep0=0.0, ep1=0.75, cshift="bicubicresize",mpeg2=false).ConvertBits(bi,fulls=fs)
        Unew    = Uu.KNLMeansCL(0, 16, 0, 6.4, "auto", wref=0, rclip=Luma).BicubicResize(w, h, b=-0.5, c=0.25)
        Vnew    = Vu.KNLMeansCL(0, 16, 0, 6.4, "auto", wref=0, rclip=Luma).BicubicResize(w, h, b=-0.5, c=0.25)
        U       = ex_makeadddiff(Unew, Removegrain(Unew, 19), Uu.BicubicResize(w, h, b=-0.5, c=0.25))
        V       = ex_makeadddiff(Vnew, Removegrain(Vnew, 19), Vu.BicubicResize(w, h, b=-0.5, c=0.25))

    } else {

        U   = p_type4 ? Uor : Eval("Uor." + resampler)
        V   = p_type4 ? Vor : Eval("Vor." + resampler)

        }


    if (matrix[0]=="Rec2020CL" || matrix[0]=="DCI-P3" || matrix[0]=="Display-P3") {

        RGB = YcCbcCrc_to_RGB( Y, U, V, matrix[0], coef, tv_in, tv_out, fs)

        R = RGB[0]  G = RGB[1]  B = RGB[2]

    } else {

        scale_y   = tv_in ? (255 / 219.) : 1.0
        scale_uv  = tv_in ? (255 / 112.) : 2.0

        Kr = 1. - coef[0]
        Kb = 1. - coef[2]

        m0 = scale_y     m1 = 0.0                                   m2 = scale_uv * Kr
        m3 = scale_y     m4 = scale_uv * ( -Kb * coef[2] / coef[1]) m5 = scale_uv * ( -Kr * coef[0] / coef[1])
        m6 = scale_y     m7 = scale_uv * Kb                         m8 = 0.0

        rangeY   = tv_in      ? "ymin - "                          : ""
        range_TV = tv_out     ? "ymax ymin - range_max / * ymin +" : ""
        UVf      = bdpth < 32 ? "range_half - " : ""

        R = Expr(Y,    V, ex_dlut( "x "+rangeY+" "+string(m0)+" *                            y "+UVf + string(m2)+" * + "+range_TV+"", bdpth, fs), optSingleMode=false, lut=lut)
        G = Expr(Y, U, V, ex_dlut( "x "+rangeY+" "+string(m3)+" * y "+UVf + string(m4)+" * + z "+UVf + string(m5)+" * + "+range_TV+"", bdpth, fs), optSingleMode=true , lut=  0)
        B = Expr(Y, U,    ex_dlut( "x "+rangeY+" "+string(m6)+" * y "+UVf + string(m7)+" * +                            "+range_TV+"", bdpth, fs), optSingleMode=false, lut=lut)

    }

    CombinePlanes(R, G, B, planes="RGB") }



# RGB to YCbCr standalone function
function RGB_to_YUV (clip rgb, string "matrix", bool "tv_range_in", bool "tv_range_out", string "pixel_type", string "kernel", float "b", float "c", float "p", string "cplace", bool "fulls") {

    matrix     = Default (matrix, "sRGB")
    p_type     = Default (pixel_type, "420")     # target YUV pixel_type
    kernel     = Default (kernel, "Bicubic")
    tv_in      = Default (tv_range_in, false)
    tv_out     = Default (tv_range_out, true)
    cplace     = Default (cplace, "")
    b          = Default (b, -0.5)
    c          = Default (c, 0.25)               # Didée's Bicubic
    p          = Default (p, 0.25)
    fs         = Default (fulls, false)

    Assert(IsVersionOrGreater(3,7,1),               "RGB_to_YUV: Update AviSynth+ version")
    Assert(isRGB(rgb)==true && IsPlanar(rgb)==true, "RGB_to_YUV: Only Planar RGB format supported")

    bdpth    = BitsPerComponent(rgb)
    p_type   = Format_fuzzy_search (rgb, p_type, bdpth)
    matrix   = Color_Fuzzy_search (matrix)
    coef     = Matrix_coef(matrix[0])
    bc       = bicubic_coeffs(kernel)
    bc_b     = string(bc[1]>=0.?bc[0]:b)
    bc_c     = string(bc[1]>=0.?bc[1]:c)
    kernel   = bc[1]>=0. ? "Bicubic" : kernel

    p_type4  = p_type[1] == "444"
    p_type2  = p_type[1] == "422"
    p_type1  = p_type[1] == "411"
    p_type10 = p_type[1] == "410"

    w  = width (rgb)
    h  = height(rgb)
    nw = p_type4 ? w : p_type1 || p_type10 ? round(w/4.0) : round(w/2.0)
    nh = p_type4 ||    p_type1 || p_type2  ?            h : round(h/2.0)

    cplace  = chroma_placement(w, h, w, h, matrix[0], matrix[0], "RGB", "YUV", "444", p_type[1], "center", cplace )

     p_type1             ? Assert(bdpth == 8, "RGB_to_YUV: Unsupported Pixel Type: HBD YUV411") : nop()
                           Assert(!p_type10,  "RGB_to_YUV: Unsupported Pixel Type: YUV410")

                           Assert(h%2==0,     "RGB_to_YUV: Height is not mod2" )
    !p_type1 || !p_type4 ? Assert(w%2==0,     "RGB_to_YUV: Width is not mod2" )                : nop()
     p_type1             ? Assert(w%4==0,     "RGB_to_YUV: Width is not mod4" )                : nop()


    Rx = ExtractR(rgb)
    Gx = ExtractG(rgb)
    Bx = ExtractB(rgb)


    if (matrix[0]=="Rec2020CL" || matrix[0]=="DCI-P3" || matrix[0]=="Display-P3") {

        YCbCr = RGB_to_YcCbcCrc( Rx, Gx, Bx, matrix[0], coef, tv_in, tv_out, fs)

        Y  = YCbCr[0]  Cb = YCbCr[1]  Cr = YCbCr[2]

    } else {

        scale_y   = !tv_in && tv_out ? ( 219 / 255.) : 1.0
        scale_uv  = !tv_in && tv_out ? ( 112 / 255.) : 0.5

        Kr = 1. - coef[0]
        Kb = 1. - coef[2]

        m0 = scale_y  *   coef[0]       m1 = scale_y  *   coef[1]         m2 = scale_y  *   coef[2]
        m3 = scale_uv * (-coef[0] / Kb) m4 = scale_uv * (-coef[1] / Kb)   m5 = scale_uv
        m6 = scale_uv                   m7 = scale_uv * (-coef[1] / Kr)   m8 = scale_uv * (-coef[2] / Kr)

        UVf       =  bdpth < 32      ? "" : "range_half -"
        rangeY_TV =  tv_out ?  tv_in ? "" : "ymin +" : tv_in ? "ymin - range_max ymax ymin - / *"    : ""
        rangeC_TV = !tv_out && tv_in ? "range_half - range_max cmax cmin - / * range_half + "+UVf+"" : UVf

        Y  = Expr(Rx, Gx, Bx, ex_dlut("           x "+string(m0)+" *   y "+string(m1)+" * + z "+string(m2)+" * + "+rangeY_TV+"", bdpth, fs), optSingleMode=true)
        Cb = Expr(Rx, Gx, Bx, ex_dlut("range_half x "+string(m3)+" * + y "+string(m4)+" * + z "+string(m5)+" * + "+rangeC_TV+"", bdpth, fs), optSingleMode=true)
        Cr = Expr(Rx, Gx, Bx, ex_dlut("range_half x "+string(m6)+" * + y "+string(m7)+" * + z "+string(m8)+" * + "+rangeC_TV+"", bdpth, fs), optSingleMode=true)

    }

    point   = kernel=="Point" ? "+1.0" : ""
    cplaceH = ",src_left="+string(cplace[0])+point
    cplaceV =  ",src_top="+string(cplace[1])

    resampler = kernel == "nnedi3" ? "nnedi3_resize16(" + String(nw+nw%2) + "," + String(nh+nh%2) + cplaceH + cplaceV + ")"         : \
                kernel == "bicubic"?   "BicubicResize(" + String(nw+nw%2) + "," + String(nh+nh%2) + cplaceH + cplaceV + ",b="+bc_b+",c="+bc_c+")" : \
                kernel == "gauss"  ?     "GaussResize(" + String(nw+nw%2) + "," + String(nh+nh%2) + cplaceH + cplaceV + ",p=p)"     : \
                                     kernel + "Resize(" + String(nw+nw%2) + "," + String(nh+nh%2) + cplaceH + cplaceV + ")"

    Cb = p_type4 ? Cb : Eval("Cb." + resampler)
    Cr = p_type4 ? Cr : Eval("Cr." + resampler)

    CombinePlanes(Y, Cb, Cr, planes="YUV", pixel_type="YUV"+p_type[1]+p_type[2]) }


# RGB to YcCbcCrc function (for Rec.2020CL)
function RGB_to_YcCbcCrc (clip RGB, clip "Gx", clip "Bx", string "matrix", float_array "coef", bool "tv_in", bool "tv_out", bool "fulls") {

    isy  = isy(RGB)
    bi   = BitsPerComponent(RGB)
    lut  = bi < 16 ? 2 : 0
    mat  = Default (matrix, "Rec709")
    coef = Default (coef, Matrix_coef(mat))
    tvi  = Default (tv_in,  false)
    tvo  = Default (tv_out, false)
    fs   = Default (fulls,  !tvi)

    mat       = Color_Fuzzy_search(mat)
    s_gam     = moncurve_coef(mat[0]) # some values are getting crushed in the Rec709 transfer
    bi32      = bi == 32 ? "" : "range_half +"
    rangeC_PC = tvi      ? "range_half - range_max cmax cmin - / * range_half + " : ""
    rangeC_TV = tvo      ? "range_half + cmax cmin - range_max / * cmin + "       : bi32

    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    B   = !isy ? clp[2] :      Bx

    clp = !isy ?          moncurve_f(RGB, s_gam[0], s_gam[1], tvi, false, 3).ExtractClip() : nop()
    Rln = !isy ? clp[0] : moncurve_f(RGB, s_gam[0], s_gam[1], tvi, false, 1)
    Gln = !isy ? clp[1] : moncurve_f(Gx,  s_gam[0], s_gam[1], tvi, false, 1)
    Bln = !isy ? clp[2] : moncurve_f(Bx,  s_gam[0], s_gam[1], tvi, false, 1)

    ca = 1.0 + s_gam[1]
    cb = 1.0 / s_gam[0]

    Pb = 1 /  (2. * (ca*(1.0 - pow(coef[2], cb))))
    Pr = 1 /  (2. * (ca*(1.0 - pow(coef[0], cb))))
    Nb = 1 / (-2. * (ca*(1.0 - pow(coef[0] + coef[1], cb)) - 1.0))
    Nr = 1 / (-2. * (ca*(1.0 - pow(coef[1] + coef[2], cb)) - 1.0))

    Y     = Expr(Rln, Gln, Bln, "x "+string(coef[0])+" * y "+string(coef[1])+" * + z "+string(coef[2])+" * + ")
    Yx    = moncurve_r(Y,  s_gam[0], s_gam[1], false, false, 1)

    Cbc   = Expr(B, Yx, ex_dlut(Format("x "+rangeC_PC+" y - A@ 0 <= A {Nb} * A {Pb} * ? "+rangeC_TV+" "), bi, fs), lut=lut)
    Crc   = Expr(R, Yx, ex_dlut(Format("x "+rangeC_PC+" y - A@ 0 <= A {Nr} * A {Pr} * ? "+rangeC_TV+" "), bi, fs), lut=lut)
    Yc    = !tvo ?  Yx : moncurve_r(Y,  s_gam[0], s_gam[1], false, true, 1)

     isy ? [Yc, Cbc, Crc] : CombinePlanes(Yc, Cbc, Crc, planes="YUV")
    !isy && mat[0] == "Rec2020CL" ? PropSet("_Matrix", 10) : last }


# WIP. YcCbcCrc to RGB function (for Rec.2020CL)
function YcCbcCrc_to_RGB (clip YUV, clip "Cb", clip "Cr", string "matrix", float_array "coef", bool "tv_in", bool "tv_out", bool "fulls") {

    isy  = isy(YUV)
    bi   = BitsPerComponent(YUV)
    lut  = bi < 16 ? 2 : 0
    mat  = Default (matrix, "Rec709")
    coef = Default (coef, Matrix_coef(mat))
    tvi  = Default (tv_in,  false)
    tvo  = Default (tv_out, false)
    fs   = Default (fulls,  !tvi)

    mat  = Color_Fuzzy_search(mat)
    clp  = !isy ? ExtractClip(YUV) : nop()
    Y    = !isy ? clp[0] :    YUV
    Cb   = !isy ? clp[1] :     Cb
    Cr   = !isy ? clp[2] :      Cr

    bi32m     = bi == 32 ? "" : "range_half -"
    bi32p     = bi == 32 ? "" : "range_half +"
    rangeC_PC = tvi ? ""+bi32m+" range_max cmax cmin - / *" : bi32m

    s_gam = moncurve_coef(mat[0])
    a = 1.0 + s_gam[1]
    b = 1.0 / s_gam[0]

    Pb =  2. * (a*(1.0 - pow(coef[2], b)))
    Pr =  2. * (a*(1.0 - pow(coef[0], b)))
    Nb = -2. * (a*(1.0 - pow(coef[0] + coef[1], b)) - 1.0)
    Nr = -2. * (a*(1.0 - pow(coef[1] + coef[2], b)) - 1.0)

    Y  = moncurve_f(Y,  s_gam[0], s_gam[1], tvi, false, 1)

    Bx = Expr(Cb, Y, ex_dlut(Format("x "+rangeC_PC+" A@ 0 <= A {Nb} * y "+bi32m+" B@ + A {Pb} * B + ? "+bi32p), bi, fs), lut=lut)
    Rx = Expr(Cr, Y, ex_dlut(Format("x "+rangeC_PC+" A@ 0 <= A {Nr} * y "+bi32m+" B@ + A {Pr} * B + ? "+bi32p), bi, fs), lut=lut)

    Gx = Expr(Y, Bx, Rx, "x "+string(coef[2])+" y * - "+string(coef[0])+" z * - "+string(coef[1])+" / ", optSingleMode=true)

    if (isy) {

        B = moncurve_r(Bx,  s_gam[0], s_gam[1], false, tvo, 1)
        R = moncurve_r(Rx,  s_gam[0], s_gam[1], false, tvo, 1)
        G = moncurve_r(Gx,  s_gam[0], s_gam[1], false, tvo, 1)
        [R, G, B]

    } else {

        CombinePlanes(Rx, Gx, Bx, planes="RGB")
        moncurve_r(s_gam[0], s_gam[1], false, tvo, 3)

    } }




# YCoCg, YCoCgR and YUVr compress better than plain YUV. YCoCg variants a tiny bit over YUVr, and YUVr and YCoCgR being losslessly reversible (RCT) with RGB
# These formats are ColorSpace and Chroma Subsampling independent, as well as signal range (full or legal)

# RGB to YCoCg function
function RGB_to_YCoCg (clip RGB, clip "G", clip "B", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    b32 = bi == 32 ? "" : "range_half +"

    if (isy) {
        Y  = Expr(R, G, B, ex_dlut("x z + 0.25 * y 0.5  * + ",     bi, fs), optSingleMode=true,  lut=  0)
        Cg = Expr(R, G, B, ex_dlut("y 0.5  * x z + 0.25 * - "+b32, bi, fs), optSingleMode=true,  lut=  0)
        Co = Expr(R,    B, ex_dlut("x y - 0.5  *            "+b32, bi, fs), optSingleMode=false, lut=lut)
        [Y, Cg, Co]

    } else {

        fmt = Format_fuzzy_search(RGB, "YUV", bi)
        Expr(R, G, B, ex_dlut("x z + 0.25 * y 0.5  * + ",     bi, fs),  \
                      ex_dlut("y 0.5  * x z + 0.25 * - "+b32, bi, fs),  \
                      ex_dlut("x z - 0.5  *            "+b32, bi, fs), format="YUV444"+fmt[2], optSingleMode=true) } }


# YCoCg to RGB function
function YCoCg_to_RGB (clip YCC, clip "Cg", clip "Co", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(YCC)
    bi  = BitsPerComponent(YCC)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(YCC) : nop()
    Y   = !isy ? clp[0] :    YCC
    Cg  = !isy ? clp[1] :     Cg
    Co  = !isy ? clp[2] :      Co

    b32 = bi == 32 ? "" : "range_half -"

    if (isy) {

        R = Expr(Y, Cg, Co, ex_dlut("x y "+b32+" - z "+b32+" + ", bi, fs), optSingleMode=true,  lut=  0)
        G = Expr(Y, Cg,     ex_dlut("x y "+b32+" +",              bi, fs), optSingleMode=false, lut=lut)
        B = Expr(Y, Cg, Co, ex_dlut("x y "+b32+" - z "+b32+" - ", bi, fs), optSingleMode=true,  lut=  0)
        [R, G, B]

    } else {

        fmt = Format_fuzzy_search(YCC, "RGB", bi)
        Expr(Y, Cg, Co, ex_dlut("x y "+b32+" - z "+b32+" + ", bi, fs),  \
                        ex_dlut("x y "+b32+" +",              bi, fs),  \
                        ex_dlut("x y "+b32+" - z "+b32+" - ", bi, fs), format="RGB"+fmt[2], optSingleMode=true) } }


# RGB to YCoCg RCT function
function RGB_to_YCoCgR (clip RGB, clip "G", clip "B", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    b32i = bi == 32 ? "" : "range_half +"
    b32f = bi == 32 ? "" : "range_half -"

    Co = Expr(R,      B, ex_dlut("x 0.5  * y 0.5  * - "+b32i,            bi, fs), optSingleMode=false, lut=lut)
    Cg = Expr(Co, G,  B, ex_dlut("y z x "+b32f+" 0.5 * + - 0.5 * "+b32i, bi, fs), optSingleMode=false, lut=  0)
    Y  = Expr(Co, Cg, B, ex_dlut("  z x "+b32f+" 0.5 * + y "+b32f+" +",  bi, fs), optSingleMode=false, lut=  0)

    isy ? [Y, Cg, Co] : CombinePlanes(Y, Cg, Co, planes="YUV") }


#  YCoCg RCT to RGB function
function YCoCgR_to_RGB (clip YCC, clip "Cg", clip "Co", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(YCC)
    bi  = BitsPerComponent(YCC)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(YCC) : nop()
    Y   = !isy ? clp[0] :    YCC
    Cg  = !isy ? clp[1] :     Cg
    Co  = !isy ? clp[2] :      Co

    b32 = bi == 32 ? "" : "range_half -"

    if (isy) {

        G = Expr(Y, Cg,     ex_dlut("y   "+b32+" Y@ 2 * x Y - +",      bi, fs), optSingleMode=false, lut=lut)
        B = Expr(Y, Cg, Co, ex_dlut("x y "+b32+" - z "+b32+" 0.5 * -", bi, fs), optSingleMode=true,  lut=  0)
        R = Expr(Co, B,     ex_dlut("y x "+b32+" 2 * +",               bi, fs), optSingleMode=false, lut=lut)
        [R, G, B]

    } else {

        fmt = Format_fuzzy_search(YCC, "RGB", bi)
        Expr(Y, Cg, Co, ex_dlut("z   "+b32+" dup 0.5 * x y "+b32+" - swap - swap 2 * +", bi, fs),  \
                        ex_dlut("y   "+b32+" Y@ 2 * x Y - +",      bi, fs),                        \
                        ex_dlut("x y "+b32+" - z "+b32+" 0.5 * -", bi, fs), format="RGB"+fmt[2], optSingleMode=true) } }


# RGB to YCbCr RCT function (Reversible Color Transform, from JPEG 2000, similar to YCoCg)
function RGB_to_YUVr (clip RGB, clip "G", clip "B", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,  false)

    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    b32 = bi == 32 ? "" : "range_half +"

    if (isy) {
        Y  = Expr(R, G, B, ex_dlut("x z + 0.25 * y 0.5  * + ", bi, fs), optSingleMode=true,  lut=  0)
        Cb = Expr(   G, B, ex_dlut("y x - "+b32,               bi, fs), optSingleMode=false, lut=lut)
        Cr = Expr(R, G,    ex_dlut("x y - "+b32,               bi, fs), optSingleMode=false, lut=lut)
        [Y, Cb, Cr]

    } else {

        fmt = Format_fuzzy_search(RGB, "YUV", bi)
        Expr(R, G, B, ex_dlut("x z + 0.25 * y 0.5  * + ", bi, fs),  \
                      ex_dlut("z y - "+b32,               bi, fs),  \
                      ex_dlut("x y - "+b32,               bi, fs), format="YUV444"+fmt[2], optSingleMode=true) } }


# YCbCr RCT to RGB function (Reversible Color Transform, from JPEG 2000, similar to YCoCg)
function YUVr_to_RGB (clip YUV, clip "Cb", clip "Cr", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(YUV)
    bi  = BitsPerComponent(YUV)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,  false)

    clp = !isy ? ExtractClip(YUV) : nop()
    Y   = !isy ? clp[0] :    YUV
    Cb  = !isy ? clp[1] :     Cb
    Cr  = !isy ? clp[2] :      Cr

    b32  = bi == 32 ? "" : "range_half -"
    b32h = bi == 32 ? "" : "range_half 0.5 * +"

        G = Expr(Y, Cb, Cr, ex_dlut("x y z + 0.25 * - "+b32h, bi, fs), optSingleMode=true,  lut=  0)

    if (isy) {

        R = Expr(G,     Cr, ex_dlut("x y + "+b32,             bi, fs), optSingleMode=false, lut=lut)
        B = Expr(G, Cb,     ex_dlut("x y + "+b32,             bi, fs), optSingleMode=false, lut=lut)
        [R, G, B]

    } else {

        fmt = Format_fuzzy_search(YUV, "RGB", bi)
        Expr(G, Cb, Cr, ex_dlut("x z + "+b32,                 bi, fs),"",  \
                        ex_dlut("x y + "+b32,                 bi, fs), format="RGB"+fmt[2]) } }


# RGB' to OPP
# This looks like a gamma encoded transformation. For the linear version use the matrix functions.
# The matrix there yields from a joint matrix between XYZ to a modified LMS matrix and a LMS to OPP matrix
#
#   # XYZ to LMS. Looks like a version of Stockman & Sharpe (2000) LMS (and not the usual Hunt-Pointer-Estevez normalized to D65)
#   [[0.2430, 0.8560, -0.0440],\
#   [-0.3910,  1.1650, 0.0870],\
#   [0.0100,  -0.0080, 0.5630]]

#   # LMS to OPP
#   [[1.0,   0.0,   0.0],\
#   [-0.59,  0.80, -0.12],\
#   [-0.34, -0.11,  0.93]]

# https://github.com/HomeOfVapourSynthEvolution/VapourSynth-BM3D/blob/7b3d8dd32e4aa4d962cf15d75d191b465682ed42/include/Specification.h#L176
function RGB_to_OPP (clip RGB, clip "G", clip "B", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)
    lut = bi < 16 ? 2 : 0
    fs  = Default (fulls, true)

    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    b32 = bi == 32 ? "" : "range_half +"

        Os  = ex_dlut(Format("x y z + + 0.333333333 *")         , bi, fs)
        P1s = ex_dlut(Format("x "+(isy?"y":"z")+" - 0.5 * "+b32), bi, fs)
        P2s = ex_dlut(Format("x z + 0.25 * y 0.5 * - "+b32)     , bi, fs)

    if (isy) {

        O  = Expr(R, G, B, Os,  optSingleMode=false, lut=  0)
        P1 = Expr(R,    B, P1s, optSingleMode=false, lut=lut)
        P2 = Expr(R, G, B, P2s, optSingleMode=false, lut=  0)
        [O, P1, P2]

    } else { Expr(R, G, B, Os, P1s, P2s, format="YUV444"+Format_fuzzy_search(RGB,"YUV",bi)[2], optSingleMode=true) } }


# https://github.com/HomeOfVapourSynthEvolution/VapourSynth-BM3D/blob/7b3d8dd32e4aa4d962cf15d75d191b465682ed42/include/Specification.h#L176
function OPP_to_RGB (clip OPP, clip "P1", clip "P2", bool "fulls") {

    isy = isy(OPP)
    bi  = BitsPerComponent(OPP)
    lut = bi < 16 ? 2 : 0
    fs  = Default (fulls, true)

    clp = !isy ? ExtractClip(OPP) : nop()
    O   = !isy ? clp[0] :    OPP
    P1  = !isy ? clp[1] :     P1
    P2  = !isy ? clp[2] :      P2

    b32 = bi == 32 ? "" : "range_half -"

        Rs = ex_dlut(Format("x y "+b32+" + z "+b32+" 0.666666666 * +")    , bi, fs)
        Gs = ex_dlut(Format("x "+(isy?"y":"z")+" "+b32+" 1.333333333 * -"), bi, fs)
        Bs = ex_dlut(Format("x z "+b32+" 0.666666666 * + y "+b32+" -")    , bi, fs)

    if (isy) {

        R = Expr(O, P1, P2, Rs, optSingleMode=false, lut=  0)
        G = Expr(O,     P2, Gs, optSingleMode=false, lut=lut)
        B = Expr(O, P1, P2, Bs, optSingleMode=false, lut=  0)
        [R, G, B]

    } else { Expr(O, P1, P2, Rs, Gs, Bs, format="RGB"+Format_fuzzy_search(OPP,"RGB",bi)[2], optSingleMode=true) } }


# XYZ to YDzDx (applied on SMPTE ST 2084 gamma space)
function XYZ_to_YDzDx (clip XYZ, clip "Y", clip "Z", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(XYZ)
    bi  = BitsPerComponent(XYZ)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(XYZ) : nop()
    X   = !isy ? clp[0] :    XYZ
    Y   = !isy ? clp[1] :     Y
    Z   = !isy ? clp[2] :      Z

    b32 = bi == 32 ? "" : "range_half +"

    cf1   = 2763/2800.
    cf2   = 2741/2763.

    if (isy) {

        Dz = Expr(   Y, Z, ex_dlut(Format("{cf1} y "+b32+" * x  - "), bi, fs), optSingleMode=false, lut=lut)
        Dx = Expr(X, Y,    ex_dlut(Format("x "+b32+"  {cf2} y * - "), bi, fs), optSingleMode=false, lut=lut)
        [Y, Dz, Dx]

    } else {

        Expr(Y, X, Z, "", ex_dlut(Format("{cf1} z "+b32+" * x  - "), bi, fs),  \
                          ex_dlut(Format("y "+b32+"  {cf2} x * - "), bi, fs), format=PixelType(XYZ)) } }


# YDzDx to XYZ
function YDzDx_to_XYZ (clip YDzDx, clip "Dz", clip "Dx", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(YDzDx)
    bi  = BitsPerComponent(YDzDx)
    lut = bi < 16 ? 2 : 0
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(YDzDx) : nop()
    Y   = !isy ? clp[0] :    YDzDx
    Dz  = !isy ? clp[1] :     Dz
    Dx  = !isy ? clp[2] :      Dx

    b32 = bi == 32 ? "" : "range_half -"

    cf1   = 2800/2763.
    cf2   = 2763/2741.

    if (isy) {

        X = Expr(Dx, Y, ex_dlut(Format("x "+b32+" y {cf2} * + "), bi, fs), optSingleMode=false, lut=lut)
        Z = Expr(Dz, Y, ex_dlut(Format("x "+b32+" y {cf1} * + "), bi, fs), optSingleMode=false, lut=lut)
        [X, Y, Z]

    } else {

        Expr(Dx, Y, Dz, ex_dlut(Format("x "+b32+" y {cf1} * + "), bi, fs), "",  \
                        ex_dlut(Format("z "+b32+" y {cf2} * + "), bi, fs), format=PixelType(YDzDx)) } }


# WIP. XYZ to CIE Lab -D65 based- (process in linear space) Normalized to 0-1
function XYZ_to_Lab (clip XYZ, clip "Y", clip "Z", bool "Jch", bool "fulls") {

    isy  = isy(XYZ)
    bi   = BitsPerComponent(XYZ)
    lut1 = bi == 32 ? 0 : 1
    lut2 = bi  < 16 ? 2 : 0
    cy   = Default (Jch,   false)
    fs   = Default (fulls,  true)

    clp  = !isy ? ExtractClip(XYZ) : nop()
    X    = !isy ? clp[0] :    XYZ
    Y    = !isy ? clp[1] :     Y
    Z    = !isy ? clp[2] :      Z

    ep    = pow(24. / 116, 3)               # 0.00885645167903563081717167575546 (or 216 / 24389.)
    coef  = pow(24. / 116, 2) * 3           # 0.12841854934601664684898929845422 (or 108 / 841)
    coefr = pow(24. / 116, -2) * (1 / 3.)   # 7.78703703703703703703703703703703 (or 841 / 108)  reciprocal of above
    rW    = [95.0449218275099, 100., 108.8916648430471] # Reference White: Normalization to Y=100 of reciprocal of illuminant

    L = Expr(Y,               Format("x "+string(rW[1])+" / Y@ {ep} > Y 0.333333333 ^ Y {coefr} * 16 116 / + ? 116 * 16 - "+" 9 /"),           optSingleMode=false, lut=lut1)
    a = Expr(X, Y,    ex_dlut(Format("x "+string(rW[0])+" / X@ {ep} > X 0.333333333 ^ X {coefr} * 16 116 / + ?
                                      y "+string(rW[1])+" / Y@ {ep} > Y 0.333333333 ^ Y {coefr} * 16 116 / + ? - 500 * "+" 13.45 /"), bi, fs), optSingleMode=true,  lut=lut2)
    b = Expr(   Y, Z, ex_dlut(Format("x "+string(rW[1])+" / Y@ {ep} > Y 0.333333333 ^ Y {coefr} * 16 116 / + ?
                                      y "+string(rW[2])+" / Z@ {ep} > Z 0.333333333 ^ Z {coefr} * 16 116 / + ? - 200 * "+" 12.3  /"), bi, fs), optSingleMode=true,  lut=lut2)

    isy ? [L, a, b] : CombinePlanes(L, a, b, planes="RGB") }


# WIP. CIE Lab to XYZ
function Lab_to_XYZ (clip Lab, clip "a", clip "b", bool "Jch", bool "fulls") {

    isy  = isy(Lab)
    bi   = BitsPerComponent(Lab)
    lut1 = bi == 32 ? 0 : 1
    lut2 = bi  < 16 ? 2 : 0
    cy   = Default (Jch,    false)
    fs   = Default (fulls,   true)

    clp  = !isy ? ExtractClip(Lab) : nop()
    L    = !isy ? clp[0] :    Lab
    a    = !isy ? clp[1] :     a
    b    = !isy ? clp[2] :      b

    ep    = 24  / 116.          # 0.20689655172413793103448275862069
    ep2   = pow(ep, 3)          # 0.00885645167903563081717167575546 (or 216 / 24389.)
    coef  = pow(ep, 2) * 3      # 0.12841854934601664684898929845422 (or 108 / 841)
    kappa = 24389 / 27.         # 903.296296296296296296296296296296
    rW    = [95.0449218275099, 100., 108.8916648430471] # Reference White: Normalization to Y=100 of reciprocal of illuminant

    Y = Expr( L,    Format("x 100 * 16 + 116 / Y@                 {ep} > Y 3 ^ Y 16 116 / - {coef} * ?                          "), optSingleMode=false, lut=lut1)
    X = Expr( L, a, Format("x 100 * 16 + 116 / y 100 * 500 / + X@ {ep} > X 3 ^ X 16 116 / - {coef} * ? "+string(rW[0])+" * 100 /"), optSingleMode=false, lut=lut2)
    Z = Expr( L, b, Format("x 100 * 16 + 116 / y 100 * 200 / - Z@ {ep} > Z 3 ^ Z 16 116 / - {coef} * ? "+string(rW[2])+" * 100 /"), optSingleMode=false, lut=lut2)

    isy ? [X, Y, Z] : CombinePlanes(X, Y, Z, planes="RGB") }



# XYZ to CIE Luv/Duv -D65 based- (process in linear space) (32-bit float recommended)
function XYZ_to_Luv (clip XYZ, clip "Y", clip "Z", bool "Jch", bool "Duv", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(XYZ)
    bi  = BitsPerComponent(XYZ)
    lut = bi == 32 ? 0 : 1
    cy  = Default (Jch,    false)
    uv  = Default (Duv,    false)
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(XYZ) : nop()
    X   = !isy ? clp[0] :    XYZ
    Y   = !isy ? clp[1] :     Y
    Z   = !isy ? clp[2] :      Z

    b32 = bi == 32 ? "" : "range_half +"

    ep    = 216 / 24389.
    kappa = 24389 / 27.
    c     = 1 / 0.62

    rW    = [95.0449218275099, 100., 108.8916648430471]

    detu  = (4 * rW[0] / (rW[0] + 15 * rW[1] + 3 * rW[2]))
    detv  = (9 * rW[1] / (rW[0] + 15 * rW[1] + 3 * rW[2]))
    duv   = uv ? Format(" {c} * ") : ""

    L = Expr(Y,                  Format("x {ep} > x 0.333333333 ^ 116 * 16 - x {kappa} * ? "),             optSingleMode=false, lut=lut)
    u = Expr(X, Y, Z, L, ex_dlut(Format("x 4 * x y 15 * + z 3 * + / {detu} - a 13 * * "+duv+b32), bi, fs), optSingleMode=true,  lut=  0)
    v = Expr(X, Y, Z, L, ex_dlut(Format("x 9 * x y 15 * + z 3 * + / {detv} - a 13 * * "+duv+b32), bi, fs), optSingleMode=true,  lut=  0)

    isy ? [L, u, v] : CombinePlanes(L, u, v, planes="RGB") }


#https://www.brucelindbloom.com/index.html?Eqn_Luv_to_XYZ.html
# CIE Luv to XYZ
function Luv_to_XYZ (clip Luv, clip "u", clip "v", bool "Jch", bool "Duv", bool "tv_in", bool "tv_out", bool "fulls") {

    isy = isy(Luv)
    bi  = BitsPerComponent(Luv)
    lut = bi == 32 ? 0 : 1
    cy  = Default (Jch,    false)
    uv  = Default (Duv,    false)
    tvi = Default (tv_in,  false)
    tvo = Default (tv_out, false)
    fs  = Default (fulls,   true)

    clp = !isy ? ExtractClip(Luv) : nop()
    L   = !isy ? clp[0] :    Luv
    u   = !isy ? clp[1] :     u
    v   = !isy ? clp[2] :      v

    b32 = bi == 32 ? "" : "range_half -"

    ep    = 216 / 24389.
    kappa = 24389 / 27.
    exk   = ep * kappa
    D65N  = [0.312713, 0.329016, 0.358271]
    Wr    = [95.0449218275099, 100., 108.8916648430471]

    detu  = (4 * D65N[0] / (D65N[0] + 15 * D65N[1] + 3 * D65N[2]))
    detv  = (9 * D65N[1] / (D65N[0] + 15 * D65N[1] + 3 * D65N[2]))
    duv   = uv ? Format(" 0.62 * ") : ""

    Y = Expr(      L,       Format("x {exk} > x 16 + 116 / 3 ^ x {kappa} / ?"),                                optSingleMode=false, lut=lut)
    X = Expr(   Y, L, u, v, Format("y 39 * y 13 * A@ {detv} * a "+duv+b32+" + / 5 - x * x 5 * +
                                    y 52 * A {detu} * z "+duv+b32+" + / 1 - 0.333333333 * 0.333333333 + / "),  optSingleMode=true,  lut=  0)
    Z = Expr(X, Y, L, u,    Format("z 52 * z 13 * {detu} * a "+duv+b32+" + / 1 - 0.333333333 * x * y 5 * - "), optSingleMode=true,  lut=  0)

    isy ? [X, Y, Z] : CombinePlanes(X, Y, Z, planes="RGB") }


# RGB' (gamma encoded) to HSV
function RGB_to_HSV (clip RGB, clip "G", clip "B", bool "tv_range", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)

    tv  = Default (tv_range, false)
    fs  = Default (fulls,     true)

    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    rangePC  = tv ? "ymin - ymax ymin - /" : bi == 32 ? "" : "range_max /"
    rangeTV  = tv ? "ymax ymin - * ymin +" : bi == 32 ? "" : "range_max *"

    V  = Expr(R, G, B,"z y max x max", optSingleMode=false)                   # Lightness Hexcone
    Ss = "a 0 == 0 a z y min x min - "+rangePC+" a "+rangePC+" / ? "+rangeTV  # Hexagonal Chroma
    Hs = "60       a z y min x min - "+rangePC+" S@ / D^
          a 0 == S a / 0 == or 0
          x a == y z - "+rangePC+" D * 360 + 360 %
          y a == z x - "+rangePC+" D * 120 + 360 %
          z a == x y - "+rangePC+" D * 240 + 360 % 0 ? ? ? ? 0.002777778 range_max * * "

    if (isy) {

        S = Expr(R, G, B, V, Ss, optSingleMode=false)
        H = Expr(R, G, B, V, Hs, optSingleMode=true)
        [H, S, V]

    } else { Expr(R, G, B, V, Hs, Ss, "a",format=PixelType(RGB), optSingleMode=true) } }


function HSV_to_RGB (clip HSV, clip "S", clip "V", bool "tv_range", bool "fulls") {

    isy = isy(HSV)
    bi  = BitsPerComponent(HSV)

    tv  = Default (tv_range, false)
    fs  = Default (fulls,     true)

    clp = !isy ? ExtractClip(HSV) : nop()
    H   = !isy ? clp[0] :    HSV
    S   = !isy ? clp[1] :     S
    V   = !isy ? clp[2] :      V

    rangePC  = tv ? "ymin - ymax ymin - /" : bi == 32 ? "" : "range_max /"
    rangeTV  = tv ? "ymax ymin - * ymin +" : bi == 32 ? "" : "range_max *"

    m = "0 1 clip 1 -    y "+rangePC+" * 1 + z "+rangePC+" * "+rangeTV
    Rs = "  x "+rangePC+" 6 * 3 - abs 1 - "+m
    Gs = "2 x "+rangePC+" 6 * 2 - abs   - "+m
    Bs = "2 x "+rangePC+" 6 * 4 - abs   - "+m

    if (isy) {

        R = Expr(H, S, V, Rs, optSingleMode=false)
        G = Expr(H, S, V, Gs, optSingleMode=false)
        B = Expr(H, S, V, Bs, optSingleMode=false)
        [R, G, B]

    } else { Expr(H, S, V, Rs, Gs, Bs, format=PixelType(HSV), optSingleMode=true) } }



# RGB linear to IPT (original PT range scaled from -1 +1 to 0 +1)
# Fix some NaN in black areas
function RGB_to_IPT (clip RGB, clip "G", clip "B", bool "Jch", string "matrix", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)

    mat = Default (matrix, "Rec709")
    cy  = Default (Jch,      false)    # enable to convert to JCh (cylindrical IPT) in the range 0 to 1.
    fs  = Default (fulls,     true)

    mat = Color_Fuzzy_search(mat)
    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    LMS = [0.4002, 0.7075, -0.0807, \
          -0.2280, 1.1500,  0.0612, \
           0.0000, 0.0000,  0.9184]

    IPT = [0.4000,  4.4550,  0.8056, \
           0.4000, -4.8510,  0.3572, \
           0.2000,  0.3960, -1.1628]

    mata = RGB_to_XYZ (R, mat[0], list=true)
    LMS  = MatrixTranspose(LMS)
    LMS  = MatrixDot(mata, LMS)
    b32m = bi == 32 ? "" : ex_dlut(" range_max *", bi, fs)
    b32d = bi == 32 ? "" : ex_dlut( "range_max /", bi, fs)

    L = Expr(R,G,B, "x "+b32d+" "+string(LMS[0])+" * y "+b32d+" "+string(LMS[3])+" * + z "+b32d+" "+string(LMS[6])+" * + dup dup 0 >= swap 0.43 ^ swap neg 0.43 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
    M = Expr(R,G,B, "x "+b32d+" "+string(LMS[1])+" * y "+b32d+" "+string(LMS[4])+" * + z "+b32d+" "+string(LMS[7])+" * + dup dup 0 >= swap 0.43 ^ swap neg 0.43 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
    S = Expr(R,G,B, "x "+b32d+" "+string(LMS[2])+" * y "+b32d+" "+string(LMS[5])+" * + z "+b32d+" "+string(LMS[8])+" * + dup dup 0 >= swap 0.43 ^ swap neg 0.43 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")

        Is  = " x "+b32d+" "+string(IPT[0])+" * y "+b32d+" "+string(IPT[3])+" * + z "+b32d+" "+string(IPT[6])+" * +"+b32m
        I   = isy ? Expr(L,M,S, Is, optSingleMode=true) : nop()

    if (!cy) {

        Ps  = " x "+b32d+" "+string(IPT[1])+" * y "+b32d+" "+string(IPT[4])+" * + z "+b32d+" "+string(IPT[7])+" * + 1 + 0.5 *"+b32m
        Ts  = " x "+b32d+" "+string(IPT[2])+" * y "+b32d+" "+string(IPT[5])+" * + z "+b32d+" "+string(IPT[8])+" * + 1 + 0.5 *"+b32m

        if (isy) {

            P  = Expr(L,M,S, Ps, optSingleMode=true)
            T  = Expr(L,M,S, Ts, optSingleMode=true)
            [I, P, T]

        } else { Expr(L,M,S, Is, Ps, Ts, format=PixelType(RGB), optSingleMode=true) }

    } else {

        Cs  = " x "+b32d+" X@ "+string(IPT[1])+" * y "+b32d+" Y@ "+string(IPT[4])+" * + z "+b32d+" Z@ "+string(IPT[7])+" * + dup *
                X             "+string(IPT[2])+" * Y             "+string(IPT[5])+" * + Z             "+string(IPT[8])+" * + dup * + sqrt pi *"+b32m
        hs  = " x "+b32d+" X@ "+string(IPT[1])+" * y "+b32d+" Y@ "+string(IPT[4])+" * + z "+b32d+" Z@ "+string(IPT[7])+" * +
                X             "+string(IPT[2])+" * Y             "+string(IPT[5])+" * + Z             "+string(IPT[8])+" * + swap atan2 pi + pi 2 * /"+b32m

        if (isy) {

            C  = Expr(L,M,S, Cs, optSingleMode=true)  # maybe normalize with 4.956244 instead
            h  = Expr(L,M,S, hs, optSingleMode=true)
            [I, C, h]

        } else { Expr(L,M,S, Is, Cs, hs, format=PixelType(RGB), optSingleMode=true) } } }



function IPT_to_RGB (clip IPT, clip "P", clip "T", bool "Jch", string "matrix", bool "fulls") {

    isy = isy(IPT)
    bi  = BitsPerComponent(IPT)

    mat = Default (matrix, "Rec709")
    cy  = Default (Jch,      false)   # enable to convert from Jch (cylindrical IPT) in the range 0 to 1.
    fs  = Default (fulls,     true)

    mat = Color_Fuzzy_search(mat)
    clp = !isy ? ExtractClip(IPT) : nop()
    I   = !isy ? clp[0] :    IPT
    P   = !isy ? clp[1] :     P
    T   = !isy ? clp[2] :      T

    IPTm = [0.4000,  4.4550,  0.8056, \
            0.4000, -4.8510,  0.3572, \
            0.2000,  0.3960, -1.1628]

    LMS  = [0.4002, 0.7075, -0.0807, \
           -0.2280, 1.1500,  0.0612, \
            0.0000, 0.0000,  0.9184]

    IPTc  = MatrixInvert(IPTm)

    b32m = bi == 32 ? "" : ex_dlut(" range_max *", bi, fs)
    b32d = bi == 32 ? "" : ex_dlut( "range_max /", bi, fs)
    nm   = !cy ? "2 * 1 -" : ""

    if (!cy) {

        L = Expr(I, P, T, "x "+b32d+" "+string(IPTc[0])+" * y "+b32d+" "+nm+" "+string(IPTc[3])+" * + z "+b32d+" "+nm+" "+string(IPTc[6])+" * + dup dup 0 >= swap 1 0.43 / ^ swap neg 1 0.43 / ^ neg ?"+b32m, optSingleMode=true)
        M = Expr(I, P, T, "x "+b32d+" "+string(IPTc[1])+" * y "+b32d+" "+nm+" "+string(IPTc[4])+" * + z "+b32d+" "+nm+" "+string(IPTc[7])+" * + dup dup 0 >= swap 1 0.43 / ^ swap neg 1 0.43 / ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
        S = Expr(I, P, T, "x "+b32d+" "+string(IPTc[2])+" * y "+b32d+" "+nm+" "+string(IPTc[5])+" * + z "+b32d+" "+nm+" "+string(IPTc[8])+" * + dup dup 0 >= swap 1 0.43 / ^ swap neg 1 0.43 / ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")

    } else {

        L = Expr(I, P, T, "x "+b32d+" "+string(IPTc[0])+" * z "+b32d+" pi 2 * * pi - H@ cos y "+b32d+" pi / Y@ * "+string(IPTc[3])+" * + H sin Y * "+string(IPTc[6])+" * + dup dup 0 >= swap 1 0.43 / ^ swap neg 1 0.43 / ^ neg ?"+b32m, optSingleMode=true)
        M = Expr(I, P, T, "x "+b32d+" "+string(IPTc[1])+" * z "+b32d+" pi 2 * * pi - H@ cos y "+b32d+" pi / Y@ * "+string(IPTc[4])+" * + H sin Y * "+string(IPTc[7])+" * + dup dup 0 >= swap 1 0.43 / ^ swap neg 1 0.43 / ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
        S = Expr(I, P, T, "x "+b32d+" "+string(IPTc[2])+" * z "+b32d+" pi 2 * * pi - H@ cos y "+b32d+" pi / Y@ * "+string(IPTc[5])+" * + H sin Y * "+string(IPTc[8])+" * + dup dup 0 >= swap 1 0.43 / ^ swap neg 1 0.43 / ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
    }

    LMS  = MatrixTranspose(LMS)
    LMS  = MatrixInvert(LMS)
    mata = XYZ_to_RGB (I, mat[0], list=true)
    RGB  = MatrixDot(LMS, mata)

        Rs = "x "+b32d+" "+string(RGB[0])+" * y "+b32d+" "+string(RGB[3])+" * + z "+b32d+" "+string(RGB[6])+" * + "+b32m
        Gs = "x "+b32d+" "+string(RGB[1])+" * y "+b32d+" "+string(RGB[4])+" * + z "+b32d+" "+string(RGB[7])+" * + "+b32m
        Bs = "x "+b32d+" "+string(RGB[2])+" * y "+b32d+" "+string(RGB[5])+" * + z "+b32d+" "+string(RGB[8])+" * + "+b32m

    if (isy) {

        R = Expr(L,M,S, Rs, optSingleMode=false)
        G = Expr(L,M,S, Gs, optSingleMode=false)
        B = Expr(L,M,S, Bs, optSingleMode=false)
        [R, G, B]

    } else { Expr(L,M,S, Rs, Gs, Bs, format=PixelType(IPT), optSingleMode=true) } }



# RGB linear to Oklab (original 'ab' range scaled from -1 +1 to 0 +1)
# Requires 32-bit processing. Fix some NaN in black areas
function RGB_to_Oklab (clip RGB, clip "G", clip "B", bool "Jch", string "matrix", bool "fulls") {

    isy = isy(RGB)
    bi  = BitsPerComponent(RGB)

    mat = Default (matrix, "Rec709")
    cy  = Default (Jch,      false)    # enable to convert to Oklch (cylindrical Oklab) in the range 0 to 1.
    fs  = Default (fulls,     true)

    mat = Color_Fuzzy_search(mat)
    clp = !isy ? ExtractClip(RGB) : nop()
    R   = !isy ? clp[0] :    RGB
    G   = !isy ? clp[1] :     G
    B   = !isy ? clp[2] :      B

    # LMS version matrix of Oklab
    M1 = [0.8189330101, 0.3618667424, -0.1288597137, \
          0.0329845436, 0.9293118715,  0.0361456387, \
          0.0482003018, 0.2643662691,  0.6338517070]

    M2 = [0.2104542553,  0.7936177850, -0.0040720468, \
          1.9779984951, -2.4285922050,  0.4505937099, \
          0.0259040371,  0.7827717662, -0.8086757660]

    mata = RGB_to_XYZ (R, mat[0], list=true)
    M1   = MatrixTranspose(M1)
    LMS  = MatrixDot(mata, M1)
    M2   = MatrixTranspose(M2)

    b32m = bi == 32 ? "" : ex_dlut(" range_max *", bi, fs)
    b32d = bi == 32 ? "" : ex_dlut(" range_max /", bi, fs)

    L = Expr(R,G,B, "x "+b32d+" "+string(LMS[0])+" * y "+b32d+" "+string(LMS[3])+" * + z "+b32d+" "+string(LMS[6])+" * + dup dup 0 >= swap 0.333333333 ^ swap neg 0.333333333 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
    M = Expr(R,G,B, "x "+b32d+" "+string(LMS[1])+" * y "+b32d+" "+string(LMS[4])+" * + z "+b32d+" "+string(LMS[7])+" * + dup dup 0 >= swap 0.333333333 ^ swap neg 0.333333333 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
    S = Expr(R,G,B, "x "+b32d+" "+string(LMS[2])+" * y "+b32d+" "+string(LMS[5])+" * + z "+b32d+" "+string(LMS[8])+" * + dup dup 0 >= swap 0.333333333 ^ swap neg 0.333333333 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")

        Ls  = " x "+b32d+" "+string(M2[0])+" * y "+b32d+" "+string(M2[3])+" * + z "+b32d+" "+string(M2[6])+" * +"+b32m
        Lk  = isy ? Expr(L,M,S, Ls, optSingleMode=true) : nop()

    if (!cy) {

        as  = " x "+b32d+" "+string(M2[1])+" * y "+b32d+" "+string(M2[4])+" * + z "+b32d+" "+string(M2[7])+" * + 1 + 0.5 *"+b32m
        bs  = " x "+b32d+" "+string(M2[2])+" * y "+b32d+" "+string(M2[5])+" * + z "+b32d+" "+string(M2[8])+" * + 1 + 0.5 *"+b32m

        if (isy) {

            a   = Expr(L,M,S, as, optSingleMode=true)
            b   = Expr(L,M,S, bs, optSingleMode=true)
            [Lk, a, b]

        } else { Expr(L,M,S, Ls, as, bs, format=PixelType(RGB), optSingleMode=true) }

    } else {

        Cs  = " x "+b32d+" X@ "+string(M2[1])+" * y "+b32d+" Y@ "+string(M2[4])+" * + z "+b32d+" Z@ "+string(M2[7])+" * + dup *
                X             "+string(M2[2])+" * Y             "+string(M2[5])+" * + Z             "+string(M2[8])+" * + dup * + sqrt pi *"+b32m
        hs  = " x "+b32d+" X@ "+string(M2[1])+" * y "+b32d+" Y@ "+string(M2[4])+" * + z "+b32d+" Z@ "+string(M2[7])+" * +
                X             "+string(M2[2])+" * Y             "+string(M2[5])+" * + Z             "+string(M2[8])+" * + swap atan2 pi + pi 2 * /"+b32m

        if (isy) {

            C  = Expr(L,M,S, Cs, optSingleMode=true)
            h  = Expr(L,M,S, hs, optSingleMode=true)
            [Lk, C, h]

        } else { Expr(L,M,S, Ls, Cs, hs, format=PixelType(RGB), optSingleMode=true) } } }



function Oklab_to_RGB (clip Lab, clip "a", clip "b", bool "Jch", string "matrix", bool "fulls") {

    isy = isy(Lab)
    bi  = BitsPerComponent(Lab)

    mat = Default (matrix, "Rec709")
    cy  = Default (Jch,      false)   # enable to convert from OkLch (cylindrical OkLab) in the range 0 to 1.
    fs  = Default (fulls,     true)

    mat = Color_Fuzzy_search(mat)
    clp = !isy ? ExtractClip(Lab) : nop()
    Lk  = !isy ? clp[0] :    Lab
    a   = !isy ? clp[1] :     a
    b   = !isy ? clp[2] :      b

    # LMS matrix version of Oklab
    M1 = [0.8189330101, 0.3618667424, -0.1288597137, \
          0.0329845436, 0.9293118715,  0.0361456387, \
          0.0482003018, 0.2643662691,  0.6338517070]

    M2 = [0.2104542553,  0.7936177850, -0.0040720468, \
          1.9779984951, -2.4285922050,  0.4505937099, \
          0.0259040371,  0.7827717662, -0.8086757660]

    M2   = MatrixTranspose(M2)
    Labc = MatrixInvert(M2)

    b32m = bi == 32 ? "" : ex_dlut(" range_max *", bi, fs)
    b32d = bi == 32 ? "" : ex_dlut( "range_max /", bi, fs)
    nm   = !cy ? "2 * 1 -" : ""

    if (!cy) {

        L = Expr(Lk, a, b, "x "+b32d+" "+string(Labc[0])+" * y "+b32d+" "+nm+" "+string(Labc[3])+" * + z "+b32d+" "+nm+" "+string(Labc[6])+" * + dup dup 0 >= swap 3 ^ swap neg 3 ^ neg ?"+b32m, optSingleMode=true)
        M = Expr(Lk, a, b, "x "+b32d+" "+string(Labc[1])+" * y "+b32d+" "+nm+" "+string(Labc[4])+" * + z "+b32d+" "+nm+" "+string(Labc[7])+" * + dup dup 0 >= swap 3 ^ swap neg 3 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
        S = Expr(Lk, a, b, "x "+b32d+" "+string(Labc[2])+" * y "+b32d+" "+nm+" "+string(Labc[5])+" * + z "+b32d+" "+nm+" "+string(Labc[8])+" * + dup dup 0 >= swap 3 ^ swap neg 3 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")

    } else {

        L = Expr(Lk, a, b, "x "+b32d+" "+string(Labc[0])+" * z "+b32d+" pi 2 * * pi - H@ cos y "+b32d+" pi / Y@ * "+string(Labc[3])+" * + H sin Y * "+string(Labc[6])+" * + dup dup 0 >= swap 3 ^ swap neg 3 ^ neg ?"+b32m, optSingleMode=true)
        M = Expr(Lk, a, b, "x "+b32d+" "+string(Labc[1])+" * z "+b32d+" pi 2 * * pi - H@ cos y "+b32d+" pi / Y@ * "+string(Labc[4])+" * + H sin Y * "+string(Labc[7])+" * + dup dup 0 >= swap 3 ^ swap neg 3 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
        S = Expr(Lk, a, b, "x "+b32d+" "+string(Labc[2])+" * z "+b32d+" pi 2 * * pi - H@ cos y "+b32d+" pi / Y@ * "+string(Labc[5])+" * + H sin Y * "+string(Labc[8])+" * + dup dup 0 >= swap 3 ^ swap neg 3 ^ neg ?"+b32m, optSingleMode=true,scale_inputs="none")
    }

    M1   = MatrixTranspose(M1)
    XYZ  = MatrixInvert(M1)
    mata = XYZ_to_RGB(Lk, mat[0], list=true)
    RGB  = MatrixDot(XYZ, mata)

        Rs = "x "+b32d+" "+string(RGB[0])+" * y "+b32d+" "+string(RGB[3])+" * + z "+b32d+" "+string(RGB[6])+" * + "+b32m
        Gs = "x "+b32d+" "+string(RGB[1])+" * y "+b32d+" "+string(RGB[4])+" * + z "+b32d+" "+string(RGB[7])+" * + "+b32m
        Bs = "x "+b32d+" "+string(RGB[2])+" * y "+b32d+" "+string(RGB[5])+" * + z "+b32d+" "+string(RGB[8])+" * + "+b32m

    if (isy) {

        R = Expr(L,M,S, Rs, optSingleMode=true)
        G = Expr(L,M,S, Gs, optSingleMode=true)
        B = Expr(L,M,S, Bs, optSingleMode=true)
        [R, G, B]

    } else { Expr(L,M,S, Rs, Gs, Bs, format=PixelType(Lab), optSingleMode=true) } }




####### FUNCTION TRANSFORMS #######


# OETF. Monitor Curve Functions: https://github.com/ampas/aces-dev
function moncurve_f (clip c, float "gamma", float "alpha", bool "tv_range_in", bool "tv_range_out", int "UV") {

    c
    rgb = IsRGB()
    isy = isy()
    bi  = BitsPerComponent()
    fs  = propNumElements("_ColorRange")  > 0 ? \
          propGetInt     ("_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    gamma  = Default(gamma, 1/0.45)       # gamma
    alpha  = Default(alpha,   0.0 )       # extension in x coords of the linear part
    tv_in  = Default(tv_range_in,    !fs)
    tv_out = Default(tv_range_out, tv_in)
    UV     = Default(UV, rgb ? 3 : 1 )    # Chroma planes TV<->PC conversion or not

    scl = tv_in!=tv_out && ( 8 < bi < 32) ? string(!tv_out ? 257/256. : 256/257.)+" *" : ""

    rangePC =         tv_in  ? "ymin - ymax ymin - /"  : bi==32 ? "" : "range_max /"
    rangeTV = ex_dlut(tv_out ? "ymax ymin - * ymin +"  : bi==32 ? "" : "range_max *", bi, !tv_out)

    beta   = (( gamma - 1.0) / alpha) * pow( alpha * gamma / ( ( gamma - 1.0) * ( 1.0 + alpha)), gamma)
    phi    = alpha / ( gamma - 1.0)
    aplus  = 1 / (1. + alpha)
    eps    = 8 < bi < 32 ? "0.001 -" : ""

    str    = alpha > 0.0 ? Format("range_min x "+rangePC+" max A@ {phi} > A {alpha} + {aplus} * {gamma} ^ A {beta} * ? "+rangeTV) : \
                           Format("range_min x "+rangePC+" "+eps+" max {gamma} ^ "+rangeTV+"")

    str    =        ex_dlut( str, bi,!tv_in)
    cstr   = !rgb ? ex_dlut(tv_in && !tv_out ? "x cmin - range_max cmax cmin - / * "     : \
                           !tv_in &&  tv_out ? "x cmax cmin - range_max / * cmin + "+scl : "", bi, !tv_in) : str

    gamma <= 1.0 ? last                                                                                   : \
    isy          ? Expr(str                                                                    , lut=lut) : \
    UV == 1      ? Expr(str, ""                                                                , lut=lut) : \
                   Expr(str, ex_UVexpr(cstr, UV, bi, rgb, !tv_in), scale_inputs=ex_UVf(rgb, bi), lut=lut)
    tv_in!=tv_out? PropSet("_ColorRange", tv_out?1:0)                                                     : last }


# EOTF. Monitor Curve Functions: https://github.com/ampas/aces-dev
function moncurve_r (clip c, float "gamma", float "alpha", bool "tv_range_in", bool "tv_range_out", int "UV") {

    c
    rgb = IsRGB()
    isy = isy()
    bi  = BitsPerComponent()
    fs  = propNumElements("_ColorRange")  > 0 ? \
          propGetInt     ("_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    gamma  = Default(gamma, 1/0.45)       # gamma
    alpha  = Default(alpha,   0.0 )       # extension in x coords of the linear part
    tv_in  = Default(tv_range_in,    !fs)
    tv_out = Default(tv_range_out, tv_in)
    UV     = Default(UV, rgb ? 3 : 1 )    # Chroma planes TV<->PC conversion or not

    scl = tv_in!=tv_out && ( 8 < bi < 32) ? string(!tv_out ? 257/256. : 256/257.)+" *" : ""

    rangePC =         tv_in  ? "ymin - ymax ymin - /"  : bi==32 ? "" : "range_max /"
    rangeTV = ex_dlut(tv_out ? "ymax ymin - * ymin +"  : bi==32 ? "" : "range_max *", bi, !tv_out)

    beta   = pow( alpha * gamma / ( ( gamma - 1.0) * ( 1.0 + alpha)), gamma)
    phi    = pow( ( gamma - 1.0) / alpha, gamma - 1.0) * pow( ( 1.0 + alpha) / gamma, gamma)
    igam   = 1. / gamma
    aplus  = 1. + alpha

    str    = alpha > 0.0 ? Format("range_min x "+rangePC+" max A@ {beta} > {aplus} A {igam} ^ * {alpha} - A {phi} * ? "+rangeTV) : \
                           Format("range_min x "+rangePC+" max {igam} ^ "+rangeTV+"")

    str    =        ex_dlut( str, bi,!tv_in)
    cstr   = !rgb ? ex_dlut(tv_in && !tv_out ? "x cmin - range_max cmax cmin - / * "     : \
                           !tv_in &&  tv_out ? "x cmax cmin - range_max / * cmin + "+scl : "", bi, !tv_in) : str

    gamma <= 1.0 ? last                                                                                   : \
    isy          ? Expr(str                                                                    , lut=lut) : \
    UV == 1      ? Expr(str, ""                                                                , lut=lut) : \
                   Expr(str, ex_UVexpr(cstr, UV, bi, rgb, !tv_in), scale_inputs=ex_UVf(rgb, bi), lut=lut)
    tv_in!=tv_out? PropSet("_ColorRange", tv_out?1:0)                                                     : last }


# Linear to ACEScct: https://github.com/ampas/aces-dev
function ACEScct_f (clip c, bool "tv_range_in", bool "tv_range_out", int "UV") {

    c
    rgb = IsRGB()
    isy = isy()
    bi  = BitsPerComponent()
    fs  = propNumElements("_ColorRange")  > 0 ? \
          propGetInt     ("_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    tv_in  = Default(tv_range_in,     !fs)
    tv_out = Default(tv_range_out,  tv_in)
    UV     = Default(UV, rgb ? 3 : 1 )

    scl    = tv_in!=tv_out && ( 8 < bi < 32) ? string(!tv_out ? 257/256. : 256/257.)+" *" : ""

    rangePC =         tv_in  ? "ymin - ymax ymin - /"  : bi==32 ? "" : "range_max /"
    rangeTV = ex_dlut(tv_out ? "ymax ymin - * ymin +"  : bi==32 ? "" : "range_max *", bi, !tv_out)

    X_BRK  = 0.0078125
    coeffA = 10.5402377416545
    coeffB = 0.0729055341958355
    lb     = 1. / log(2)
    coeffC = 1 / 17.52

    str    = Format("x "+rangePC+" A@ {X_BRK} <= A {coeffA} * {coeffB} + A log {lb} * 9.72 + {coeffC} * ? "+rangeTV)

    str    =        ex_dlut( str, bi,!tv_in)
    cstr   = !rgb ? ex_dlut(tv_in && !tv_out ? "x cmin - range_max cmax cmin - / * "     : \
                           !tv_in &&  tv_out ? "x cmax cmin - range_max / * cmin + "+scl : "", bi, !tv_in) : str

    isy     ?      Expr(str                                                                    , lut=lut) : \
    UV == 1 ?      Expr(str, ""                                                                , lut=lut) : \
                   Expr(str, ex_UVexpr(cstr, UV, bi, rgb, !tv_in), scale_inputs=ex_UVf(rgb, bi), lut=lut)
    tv_in!=tv_out? PropSet("_ColorRange", tv_out?1:0)                                                     : last }


# ACEScct to Linear: https://github.com/ampas/aces-dev
function ACEScct_r (clip c, bool "tv_range_in", bool "tv_range_out", int "UV") {

    c
    rgb = IsRGB()
    isy = isy()
    bi  = BitsPerComponent()
    fs  = propNumElements("_ColorRange")  > 0 ? \
          propGetInt     ("_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    tv_in  = Default(tv_range_in,    !fs)
    tv_out = Default(tv_range_out, tv_in)
    UV     = Default(UV, rgb ? 3 : 1 )

    scl    = tv_in!=tv_out && ( 8 < bi < 32) ? string(!tv_out ? 257/256. : 256/257.)+" *" : ""

    rangePC =         tv_in  ? "ymin - ymax ymin - /"  : bi==32 ? "" : "range_max /"
    rangeTV = ex_dlut(tv_out ? "ymax ymin - * ymin +"  : bi==32 ? "" : "range_max *", bi, !tv_out)

    Y_BRK  = 0.155251141552511
    coeffA = 1 / 10.5402377416545
    coeffB = 0.0729055341958355

    str    = Format("x "+rangePC+" A@ {Y_BRK} > 2 A 17.52 * 9.72 - ^ A {coeffB} - {coeffA} * ? "+rangeTV)

    str    =        ex_dlut( str, bi,!tv_in)
    cstr   = !rgb ? ex_dlut(tv_in && !tv_out ? "x cmin - range_max cmax cmin - / * "     : \
                           !tv_in &&  tv_out ? "x cmax cmin - range_max / * cmin + "+scl : "", bi, !tv_in) : str

    isy     ?      Expr(str                                                                    , lut=lut) : \
    UV == 1 ?      Expr(str, ""                                                                , lut=lut) : \
                   Expr(str, ex_UVexpr(cstr, UV, bi, rgb, !tv_in), scale_inputs=ex_UVf(rgb, bi), lut=lut)
    tv_in!=tv_out? PropSet("_ColorRange", tv_out?1:0)                                                     : last }


# Other names:  Broadcast Safe, Studio Swing, Limited/Narrow/Video/Head/TV range.
# For opposite: Full Swing, Full/Data/CG/RGB/PC range.
# Other:        SMPTE+, Extended Range (Ocassional case for 10-bit (64-1023) narrow blacks+full whites used for HLG)
function SMPTE_legal (clip a, bool "forward", int "Y", int "UV", bool "fulls", bool "fulld") {

    rgb = isRGB(a)
    yuv = isYUV(a) # as in !isy && !rgb
    isy = isy(a)
    bi  = BitsPerComponent(a)
    fs  = propNumElements (a,"_ColorRange")  > 0 ? \
          propGetInt      (a,"_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    fw  = Default(forward,  fs)     # forward converts to SMPTE legal, otherwise converts to Full Range.
    Y   = Default(Y,            3 )
    UV  = Default(UV, isy ? 1 : 3 )
    fi  = Defined(fulls) || Defined(fulld)
    fs  = Default(fulls,    fs)
    fd  = Default(fulld,   !fw)

    if (fi && fs!=fd) {
        scl = fs!=fd && ( 8 < bi < 32) ? string(fd ? 257/256. : 256/257.)+" *" : ""

        str  = fw ? "x ymax ymin - range_max / * ymin  + "+scl : \
                    "x ymin - range_max ymax ymin - / *  "

        cstr = fw ? "x cmax cmin - range_max / * cmin  + "+scl : \
                    "x cmin - range_max cmax cmin - / *  "

        str  =        ex_dlut( ex_Yexpr(  str,  Y, bi, rgb, fs), bi, fs)
        cstr = !rgb ? ex_dlut( ex_UVexpr(cstr, UV, bi, rgb, fs), bi, fs) : str

        isy     ? Expr(a, str                                    , lut=lut) : \
        UV == 1 ? Expr(a, str, ""                                , lut=lut) : \
                  Expr(a, str, cstr, scale_inputs=ex_UVf(rgb, bi), lut=lut)
                  PropSet("_ColorRange", fw?1:0)
    } else {
        ConvertBits(a, bi, fulls=fw, fulld=!fw)
        Y == 3 && UV != 3 && yuv ? mergechroma(a) : \
        Y != 3 && UV == 3 && yuv ? mergeluma  (a) : \
        Y != 3 && UV != 3        ?             a  : last } } # faster than CombinePlanes()


# For fixing purposes. To convert from bitshift scale to fullscale and reverse (no range conversion, as in TV to PC levels)
function Full_scale (clip a, bool "forward", int "Y", int "UV") {

    rgb = isRGB(a)
    isy = isy(a)
    bi  = BitsPerComponent(a)
    fsd = propNumElements (a,"_ColorRange")  > 0
    fs  = fsd                                    ? \
          propGetInt      (a,"_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    fw  = Default(forward,     !fs) # forward converts to full scale, otherwise converts to bitshift scale
    Y   = Default(Y,            3 )
    UV  = Default(UV, isy ? 1 : 3 )

    scl = fw ? 257/256. : 256/257.

    str  = Format("x {scl} *")
    cstr = !rgb ? ex_dlut( ex_UVexpr( str, UV, bi, rgb, fs), bi, fs) : str
    str  =        ex_dlut( ex_Yexpr(  str,  Y, bi, rgb, fs), bi, fs)

    !(8 < bi < 32) ?      a                                                    : \
    isy            ? Expr(a, str                                    , lut=lut) : \
    UV == 1        ? Expr(a, str, ""                                , lut=lut) : \
                     Expr(a, str, cstr, scale_inputs=ex_UVf(rgb, bi), lut=lut)
    !fsd           ? PropSet("_ColorRange", !fw?1:0)                           : last }


# SoftLimiter (27-11-2021)
#
# SoftLimiter is an inclusive limiter, it brings clips with under or overshoot values to in-range legal broadcast values
# It does so in a gentle manner by rolling off the values into range without altering the clip's levels and then clipping leftovers.
# RGB is not yet supported.
#
# Disclaimer1: This is not a range conversion filter! Input is assumed to be "legal/tv range"
# Disclaimer2: For static mode, first find the under and overshoot values by inspecting the clip with show=true
#
# Dependencies: ExTools
#               ResizersPack (for show)
#
# Examples:
#   SoftLimiter(16,235)        # no rolloff (straight clamp), assumes input IS legal (within 16,235)
#   SoftLimiter(12,240,12,245) # Bring specified values to legal range with rolloff
#
# modes:
# dyn = 0  -> static mode, set values after manual inspection
# dyn = 1  -> accumulative loose  dynamic mode. Very conservative, for set and forget (after proper cropping black borders)
# dyn = 2  ->              loose  dynamic mode. Medium,         will bring some values into range (recommended)
# dyn = 3  ->              strict dynamic mode. Very sensitive, will bring many values into range
#
function SoftLimiter (clip a, float "lo", float "hi", float "lo_c", float "hi_c", int "tolerance", int "dyn", bool "show", int "UV") {

    rgb = isRGB(a)
    isy = isy(a)
    bi  = BitsPerComponent(a)
    fs  = propNumElements (a,"_ColorRange")  > 0 ? \
          propGetInt      (a,"_ColorRange") == 0 : rgb
    lut = bi == 32 ? 0 : 1

    lo  = Default(lo,      16)   # Low  limit
    hi  = Default(hi,     235)   # High limit
    loc = Default(lo_c,    lo)   # Low  limit (Chroma)
    hic = Default(hi_c,   240)   # High limit (Chroma)
    tol = Default(tolerance,0)   # 0-100 Percentage of allowed under/overshoot
    dyn = Default(dyn,      0)   # 0: static  1: accumulated loose (min/max 0.454% ignored)  2: medium (min/max 0.2% ignored)  3: strict (min/max 0.1% ignored)
    dg  = Default(show, false)
    UV  = Default(UV, isy ? 1 : 3 )

    lo  = min(16, max(0,   lo))   loc  = min(16, max(0,   loc))
    hi  = min(255,max(235, hi))   hic  = min(255,max(240, hic))

    if (tol > 0) {
    pc  = tol/100.
    lo  = lo + ((16-lo)  * pc)    loc  = loc + ((16-loc)  * pc)
    hi  = hi - ((hi-235) * pc)    hic  = hic - ((hic-240) * pc)
    }

    lo0 = lo == 16                loc0 = loc == 16
    hi0 = hi == 235               hic0 = hic == 240


    if (dg) {

        a.ConvertBits(8, dither=1, fulls=fs)
        w    = Width()
        h    = Height()
        w4   = nmod(w/4.)
        h2   = nmod(h/2.)
        w2   = w4*2
        n4   = min(w4,h2)
        padw = (w4-n4)/2
        padh = (h2-n4)/2
        lo   = ex_bs(lo,  8, bi, fs)
        loc  = ex_bs(loc, 8, bi, fs)
        loc  = bi > 16 ? loc - 0.5 : loc
        hi   = ex_bs(hi,  8, bi, fs)
        hic  = ex_bs(hic, 8, bi, fs)
        hic  = bi > 16 ? hic - 0.5 : hic

        b = StackHorizontal( \
            Histogram("levels").blackmanresize(w4,h2,w,0,256,256), \
            Histogram("color2").blackmanresize(n4,n4,w,0,256,256).AddBorders(padw+padw%2, padh+padh%2, padw-padw%2, padh-padh%2) )

        c = StackVertical( \
            a.Limiter(lo, hi, loc, hic, "luma_grey"  ).Subtitle("Luma Spill"  , align=7, size=30), \
            a.Limiter(lo, hi, loc, hic, "chroma_grey").Subtitle("Chroma Spill", align=7, size=30) ).BicubicResize(w2,h2*2,-0.5,0.25).ConvertBits(8, dither=1, fulls=fs)

        d = TurnRight().Histogram(mode="classic").BilinearResize(h2,w2,src_left=h2*2,src_width=-0).TurnLeft()

        s = StackHorizontal(StackVertical(d, b), c).PadResize(w, h ).ConvertBits(bi, fulls=fs)
    }


    if (dyn > 0) {
        a
        ab = removegrain(12,UV==3?12:-1)
        th = dyn > 2 ? 0.1 : dyn > 1 ? 0.2 : 0.454
        PS = "Y  = PlaneMinMaxStats(ab, th, 0, 0, false)
              U  = PlaneMinMaxStats(ab, th, 0, 1, false)
              V  = PlaneMinMaxStats(ab, th, 0, 2, false)
              Y1 = ex_bs(Y[2], bi, 8, fs, float=true) Y2 = ex_bs(Y[3], bi, 8, fs, float=true)
              U1 = ex_bs(U[2], bi, 8, fs, float=true) U2 = ex_bs(U[3], bi, 8, fs, float=true)
              V1 = ex_bs(V[2], bi, 8, fs, float=true) V2 = ex_bs(V[3], bi, 8, fs, float=true)"

        if (dg) {
            ScriptClip( function [ab,bi,fs,th,PS] () {
            Eval(PS)
            fl = "%0.2f"
            Subtitle("YMin: "+string(Y1, fl)+"     "+"YMax: "+string(Y2, fl)+"     "+"UVMin: "+string((U1+V1)/2., fl)+"     "+"UVMax: "+string((U2+V2)/2., fl), align=1) }, after_frame=true )
            StackVertical(last, s)
        } else {
            ScriptClip( function [ab,bi,fs,th,tol,uv,PS] () {
            Eval(PS)
            SoftLimiter(Y1, Y2, (U1+V1)/2., (U2+V2)/2., tol, 0, false, uv) }, after_frame=true )
        }

    } else {

    if (dg) { StackVertical(a, s) }
    else {

        lol  = ex_bs(16,  8, bi, fs)
        hil  = ex_bs(235, 8, bi, fs)
        hicl = ex_bs(240, 8, bi, fs)

    if (lo0 && loc0 && hi0 && hic0) {

        limiter(a, lol,hil,bi>16?lol-0.5:lol,bi>16?hicl-0.5:hicl)

    } else {

        b = spline(hi,  236,-0.44, 237,-0.815, 238,-1.131, 239,-1.396, 240,-1.617, 241,-1.8, 242,-1.951, 243,-2.073, 244,-2.17, 245,-2.247, 246,-2.305, 247,-2.348, 248,-2.378, 249,-2.397, 250,-2.4065, 251,-2.408, 252,-2.408, 253,-2.408, 254,-2.4078, 255,-2.4077)
        c = spline(hic, 236,-0.44, 237,-0.815, 238,-1.131, 239,-1.396, 240,-1.617, 241,-1.8, 242,-1.951, 243,-2.073, 244,-2.17, 245,-2.247, 246,-2.305, 247,-2.348, 248,-2.378, 249,-2.397, 250,-2.4065, 251,-2.408, 252,-2.408, 253,-2.408, 254,-2.4078, 255,-2.4077)
        d = spline(lo,  0,-1.871, 1,-1.861, 2,-1.845, 3,-1.8215, 4,-1.7905, 5,-1.7495, 6,-1.697, 7,-1.6325, 8,-1.552, 9,-1.454, 10,-1.3365, 11,-1.195, 12,-1.028, 13,-0.829, 14,-0.595, 15,-0.321)
        e = spline(loc, 0,-1.871, 1,-1.861, 2,-1.845, 3,-1.8215, 4,-1.7905, 5,-1.7495, 6,-1.697, 7,-1.6325, 8,-1.552, 9,-1.454, 10,-1.3365, 11,-1.195, 12,-1.028, 13,-0.829, 14,-0.595, 15,-0.321)

        phi = 20
        phr = 1./phi
        bi32m = bi == 32 ? "" : " range_max *"
        bi32d = bi == 32 ? "" : " range_max /"

        hi  = Format("    x "+bi32d+"   dup log {phi} * exp 1 + log {phr} {b} * * "+expT(1)+" *  ")
        lo  = Format("1 1 x "+bi32d+" - dup log {phi} * exp 1 + log {phr} {d} * * "+expT(1)+" * -")
        hic = Format("    x "+bi32d+"   dup log {phi} * exp 1 + log {phr} {c} * * "+expT(1)+" *  ")
        loc = Format("1 1 x "+bi32d+" - dup log {phi} * exp 1 + log {phr} {e} * * "+expT(1)+" * -")

        str  = (lo0  && hi0  ? "x " :  (lo0  && !hi0  ? hi  : !lo0  && hi0  ? lo  : "x range_half > "+hi +" "+lo +" ?") + bi32m) + Format(" {lol} {hil}  clip") # still need to account for 'tolerance'
        cstr =  loc0 && hic0 ? "x " : ((loc0 && !hic0 ? hic : !loc0 && hic0 ? loc : "x range_half > "+hic+" "+loc+" ?") + bi32m  + Format(" {lol} {hicl} clip"))


        str  =        ex_dlut( str,                              bi, fs)
        cstr = !rgb ? ex_dlut( ex_UVexpr(cstr, UV, bi, rgb, fs), bi, fs) : str

        isy     ? Expr(a, str                                    , lut=lut) : \
        UV == 1 ? Expr(a, str, ""                                , lut=lut) : \
                  Expr(a, str, cstr, scale_inputs=ex_UVf(rgb, bi), lut=lut) } } } }






####### DATA RETRIEVAL FUNCTIONS #######



# Matrix, Primaries, Illuminant and Transfer fuzzy search. Input: string, Output: [string, ID]
function Color_Fuzzy_search (string matrix) {

    matrix = UCase(matrix)
    matrixn =
\     (FindStr(matrix,"709" )>0 ) ? "Rec709"
\   : (matrix == "HDTV"         ) ? "Rec709"
\   : (matrix == "sRGB"         ) ? "sRGB"
\   : (matrix == "XYZ"          ) ? "XYZ"
\   : (matrix == "SDTV"         ) ? "170M"
\   : (FindStr(matrix, "274")>0 ) ? "170M"
\   : (FindStr(matrix, "601")>0 ) ? "170M"
\   : (FindStr(matrix, "525")>0 ) ? "170M"
\   : (FindStr(matrix, "170")>0 ) ? "170M"
\   : (matrix == "jpeg"         ) ? "170M"
\   : (matrix == "jpg"          ) ? "170M"
\   : (matrix == "NTSC"         ) ? "170M"
\   : (matrix == "SMPTE-C"      ) ? "170M"
\   : (matrix == "YPbPr"        ) ? "170M"
\   : (matrix == "YCC"          ) ? "Rec709"
\   : (matrix == "YUV"          ) ? "Rec709"
\   : (matrix == "sYCC"         ) ? "Rec709"
\   : (matrix == "YCbCr"        ) ? "Rec709"
\   : (FindStr(matrix,"NCL"  )>0) ? "Rec2020NCL"
\   : (FindStr(matrix,"20-10")>0) ? "Rec2020NCL"
\   : (FindStr(matrix,"CL"   )>0) ? "Rec2020CL"
\   : (FindStr(matrix,"20-12")>0) ? "Rec2020CL"
\   : (FindStr(matrix,"2020")>0 ) ? "Rec2020NCL"
\   : (FindStr(matrix,"2084")>0 ) ? "Rec2020CL"
\   : (FindStr(matrix,"2100")>0 ) ? "Rec2020CL"
\   : (FindStr(matrix,"DOVI")>0 ) ? "Rec2020DV5"
\   : (FindStr(matrix,"VISION")>0)? "Rec2020DV5"
\   : (FindStr(matrix,"2085")>0 ) ? "YDzDx"
\   : (matrix == "AdobeWideGamut")? "AWG"
\   : (matrix == "AWG"          ) ? "AWG"
\   : (matrix == "Adobe"        ) ? "AdobeRGB"
\   : (matrix == "opRGB"        ) ? "AdobeRGB"
\   : (matrix == "opYCC"        ) ? "AdobeRGB"
\   : (FindStr(matrix, "DCI")>0 ) ? "DCI-P3"
\   : (matrix == "P3"           ) ? "Display-P3"
\   : (matrix == "P3D65"        ) ? "Display-P3"
\   : (FindStr(matrix,"DISPLAY")>0)?"Display-P3"
\   : (matrix == "AP1"          ) ? "ACEScg"
\   : (matrix == "AP0"          ) ? "ACES2065"
\   : (matrix == "ACEScg"       ) ? "ACEScg"
\   : (matrix == "ACESCCt"      ) ? "ACESCCt"
\   : (FindStr(matrix,"ACES2")>0) ? "ACES2065"
\   : (FindStr(matrix, "240")>0 ) ? "240M"
\   : (matrix == "PAL"          ) ? "470BG"
\   : (matrix == "SECAM"        ) ? "470BG"
\   : (matrix == "NTSC-M"       ) ? "470M"
\   : (matrix == "FCC"          ) ? "470M"
\   : (FindStr(matrix,"470M")>0 ) ? "470M"
\   : (FindStr(matrix,"470" )>0 ) ? "470BG"
\   : (FindStr(matrix,"1701")>0 ) ? "470BG"
\   : (FindStr(matrix,"625" )>0 ) ? "470BG"
\   : (matrix == "OPP"          ) ? "OPP"
\   : (matrix == "OOO"          ) ? "OPP" : ""

# * ST2084 or ARIB STD-B67 is the name of the normative/paper not the transfer function
    transfer =
\     (FindStr(matrix,"2084")>0 ) ? "PQ"
\   : (FindStr(matrix,"2100")>0 ) ? "PQ"
\   : (matrix == "PQ"           ) ? "PQ"
\   : (matrix == "Perceptual"   ) ? "PQ"
\   : (matrix == "Rec2020DVp5"  ) ? "PQ"
\   : (matrix == "HLG"          ) ? "HLG"
\   : (FindStr(matrix,"ARIB")>0 ) ? "HLG"
\   : (FindStr(matrix,"B67" )>0 ) ? "HLG"
\   : (FindStr(matrix,"BBC" )>0 ) ? "HLG"
\   : (FindStr(matrix,"NHK" )>0 ) ? "NHK HLG"
\   : (matrix == "1886a"        ) ? "1886a"
\   : (FindStr(matrix,"1886")>0 ) ? "1886"
\   : (FindStr(matrix,"428" )>0 ) ? "DCI-P3"
\   : (matrix == "Camera"       ) ? "170M"
\   : (matrix == "Rec709-Camera") ? "170M"
\   : (matrix == "AWG"          ) ? "AdobeRGB"
\   : (matrix == "XYZ"          ) ? "linear"
\   : (matrix == "linear"       ) ? "linear"
\   : (matrix == "ACEScg"       ) ? "linear"
\   : (matrix == "ACES2065"     ) ? "linear"
\   : (matrix == "ACESCCt"      ) ? "ACESCCt" : matrixn

    illuminant =
\     (matrix == "50"            ) ? "D50"
\   : (matrix == "D50"           ) ? "D50"
\   : (matrix == "55"            ) ? "D55"
\   : (matrix == "D55"           ) ? "D55"
\   : (matrix == "60"            ) ? "D60"
\   : (matrix == "D60"           ) ? "D60"
\   : (matrix == "DCI"           ) ? "DCI"
\   : (matrix == "65"            ) ? "D65"
\   : (matrix == "D65"           ) ? "D65"
\   : (matrix == "75"            ) ? "D75"
\   : (matrix == "D75"           ) ? "D75"
\   : (matrix == "C"             ) ? "C"
\   : (matrix == "93"            ) ? "D93"
\   : (matrix == "D93"           ) ? "D93" : matrixn


    # ID for _Matrix frame properties (BT.2380-2. Table 2.8)
    idm =
\     (matrixn == "XYZ"            ) ? 0
\   : (matrixn == "RGB"            ) ? 0
\   : (matrixn == "sRGB"           ) ? 1
\   : (matrixn == "Rec709"         ) ? 1
\   : (matrixn == "470M"           ) ? 4
\   : (matrixn == "470BG"          ) ? 5
\   : (matrixn == "170M"           ) ? 6
\   : (matrixn == "240M"           ) ? 7
\   : (matrixn == "Rec2020NCL"     ) ? 9
\   : (matrixn == "Rec2020CL"      ) ? 10
\   : (matrixn == "Rec2020"        ) ? 9
\   : (matrixn == "YDzDx"          ) ? 11
\   : (matrixn == "DCI-P3"         ) ? 12
\   : (matrixn == "Display-P3"     ) ? 12
\   : (matrixn == "ACEScg"         ) ? 13
\   : (matrixn == "ACES2065"       ) ? 14
\   : (matrixn == "ACESCCt"        ) ? 15
\   : (matrixn == "AdobeRGB"       ) ? 16
\   : (matrixn == "AWG"            ) ? 17 : -1
# * YDzDx is defined in SMPTE 2085

    # ID for _Primaries frame properties (BT.2380-2. Table 2.6)
    ids =
\     (matrixn == "Rec2020CL"      ) ? 9
\   : (matrixn == "DCI-P3"         ) ? 11 : idm

    idi =
\     (illuminant == "D50"         ) ? 0
\   : (illuminant == "D55"         ) ? 1
\   : (illuminant == "D60"         ) ? 2
\   : (illuminant == "DCI"         ) ? 3
\   : (illuminant == "D65"         ) ? 4
\   : (illuminant == "C"           ) ? 5
\   : (illuminant == "D75"         ) ? 6
\   : (illuminant == "D93"         ) ? 7 : -1

    # ID for _Transfer frame properties (BT.2380-2. Table 2.7)
    idt =
\     (transfer == "1886a"        ) ? 0
\   : (transfer == "1886"         ) ? 1
\   : (transfer == "Rec709"       ) ? 1
\   : (transfer == "470M"         ) ? 4
\   : (transfer == "470BG"        ) ? 5
\   : (transfer == "170M"         ) ? 6
\   : (transfer == "Rec709-Camera") ? 6
\   : (transfer == "240M"         ) ? 7
\   : (transfer == "linear"       ) ? 8
\   : (transfer == "log100"       ) ? 9
\   : (transfer == "log316"       ) ? 10
\   : (transfer == "xvYCC"        ) ? 11
\   : (transfer == "1361"         ) ? 12
\   : (transfer == "sRGB"         ) ? 13
\   : (transfer == "Display-P3"   ) ? 13
\   : (transfer == "Rec2020"      ) ? 14
\   : (transfer == "Rec2020NCL"   ) ? 14
\   : (transfer == "Rec2020CL"    ) ? 15
\   : (transfer == "PQ"           ) ? 16
\   : (transfer == "DCIXYZ"       ) ? 17
\   : (transfer == "HLG"          ) ? 18
\   : (transfer == "NHK HLG"      ) ? 19
\   : (transfer == "AdobeRGB"     ) ? 20
\   : (transfer == "ACESCCt"      ) ? 21 : -1
# * DCIXYZ is defined in smpte428-1. It's XYZ space with DCI white point for cinema distribution in DCDM format

    str = illuminant != "" ? [illuminant,idm,ids,idi,idt] : \
          transfer   != "" ? [transfer,  idm,ids,idi,idt] : \
          matrixn    != "" ? [matrixn,   idm,ids,idi,idt] : ["",-1,-1,-1,-1]

    str }



# Has prevalence over string based Color_fuzzy_search() and Format_fuzzy_search() when input input arg is undefined (ie. for Defaults() )
function color_propGet (clip a) {

    w        = width (a)
    h        = height(a)
    bi       = BitsPerComponent(a)
    isHD     = (w  > 1099 ||  h  >  599)
    isUHD    = (w  > 2599 ||  h  > 1499)

    fmt      = Format_fuzzy_search(a, PixelType(a), bi)
    cm_i     = a.propNumElements("_Model")      > 0 ? PropGetInt(a, "_Model")       : -1
    prim_i   = a.propNumElements("_Primaries")  > 0 ? PropGetInt(a, "_Primaries")   : 2
    illu_i   = a.propNumElements("_Illuminant") > 0 ? PropGetInt(a, "_Illuminant")  : -1
    mat_i    = a.propNumElements("_Matrix")     > 0 ? PropGetInt(a, "_Matrix")      : 2
    t_i      = a.propNumElements("_Transfer")   > 0 ? PropGetInt(a, "_Transfer")    : 2

    # Input Defaults
    cm_i     = cm_i   != -1 ? cm_i   : fmt[4]
    prim_i   = prim_i !=  2 ? prim_i : fmt[6] != -1 ? fmt[6] : isUHD ? 9 : isHD ? 1 : 6
    illu_i   = illu_i != -1 ? illu_i :                             prim_i == 11 ? 3 : prim_i == 13 || prim_i == 14 ? 2 : prim_i == 17 || cm_i == 2 ? 0 : 4
    mat_i    = mat_i  !=  2 ? mat_i  : fmt[5] != -1 ? fmt[5] : 3 < prim_i  < 10 ?  prim_i : cm_i == 15 ? 11 : prim_i == 11 || prim_i == 12  ? 12 : 1
    t_i      = t_i    !=  2 ? t_i    :                         3 < prim_i  < 8  ?  prim_i : \
                                                                   prim_i == 15 ? 21 : \
                                                                   prim_i == 16 || prim_i == 17 ? 20 : \
                                                                   prim_i == 13 || prim_i == 14 || prim_i == 10 || cm_i == 0 || cm_i == 23 ? 8 : \
                                                                   prim_i == 9  ? 16 : \
                                                                   prim_i == 11 ? 21 : \
                                                                   prim_i == 12 ? 13 : \
                                                                   cm_i   == 24 ? 11 : 1
    cm_id =
\     (cm_i == 0      ) ? ["XYZ",      "RGB"  ]
\   : (cm_i == 1      ) ? ["RGB",      "RGB"  ]
\   : (cm_i == 2      ) ? ["CMYK",     "RGBA" ]
\   : (cm_i == 3      ) ? ["YIQ",      "YCbCr"]
\   : (cm_i == 4      ) ? ["YDbDr",    "YCbCr"]
\   : (cm_i == 5      ) ? ["YCbCr",    "YCbCr"]
\   : (cm_i == 6      ) ? ["YUVr",     "YCbCr"]
\   : (cm_i == 7      ) ? ["sYUV",     "YCbCr"]
\   : (cm_i == 8      ) ? ["YUVJ",     "YCbCr"]
\   : (cm_i == 8      ) ? ["sYCC",     "YCbCr"]
\   : (cm_i == 9      ) ? ["YCoCg",    "YCbCr"]
\   : (cm_i == 10     ) ? ["YCoCgR",   "YCbCr"]
\   : (cm_i == 11     ) ? ["YcCbcCr",  "YCbCr"]
\   : (cm_i == 12     ) ? ["OPP",      "RGB"  ]
\   : (cm_i == 13     ) ? ["Jzazbz",   "YCbCr"]
\   : (cm_i == 14     ) ? ["JzCzhz",   "YCbCr"]
\   : (cm_i == 15     ) ? ["YDzDx",    "YCbCr"]
\   : (cm_i == 16     ) ? ["YCxCz",    "YCbCr"]
\   : (cm_i == 17     ) ? ["IPT",      "YCbCr"]
\   : (cm_i == 18     ) ? ["IPTJch",   "YCbCr"]
\   : (cm_i == 19     ) ? ["ICaCb",    "YCbCr"]
\   : (cm_i == 20     ) ? ["ITP",      "YCbCr"]
\   : (cm_i == 21     ) ? ["ICtCp",    "YCbCr"]
\   : (cm_i == 22     ) ? ["IPTPQc2",  "YCbCr"]
\   : (cm_i == 23     ) ? ["Yxy",      "RGB"  ]
\   : (cm_i == 24     ) ? ["xvYCC",    "YCbCr"]
\   : (cm_i == 25     ) ? ["HSV",      "RGB"  ]
\   : (cm_i == 26     ) ? ["HunterLab","YCbCr"]
\   : (cm_i == 27     ) ? ["CIELab",   "YCbCr"]
\   : (cm_i == 28     ) ? ["CIELch",   "RGB"  ]
\   : (cm_i == 29     ) ? ["CIELuv",   "YCbCr"]
\   : (cm_i == 30     ) ? ["CIELchuv", "RGB"  ]
\   : (cm_i == 31     ) ? ["CIEDuDv",  "YCbCr"]
\   : (cm_i == 32     ) ? ["CIECAM97s","YCbCr"]
\   : (cm_i == 33     ) ? ["CIECAM02", "YCbCr"]
\   : (cm_i == 34     ) ? ["CAM16",    "YCbCr"]
\   : (cm_i == 35     ) ? ["Duv",      "YCbCr"]
\   : (cm_i == 36     ) ? ["OSA",      "YCbCr"]
\   : (cm_i == 37     ) ? ["OkLab",    "YCbCr"]
\   : (cm_i == 38     ) ? ["OkLch",    "RGB"  ]
\   : (cm_i == 39     ) ? ["iCAM",     "RGB"  ]
\   : Assert (false, "color_propGet: Unknown _Model ID.")
# * YDbDr is for PAL-N and SECAM
# * xvYCC is defined in IEC61966-2-4

    range    = propNumElements(a,"_ColorRange") > 0 ? PropGetInt(a, "_ColorRange") == 1 : cm_id[1] == "YCbCr"

    # ID for _Primaries frame properties (BT.2380-2. Table 2.6)
    prim_i =
\     (prim_i == 1    ) ? "Rec709"
\   : (prim_i == 4    ) ? "470M"
\   : (prim_i == 5    ) ? "470BG"
\   : (prim_i == 6    ) ? "170M"
\   : (prim_i == 7    ) ? "240M"
\   : (prim_i == 9    ) ? "Rec2020"
\   : (prim_i == 10   ) ? "XYZ"
\   : (prim_i == 11   ) ? "DCI-P3"
\   : (prim_i == 12   ) ? "Display-P3"
\   : (prim_i == 13   ) ? "ACEScg"
\   : (prim_i == 14   ) ? "ACES2065"
\   : (prim_i == 15   ) ? "ACESCCt"
\   : (prim_i == 16   ) ? "AdobeRGB"
\   : (prim_i == 17   ) ? "AWG"
\   : Assert (false, "color_propGet: Unknown _Primaries ID.")

    # ID for _Matrix frame properties (BT.2380-2. Table 2.8)
    mat_i =
\     (mat_i == 0     ) ? "XYZ"
\   : (mat_i == 1     ) ? "Rec709"
\   : (mat_i == 4     ) ? "470M"
\   : (mat_i == 5     ) ? "470BG"
\   : (mat_i == 6     ) ? "170M"
\   : (mat_i == 7     ) ? "240M"
\   : (cm_i  == 8     ) ? "YCoCg"
\   : (mat_i == 9     ) ? "Rec2020"
\   : (mat_i == 10    ) ? "Rec2020CL"
\   : (mat_i == 11    ) ? "YDzDx"
\   : (mat_i == 12    ) ? "DCI-P3"
\   : (mat_i == 12    ) ? "Display-P3"
\   : (mat_i == 14    ) ? "ICtCp"
\   : Assert (false, "color_propGet: Unknown _Matrix ID.")

    illu_i =
\     (illu_i == 0    ) ? "D50"
\   : (illu_i == 1    ) ? "D55"
\   : (illu_i == 2    ) ? "D60"
\   : (illu_i == 3    ) ? "DCI"
\   : (illu_i == 4    ) ? "D65"
\   : (illu_i == 5    ) ? "C"
\   : (illu_i == 6    ) ? "D75"
\   : (illu_i == 7    ) ? "D93"
\   : Assert (false, "color_propGet: Unknown _Illuminant ID.")

    # ID for _Transfer frame properties (BT.2380-2. Table 2.7)
    t_i =
\     (t_i == 0       ) ? "1886a"
\   : (t_i == 1       ) ? "1886"
\   : (t_i == 4       ) ? "470M"
\   : (t_i == 5       ) ? "470BG"
\   : (t_i == 6       ) ? "170M"
\   : (t_i == 7       ) ? "240M"
\   : (t_i == 8       ) ? "linear"
\   : (t_i == 9       ) ? "log100"
\   : (t_i == 10      ) ? "log316"
\   : (t_i == 11      ) ? "xvYCC"
\   : (t_i == 12      ) ? "1361"
\   : (t_i == 13      ) ? "sRGB"
\   : (t_i == 14      ) ? "Rec2020NCL"
\   : (t_i == 15      ) ? "Rec2020CL"
\   : (t_i == 16      ) ? "PQ"
\   : (t_i == 17      ) ? "DCIXYZ"
\   : (t_i == 18      ) ? "HLG"
\   : (t_i == 19      ) ? "NHK HLG"
\   : (t_i == 20      ) ? "AdobeRGB"
\   : (t_i == 21      ) ? "ACESCCt"
\   : Assert (false, "color_propGet: Unknown _Transfer ID.")
# * 1, 14, and 15 share the same function

    # model, packing, prims, illu, matrix, transfer, range
    [cm_id[0],cm_id[1],prim_i,illu_i,mat_i,t_i,range] }



# Jab and Model fuzzy search. Also sets model id and packing format.
function Format_fuzzy_search (clip c, string format, int bits) {

    # Block not evaluated unless Jab enum fails the search
    rgb  = isRGB(c)
    isy  = isy(c)
    Up   = rgb || isy ? c : ExtractU(c)
    rw   = width (Up) / float(width (c))
    rh   = height(Up) / float(height(c))
    a    = int(rw * 4.)
    b    = round(rh-0.01)*a

    str    = ReplaceStr(format, "P8", "")
    str    = ReplaceStr(format, "PS", "")
    trhbd  = FindStr(format,    "P1")
    format = trhbd>0 ? LeftStr(format,trhbd-1) : str


    jab =
\     (FindStr(format,"420"     )>0) ? "420"
\   : (FindStr(format, "42"     )>0) ? "420"
\   : (FindStr(format, "20"     )>0) ? "420"
\   : (FindStr(format, "12"     )>0) ? "420"
\   : (FindStr(format,"444"     )>0) ? "444"
\   : (FindStr(format, "44"     )>0) ? "444"
\   : (FindStr(format, "24"     )>0) ? "444"
\   : (FindStr(format,"422"     )>0) ? "422"
\   : (FindStr(format, "22"     )>0) ? "422"
\   : (FindStr(format, "16"     )>0) ? "422"
\   : (FindStr(format,"411"     )>0) ? "411"
\   : (FindStr(format, "11"     )>0) ? "411"
\   : (FindStr(format,"440"     )>0) ? "440"
\   : (FindStr(format, "40"     )>0) ? "410"
\   : (FindStr(format,"410"     )>0) ? "410"
\   : (FindStr(format, "41"     )>0) ? "410"
\   : (FindStr(format, "10"     )>0) ? "410"
\   : (FindStr(format,"YUV9"    )>0) ? "410"
\
\   : (FindStr(format,"RGB"     )>0) ? "444"
\   : (FindStr(format,"Yxy"     )>0) ? "444"
\   : (FindStr(format,"xyY"     )>0) ? "444"
\   : (        format=="Yxy"       ) ? "444"
\   : (        format=="xyY"       ) ? "444"
\   : (FindStr(format,"XYZ"     )>0) ? "444"
\   : (        format=="XYZ"       ) ? "444"
\   : (FindStr(format,"Jzazbz"  )>0) ? "444"
\   : (FindStr(format,"JzCzhz"  )>0) ? "444"
\   : (FindStr(format,"HSV"     )>0) ? "444"
\   : (        format=="HSV"       ) ? "444"
\   :                "4"+string(a)+string(b)


    model  = UCase(ReplaceStr(format, jab, ""))

    # store all opposing models in YUV format, otherwise (correlated) as RGB
    # Input Model, Name Normalizing, Packing format, model ID
    cm =
\     (FindStr(model, "RGB"    )>0) ? ["RGB",      "RGB",1]
\   : (        model=="JPEG"      ) ? ["YCbCr",    "YUV",5]
\   : (        model=="JPG"       ) ? ["YCbCr",    "YUV",5]
\   : (        model=="YUVJ"      ) ? ["YUVJ",     "YUV",5]
\   : (        model=="YCbCr"     ) ? ["YCbCr",    "YUV",5]
\   : (        model=="YUV"       ) ? ["YCbCr",    "YUV",5]
\   : (FindStr(model, "YV"     )>0) ? ["YCbCr",    "YUV",5]
\   : (FindStr(model, "DV"     )>0) ? ["YCbCr",    "YUV",5]
\   : (        model=="YCC"       ) ? ["YCbCr",    "YUV",5]
\   : (        model=="sYCC"      ) ? ["sYCC",     "YUV",8]
\   : (        model=="YPbPr"     ) ? ["YCbCr",    "YUV",5]
\   : (        model=="YIQ"       ) ? ["YIQ",      "YUV",3]
\   : (        model=="YDbDr"     ) ? ["YDbDr",    "YUV",4]
\   : (        model=="YUVr"      ) ? ["YUVr",     "YUV",6]
\   : (        model=="sYUV"      ) ? ["sYUV",     "YUV",7]
\   : (FindStr(model, "SHARP"  )>0) ? ["sYUV",     "YUV",7]
\   : (        model=="YcCbcCr"   ) ? ["YcCbcCrc", "YUV",11]
\   : (FindStr(model, "YCCBC"  )>0) ? ["YcCbcCrc", "YUV",11]
\   : (        model=="YCgCo"     ) ? ["YCoCg",    "YUV",9]
\   : (        model=="YCgCoR"    ) ? ["YCoCgR",   "YUV",10]
\   : (        model=="YCoCg"     ) ? ["YCoCg",    "YUV",9]
\   : (        model=="YCoCgR"    ) ? ["YCoCgR",   "YUV",10]
\   : (        model=="ICaCb"     ) ? ["ICaCb",    "YUV",19]
\   : (        model=="ICtCp"     ) ? ["ICtCp",    "YUV",21]
\   : (        model=="IPT"       ) ? ["ICtCp",    "YUV",21]
\   : (        model=="YDzDx"     ) ? ["YDzDx",    "YUV",15]
\   : (        model=="YCxCz"     ) ? ["YCxCz",    "YUV",16]
\   : (        model=="xvYCC"     ) ? ["xvYCC",    "YUV",24]
\   : (        model=="Yxy"       ) ? ["Yxy",      "RGB",23]
\   : (        model=="xyY"       ) ? ["Yxy",      "RGB",23]
\   : (        model=="XYZ"       ) ? ["XYZ",      "RGB",0]
\   : (        model=="CIEXYZ"    ) ? ["XYZ",      "RGB",0]
\   : (        model=="YZX"       ) ? ["XYZ",      "RGB",0]
\   : (        model=="CMYK"      ) ? ["CMYK",     "RGBA",2]
\   : (        model=="OPP"       ) ? ["OPP",      "RGB",12]
\   : (        model=="Jzazbz"    ) ? ["Jzazbz",   "YUV",13]
\   : (        model=="JzCzhz"    ) ? ["JzCzhz",   "YUV",14]
\   : (        model=="HSV"       ) ? ["HSV",      "RGB",24]
\   : (        model=="CIEDuv"    ) ? ["Duv",      "YUV",35]
\   : (        model=="Duv"       ) ? ["Duv",      "YUV",35]
\   : (        model=="OSA"       ) ? ["OSA",      "YUV",36]
\   : (FindStr(model, "CAM97"  )>0) ? ["CIECAM97s","YUV",32]
\   : (FindStr(model, "CAM02"  )>0) ? ["CIECAM02", "YUV",33]
\   : (FindStr(model, "CAM16"  )>0) ? ["CAM16 ",   "YUV",34]
\   : (FindStr(model, "HUNTER" )>0) ? ["HunterLab","YUV",26]
\   : (FindStr(model, "OK"     )>0) ? ["OkLab",    "YUV",37]
\   : (FindStr(model, "LUV"    )>0) ? ["CIELuv",   "YUV",29]
\   : (FindStr(model, "LAB"    )>0) ? ["CIELab",   "YUV",27]
\   :                     rgb ? ["RGB","RGB",1] : ["YCbCr","YUV",5]

    # Color Model based Matrix constants (for frameprops)
    ma =
\     (        cm[0]=="RGB"       ) ? 0
\   : (        cm[0]=="XYZ"       ) ? 0
\   : (        cm[0]=="xvYCC"     ) ? 1
\   : (        cm[0]=="YCoCg"     ) ? 8
\   : (        cm[0]=="ICtCp"     ) ? 14 : -1


    # Color Model based Primaries constants (for frameprops)
    pr =
\     (        cm[0]=="sYCC"      ) ? 1
\   : (        cm[0]=="XYZ"       ) ? 10 : -1

    bdpth = isy ? string(bits) : bits < 32 ? "P" + string(bits) : "PS"

    #model, jab, bitdepth type, packing, model ID, matrix ID override, prim ID override
    [cm[0], jab, bdpth, cm[1], cm[2], ma, pr] }



# Bicubic kernels are very performant but tends to 'blocking' in upscales compared to more advanced kernels
function bicubic_coeffs (string kernel) {

    rb  = 12. /(19.  +9.*sqrt(2))    # 0.378216
    rc  = 113./(58.+216.*sqrt(2))    # 0.310892
    rsb = 6.  /(13.  +7.*sqrt(2))    # 0.262015
    rsc = 7.  /(2.  +12.*sqrt(2))    # 0.368993

    # From smoother to sharper
    c = [-1,-1]
    c = kernel == "SoftCubic100"      ? [1.0,0.0]   : c # same as GaussResize(p=21)
    c = kernel == "SoftCubic75"       ? [0.75,0.25] : c
    c = kernel == "BilcubicD"         ? [1/3.,0.0]  : c # dw Bicubic practical match to Bilinear
    c = kernel == "BilcubicU"         ? [0.5, 0.2]  : c # up Bicubic practical match to Bilinear
    c = kernel == "Hermite"           ? [0.0,0.0]   : c # dw Bicubic approximation   to Bilinear (a bit sharper than it)
    c = kernel == "Robidoux"          ? [rb,  rc]   : c
    c = kernel == "Centroid"          ? [0.37,0.35] : c # Arithmetic mean of the satisfactory zone (by Dogway)
    c = kernel == "Mitchell-Netravali"? [1/3.,1/3.] : c # Canonical Bicubic
    c = kernel == "Robidoux Sharp"    ? [rsb,rsc]   : c
    c = kernel == "SoftCubic50"       ? [0.5,0.5]   : c
    c = kernel == "Catmull-Rom"       ? [0.0,0.5]   : c # Canonical sharp Bicubic
    c = kernel == "Didee"             ? [-0.5,0.25] : c # dw Didée's downscaling sharp coefficients
    c = kernel == "Precise Bicubic"   ? [0.0,0.75]  : c
    c = kernel == "Sharp"             ? [0.0,1.0]   : c
    c = kernel == "Hatch"             ? [0.0,-5.0]  : c

    # Aliases
    c = kernel == "SoftCubic"         ? [0.75,0.25] : c
    c = kernel == "Precise"           ? [0.0,0.75]  : c
    c = kernel == "catrom"            ? [0.0,0.5]   : c
    c = kernel == "Catmull"           ? [0.0,0.5]   : c
    c = kernel == "Mitchell"          ? [1/3.,1/3.] : c
    c = kernel == "Mitchel"           ? [1/3.,1/3.] : c
    c = kernel == "RobiSharp"         ? [rsb,rsc]   : c
    c = kernel == "Robi"              ? [rb,  rc]   : c
    c = kernel == "RobidouxSharp"     ? [rsb,rsc]   : c
    c = kernel == "B-Spline"          ? [1.0,0.0]   : c
    c = kernel == "BSpline"           ? [1.0,0.0]   : c
    c = kernel == "BCSpline"          ? [0.5,0.5]   : c
    c = kernel == "BC-Spline"         ? [0.5,0.5]   : c
    c = kernel == "CSpline"           ? [0.0,1.0]   : c
    c = kernel == "C-Spline"          ? [0.0,1.0]   : c
    c = kernel == "Didée"             ? [-0.5,0.25] : c
    c = kernel == "Dide"              ? [-0.5,0.25] : c

    c }


# JPEGs uses Rec.601 primaries, PC Levels, MPEG1 chroma placement, and can be many formats; from RGB to 420, 422 being to spec, but also 440*, 444, 411, etc
#*YUV440 or YUVJ440 are for rotated versions of 422 (rotated JPEG)
# Photoshop saves as 420 up to level 6, 422 for above

function chroma_placement (int w, int h, int nw, int nh, string matrix_i, string matrix_o, string format_i, string format_o, string jab_i, string jab_o, string "cplace_in", string "cplace_out") {

    ryw = w  / float(nw)       # source/target Y  dimensions
    ryh = h  / float(nh)

    # Input Jab to chroma units
    eps= 0.001
    a  = Eval(MidStr(jab_i, 2, 1))
    b  = Eval(MidStr(jab_i, 3, 1))
    iu =                       a  / 8.         # chroma units/pixels for U dimension in respect to luma units
    iv = (round((b/(b+eps))) + 1) / 4.         # chroma units/pixels for V dimension in respect to luma units

    # Output Jab to chroma units
    a  = Eval(MidStr(jab_o, 2, 1))
    b  = Eval(MidStr(jab_o, 3, 1))
    ou =                       a  / 8.         # chroma units/pixels for U dimension in respect to luma units
    ov = (round((b/(b+eps))) + 1) / 4.         # chroma units/pixels for V dimension in respect to luma units

                         # source chroma placement defaults
                         # top_left is always on 4:2:0 by spec
    dplacei= FindStr(format_i,"RGB")>0      ? "center"   : \
             format_i == "YUV444"           ? "center"   : \
             FindStr(matrix_i,"2020")>0     ? "top_left" : \
             FindStr(matrix_i,"2100")>0     ? "top_left" : \
             FindStr(format_i,"YcCbcCrc")>0 ? "top_left" : \
             FindStr(format_i,"ICtCp")>0    ? "top_left" : \
             format_i == "YUV420"           ? "MPEG2"    : \
             format_i == "YUV422"           ? "MPEG2"    : \
             format_i == "YUV411"           ? "MPEG1"    : \
             format_i == "YUV410"           ? "DV"       : "MPEG2"

                         # out chroma placement defaults
    dplaceo= FindStr(format_o,"RGB")>0      ? "center"   : \
             format_o == "YUV444"           ? "center"   : \
             FindStr(matrix_o,"2020")>0     ? "top_left" : \
             FindStr(matrix_o,"2100")>0     ? "top_left" : \
             FindStr(format_o,"YcCbcCrc")>0 ? "top_left" : \
             FindStr(format_o,"ICtCp")>0    ? "top_left" : \
             format_o == "YUV420"           ? "MPEG2"    : \
             format_o == "YUV422"           ? "MPEG2"    : \
             format_o == "YUV411"           ? "MPEG1"    : \
             format_o == "YUV410"           ? "DV"       : "MPEG2"

    cplacei = cplace_in =="" ? dplacei : Default (cplace_in,  dplacei)
    cplaceo = cplace_out=="" ? dplaceo : Default (cplace_out, dplaceo)

    cplacei = cplacei == "center"       ? "MPEG1"    : \
              cplacei == "JPEG"         ? "MPEG1"    : \
              cplacei == "JPG"          ? "MPEG1"    : \
              cplacei == "DV"           ? "top_left" : \
              FindStr(cplacei,"2020")>0 ? "top_left" : \
              FindStr(cplacei,"2100")>0 ? "top_left" : \
              cplacei == "left"         ? "MPEG2"    : cplacei

    cplaceo = cplaceo == "center"       ? "MPEG1"    : \
              cplaceo == "JPEG"         ? "MPEG1"    : \
              cplaceo == "JPG"          ? "MPEG1"    : \
              cplaceo == "DV"           ? "top_left" : \
              FindStr(cplaceo,"2020")>0 ? "top_left" : \
              FindStr(cplaceo,"2100")>0 ? "top_left" : \
              cplaceo == "left"         ? "MPEG2"    : cplaceo

    # Scale chroma units (MPEG1 aware)
    scloc  = cplacei == "MPEG2"       ? [-iu,  0.0]  : \
             cplacei == "MPEG1"       ? [ iu,   iv]  : \
             cplacei == "top_left"    ? [ 0.0, 0.0]  : \
             cplacei == "bottom_left" ? [ 0.0, iv*2] : \
             Assert (false, "chroma_placement: Unsupported chroma placement mode.")

    # In chroma units
    icloc  = cplacei == "MPEG2"       ? [-ou,  0.0]  : \
             cplacei == "MPEG1"       ? [ ou,   ov]  : \
             cplacei == "top_left"    ? [ 0.0, 0.0]  : \
             cplacei == "top"         ? [ ou,  0.0]  : \
             cplacei == "bottom_left" ? [ 0.0, ov*2] : \
             cplacei == "bottom"      ? [ ou,  ov*2] : \
             Assert (false, "chroma_placement: Unsupported chroma placement mode.")

    # Out chroma units [third item is _ChromaLocation index for frameprops]
    ocloc  = cplaceo == "MPEG2"       ? [-ou,  0.0,  0] : \
             cplaceo == "MPEG1"       ? [ ou,   ov,  1] : \
             cplaceo == "top_left"    ? [ 0.0, 0.0,  2] : \
             cplaceo == "top"         ? [ ou,  0.0,  3] : \
             cplaceo == "bottom_left" ? [ 0.0, ov*2, 4] : \
             cplaceo == "bottom"      ? [ ou,  ov*2, 5] : \
             Assert (false, "chroma_placement: Unsupported chroma placement mode.")

    [-scloc[0]*(1-ryw)+(ocloc[0]-icloc[0]), -scloc[1]*(1-ryh)+(ocloc[1]-icloc[1]), ocloc[2]] }




# NTSC and PAL YCbCr (Rec601 and BT-470BG) share the same coefficients defined in (https://poynton.ca/PDFs/coloureq.pdf - 10.4),
# and derived from the old SMPTE 470M (NTSC 1953) standard. Exactly:
# kr: 0.298903070250081
# kg: 0.586619854659197
# kb: 0.114477075090722
# And for Rec709:
# kr: 0.21264933049678802
# kg: 0.71516913175582890
# kb: 0.07218152284622192
function Matrix_coef (string matrix, string "illuminant") {

    illuminant = Default(illuminant, matrix)

    mat_i =
\     (matrix == "sRGB"           ) ? 1
\   : (matrix == "170M"           ) ? 0
\   : (matrix == "Rec709"         ) ? 1
\   : (matrix == "Rec2020CL"      ) ? 5
\   : (matrix == "Rec2020NCL"     ) ? 5
\   : (matrix == "AdobeRGB"       ) ? 6
\   : (matrix == "AWG"            ) ? 7
\   : (matrix == "Display-P3"     ) ? 8
\   : (matrix == "DCI-P3"         ) ? 9
\   : (matrix == "ACEScg"         ) ? 10
\   : (matrix == "ACESCCt"        ) ? 10
\   : (matrix == "ACES2065"       ) ? 11
\   : (matrix == "240M"           ) ? 3
\   : (matrix == "470BG"          ) ? 0 : 1
# * Deriving Rec709 matrix coefficients from its primaries is noted as BT.709-2, in contrast to older and slightly different BT.709-1

    mat_wp =
\     (matrix == "170M"           ) ? 1
\   : (matrix == "Rec709"         ) ? 1
\   : (matrix == "DCI-P3"         ) ? 3
\   : (matrix == "ACES2065"       ) ? 4
\   : (matrix == "ACEScg"         ) ? 4
\   : (matrix == "AWG"            ) ? 2
\   :                                 1

    # The coordinates and CCT's are from CIE 1931 2 degree standard observer
    mat_wp =
\     (illuminant == "D50"        ) ? 2
\   : (illuminant == "D55"        ) ? 5
\   : (illuminant == "D60"        ) ? 4
\   : (illuminant == "DCI"        ) ? 3
\   : (illuminant == "D65"        ) ? 1
\   : (illuminant == "C"          ) ? 0
\   : (illuminant == "D75"        ) ? 6
\   : (illuminant == "D93"        ) ? 7 : mat_wp
# * D93 is not a D standard illuminant. Here it is defined for CCT (correlated) to consumer's TV standard "9300K+27 MPCD". "9300K+8 MPCD" for master CRT corresponds to 0.2838, 0.2984

    # Hardcode constants for the Kr, Kg, Kb derivations
    mat_w =
\     (matrix == "170M"           ) ? 0
\   : (matrix == "470BG"          ) ? 0
\   : (matrix == "AWG"            ) ? 2 : mat_wp


    #                     NTSC 1953/YCbCr   ITU-R BT.709-6/sRGB ITU-R BT.601     YPbPr 601        PAL/SECAM         BT-2020/BT-2100   Adobe RGB (1998)  Adobe Wide Gamut   Display-P3/D65P3  DCI-P3            AP1                AP0                D55                D75                D93
    #                     BT-470M/FCC       IEC 61966-2-1       SMPTE 170M       SMPTE 240M        BT-470BG          BT-2020/BT-2100   Adobe RGB (1998)  AWG                SMPTE RP 432-1    SMPTE RP 431-2    ACEScg/ACEScct     SMPTE ST 2065-1    D55                D75                9300K+27 MPCD
    pr  = Select (mat_i,  [0.670,  0.330],  [0.640, 0.330],    [0.630,  0.340],  [0.630,  0.340],  [0.640,  0.330],  [0.708,  0.292],  [0.640,  0.330],  [0.73469,0.26531], [0.680,  0.320],  [0.680,  0.320],  [0.713,   0.293],  [0.7347,  0.2653])
    pg  = Select (mat_i,  [0.210,  0.710],  [0.300, 0.600],    [0.310,  0.595],  [0.310,  0.595],  [0.290,  0.600],  [0.170,  0.797],  [0.210,  0.710],  [0.11416,0.82621], [0.265,  0.690],  [0.265,  0.690],  [0.165,   0.830],  [0.0000,  1.0000])
    pb  = Select (mat_i,  [0.140,  0.080],  [0.150, 0.060],    [0.155,  0.070],  [0.155,  0.070],  [0.150,  0.060],  [0.131,  0.046],  [0.150,  0.060],  [0.15664,0.01770], [0.150,  0.060],  [0.150,  0.060],  [0.128,   0.044],  [0.0001, -0.0770])
    pw  = Select (mat_w,  [0.31006,0.31616],[0.312713, 0.329016],                                                                                        [0.34567,0.35850],                   [0.314,  0.351],  [0.32168,0.33767]                   , [0.33242, 0.34743],[0.29902, 0.31485],[0.281, 0.311])
    wp  = Select (mat_wp, [0.31006,0.31616],[0.312713, 0.329016],                                                                                        [0.34567,0.35850],                   [0.314,  0.351],  [0.32168,0.33767]                   , [0.33242, 0.34743],[0.29902, 0.31485],[0.281, 0.311])
    Kv  = Select (mat_wp,  6774.202        , 6504.13            ,                                                                                         5001.668        ,                    6304.573      ,   6000.211                           ,  5502.33          , 7506.16          , 8941.864     )

    pr = [pr[0], pr[1], 1 - pr[0] - pr[1]]
    pb = [pb[0], pb[1], 1 - pb[0] - pb[1]]
    pg = [pg[0], pg[1], 1 - pg[0] - pg[1]]
    pw = [pw[0], pw[1], 1 - pw[0] - pw[1]]
    wp = [wp[0], wp[1], 1 - wp[0] - wp[1]]

    det = pw[1] * Dot([pr[0],pg[0],pb[0]], Cross([pr[1],pg[1],pb[1]], [pr[2],pg[2],pb[2]]))
    kr  = pr[1] * Dot(pw, Cross(pg, pb)) / det
    kb  = pb[1] * Dot(pw, Cross(pr, pg)) / det
    kg  = 1 - kb - kr

    [kr, kg, kb, wp[0], wp[1], wp[2]] }


# Should pass through Color_Fuzzy_search() for string normalizing
function moncurve_coef (string transfer) {

    t_num =
\     (transfer == "sRGB"         ) ? 0
\   : (transfer == "Display-P3"   ) ? 0
\   : (transfer == "170M"         ) ? 1
\   : (transfer == "Rec601"       ) ? 1
\   : (transfer == "Rec709-Camera") ? 1
\   : (transfer == "Rec2020NCL"   ) ? 1
\   : (transfer == "Rec2020CL"    ) ? 1
\   : (transfer == "Rec2020"      ) ? 1
\   : (transfer == "240M"         ) ? 2
\   : (transfer == "470BG"        ) ? 3
\   : (transfer == "Rec709"       ) ? 4
\   : (transfer == "1886"         ) ? 4
\   : (transfer == "AdobeRGB"     ) ? 5
\   : (transfer == "AWG"          ) ? 5
\   : (transfer == "DCIXYZ"       ) ? 6
\   : (transfer == "linear"       ) ? 7
\   : (transfer == "470M"         ) ? 8
\   : (transfer == "1886a"        ) ? 9
\   : (transfer == "xvYCC"        ) ? -1
\   : (transfer == "PQ"           ) ? -1
\   : (transfer == "HLG"          ) ? -1 : 4


       /* Coeff Derivations:
          BT.2020/SMPTE 170M "simultaneous equations" require brute force root-finding algos (ie. bisection method)
          Added only as reference here since moncurve_x() functions compute them correctly from "alpha" coeff.

        #   alpha = offset     (x coord - 1)
        #   beta  = transition (y coord)= K0/Phi
        #   phi   = slope
        #   k0    = beta * phi or alpha / (gam-1)
                                                                      #  SMPTE 240M
        #   BT.2020/SMPTE 170M                                        #  piece+slope match
        #   phi*y = a*b^igam-x+1                                      #  k0  = a / (gam-1)
        #   phi   = igam*a*b^(igam-1)                                 #  phi = (((1+a)^gam)*(gam-1)^(gam-1))/((a^(gam-1))*gam^gam)
            gamma = 1/0.45                                               gamma = 1/0.45 = 2.2222
            alpha = 0.099296826809442940347282759                        alpha = 0.1115
            beta  = 0.018053968510807807335869592                        beta  = 0.02280681818181818182
            k0    = 0.081242858298635133011413164                        k0    = 0.09122727272727272727
            phi   = 4.5                                                  phi   = 4.0

        #   sRGB                                                      #  sRGB
        #   piece+slope match                                         #  piece match
        #   k0  = a / (gam-1)                                         #  phi*b = a*b^igam-a+1
        #   phi = (((1+a)^gam)*(gam-1)^(gam-1))/((a^(gam-1))*gam^gam) #  phi   = igam*a*b^(igam-1)
            gamma = 2.40                                                 gamma = 2.40
            alpha = 0.055                                                alpha = 0.05501071894758659721
            beta  = 0.00303993463977843                                  beta  = 0.00304128256012752085
            k0    = 0.03928571428571428571                               k0    = 0.039293370676847569382
            phi   = 12.92321018078786109464                              phi   = 12.92
            */

    #                                                SMPTE-C    / BT-2020           YPbPr 601              PAL/SECAM                      Rec.709  AdobeRGB  DCI-P3      AP1/AP0   NTSC 1953/YCbCr Rec.709
    #                       sRGB                     SMPTE 170M / BT-2020           SMPTE 240M              BT-470BG (historical)          BT-1886  AdobeRGB  DCI-P3/XYZ  ACES/LIN  BT-470M/FCC     BT-1886a (more CRT alike)
    t_gamma = Select(t_num, 2.40                   , 1/0.45                       , 1/0.45                , 2.80                         , 2.40   , 563/256., 2.60       , 1.0      , 2.2          , 2.60   )
    t_alpha = Select(t_num, 0.055                  , 0.099296826809442940347282759, 0.1115                , 0.099296826809442940347282759, 0      , 0       , 0          , 0        , 0            , 0      )
    t_beta  = Select(t_num, 0.00303993463977843    , 0.018053968510807807335869592, 0.02280681818181818182, 0.00410749063249639977       , 0      , 0       , 0          , 0        , 0            , 0.35/pow(0.35, 3.0-2.6))
    t_k0    = Select(t_num, 0.03928571428571428571 , 0.081242858298635133011413164, 0.09122727272727272727, 0.05516490378302385575       , 0      , 0       , 0          , 0        , 0            , 0.35   )
    t_phi   = Select(t_num, 12.92321018078786109464, 4.5                          , 4.0                   , 13.43031761206876179575      , 4.5    , 0       , 0          , 0        , 0            , pow(0.35, 3.0-2.6) )

    [t_gamma, t_alpha] }



function RGB_to_XYZ (clip rgb, string cspace, bool "list") {

    list = Default(list, false)

    matrix =        cspace == "sRGB"   || cspace == "Rec709"                                             ?  \
                                        [ 0.41241079568862915, 0.21264933049678802, 0.01933175697922707,    \
                                          0.35758456587791443, 0.71516913175582890, 0.11919485777616501,    \
                                          0.18045382201671600, 0.07218152284622192, 0.95039016008377080]  : \
                    cspace == "Rec601" || cspace == "170M" || cspace == "240M"                           ?  \
                                        [ 0.39354196190834045, 0.21238772571086884, 0.0187400933355093,     \
                                          0.36525884270668030, 0.70106136798858640, 0.1119341626763344,     \
                                          0.19164848327636720, 0.08655092865228653, 0.9582424163818359]   : \
                    FindStr(cspace, "ec2")>0                                                             ?  \
                                        [ 0.63697350025177000, 0.24840137362480164, 0.00000000000000000,    \
                                          0.15294560790061950, 0.67799961566925050, 0.04253686964511871,    \
                                          0.11785808950662613, 0.03913172334432602, 1.06084382534027100]  : \
                    cspace == "DCI-P3"                                                                   ?  \
                                        [ 0.44516983628273010, 0.20949168503284454, 0.00000000000000000,    \
                                          0.27713435888290405, 0.72159516811370850, 0.04706055670976639,    \
                                          0.17228263616561890, 0.06891304999589920, 0.90735518932342530]  : \
                    cspace == "Display-P3"                                                               ?  \
                                        [ 0.48659050464630127, 0.22898375988006592, 0.00000000000000000,    \
                                          0.26566821336746216, 0.69173991680145260, 0.04511347413063049,    \
                                          0.19819043576717377, 0.07927616685628891, 1.04380297660827640]  : \
                    cspace == "AdobeRGB"                                                                 ?  \
                                        [ 0.57666999101638790, 0.29734000563621520, 0.02703000046312809,    \
                                          0.18556000292301178, 0.62735998630523680, 0.07068999856710434,    \
                                          0.18822999298572540, 0.07529000192880630, 0.99133998155593870]  : \
                    cspace == "AWG"                                                                      ?  \
                                        [ 0.71650063991546630, 0.258728206157684300, 0.00000000000000000,   \
                                          0.10102055221796036, 0.724682152271270800, 0.05121181160211563,   \
                                          0.14677436649799347, 0.016589440405368805, 0.77389270067214970]:  \
                    cspace == "ACEScg"  ||  cspace == "ACESCCt"                                          ?  \
                                        [ 0.66332850000000000, 0.27258800000000000, 0.00000000000000000,    \
                                          0.13399166000000000, 0.67401860000000000, 0.00406035300000000,    \
                                          0.15532595000000000, 0.05339329000000000, 1.00476470000000000]  : \
                    cspace == "ACES2065"                                                                 ?  \
                                        [ 0.95253682136535640000,  0.34396082162857056, 0.0000000000000000, \
                                          0.00000000000000000000,  0.74020814895629880, 0.0000000000000000, \
                                          0.00010931033466476947, -0.08416896313428879, 1.0088251829147339]:\
                    cspace == "470BG"                                                                    ?  \
                                        [ 0.43057379126548767, 0.22201462090015410, 0.02018314599990845,    \
                                          0.34154993295669556, 0.70665508508682250, 0.12955342233181000,    \
                                          0.17832535505294800, 0.07133013755083084, 0.93918019533157350]  : \
                    cspace == "OPP"                                                                      ?  \
                                        [ 0.93410000000000000, -1.70130000000000000, 0.16770000000000000,   \
                                          0.94500000000000000,  0.49860000000000000, 0.05220000000000000,   \
                                          0.81570000000000000,  0.30470000000000000, 1.94220000000000000] : \
                    Assert(false,"RGB_to_XYZ: Unsupported Color Space.")

    list ? matrix : MatrixClip(rgb, matrix) }



function XYZ_to_RGB (clip rgb, string cspace, bool "list") {

    list = Default(list, false)

    matrix =        cspace == "sRGB"   || cspace == "Rec709"                                                ?  \
                                        [  3.24081254005432130, -0.96924304962158200,  0.055638398975133896,   \
                                          -1.53730857372283940,  1.87596631050109860, -0.204007431864738460,   \
                                          -0.49858659505844116,  0.04155505076050758,  1.057129383087158200] : \
                    cspace == "Rec601" || cspace == "170M" || cspace == "240M"                              ?  \
                                        [  3.5058159828186035, -1.06904542446136470,  0.05631496384739876,     \
                                          -1.7396978139877320,  1.97777497768402100, -0.19700492918491364,     \
                                          -0.5440292358398438,  0.035171352326869965, 1.05010843276977540]   : \
                    FindStr(cspace, "ec2")>0                                                                ?  \
                                        [  1.71660947799682620, -0.66668272018432620,  0.017642205581068993,   \
                                          -0.35566213726997375,  1.61647748947143550, -0.042776308953762054,   \
                                          -0.25336012244224550,  0.01576850563287735,  0.942228555679321300] : \
                    cspace == "DCI-P3"                                                                      ?  \
                                        [  2.72539401054382320, -0.7951681613922119,  0.041241902858018875,    \
                                          -1.01800286769866940,  1.6897321939468384, -0.087639048695564270,    \
                                          -0.44016319513320923,  0.0226471945643425,  1.100929737091064500]  : \
                    cspace == "Display-P3"                                                                  ?  \
                                        [  2.49339652061462400, -0.82948720455169680,  0.035850685089826584,   \
                                          -0.93134605884552000,  1.76266026496887200, -0.076182708144187930,   \
                                          -0.40269458293914795,  0.02362464182078838,  0.957014024257659900] : \
                    cspace == "AdobeRGB"                                                                    ?  \
                                        [  2.04158997535705570, -0.96924000978469850,  0.013439999893307686,   \
                                          -0.56501001119613650,  1.87597000598907470, -0.118359997868537900,   \
                                          -0.34472998976707460,  0.04156000167131424,  1.015169978141784700] : \
                    cspace == "AWG"                                                                         ?  \
                                        [  1.46230435371398930, -0.52286839485168460,  0.034600451588630676,   \
                                          -0.18452566862106323,  1.44798874855041500, -0.095819652080535890,   \
                                          -0.27338108420372010,  0.06812617927789688,  1.287660717964172400] : \
                    cspace == "ACEScg"  ||  cspace == "ACESCCt"                                             ?  \
                                        [  1.64102330000000000, -0.66387850000000000,  0.002682799000000000,   \
                                          -0.32480330000000000,  1.61551320000000000, -0.006528448000000000,   \
                                          -0.23642470000000000,  0.01678004000000000,  0.995190000000000000] : \
                    cspace == "ACES2065"                                                                    ?  \
                                        [  1.04982817173004150000, -0.48783543705940247, 0.0000000000000000,   \
                                           0.00000000000000000000,  1.35097146034240720, 0.0000000000000000,   \
                                          -0.00011375317990314215,  0.11276797950267792, 0.9912520051002502] : \
                    cspace == "470BG"                                                                       ?  \
                                        [  3.0632193088531494, -0.96924340724945070,  0.06787130981683731,     \
                                          -1.3933255672454834,  1.87596678733825680, -0.22883385419845580,     \
                                          -0.4758017063140869,  0.04155505821108818,  1.06925129890441900]   : \
                    cspace == "OPP"                                                                         ?  \
                                        [  0.24300000000000000,  0.85600000000000000, -0.04400000000000000,    \
                                          -0.45740000000000000,  0.42790000000000000,  0.02800000000000000,    \
                                          -0.03030000000000000, -0.42660000000000000,  0.52900000000000000]  : \
                    Assert(false,"XYZ_to_RGB: Unsupported Color Space.")

    list ? matrix : MatrixClip(rgb, matrix) }



# Chromatic Adaptation types:
# Bianco 2010
# Bianco PC 2010
# Bradford
# CAT02
# CAT02 Brill 2008
# CMCCAT2000
# CMCCAT97
# Fairchild
# Sharp
# Spectral-sharpened Bradford
# Von Kries (Hunt-Pointer-Estevez adjusted for D65)
# Von Kries (Hunt-Pointer-Estevez for equal energy)
# XYZ Scaling
#
# von Kries Chromatic Adaptation
# source and/or target can be a Primaries Color Space (ie. sRGB) or an illuminant (ie: D65)
function c_adaptation (clip c, string "source", string "target", bool "tv_range", bool "list", bool "fulls") {

    rgb     = IsRGB(c)
    propIDs = color_propGet(c)

    src    = Default (source,  propIDs[3])
    tgt    = Default (target, "D65")
    range  = Default (tv_range, !rgb)
    list   = Default (list,    false)
    fs     = Default (fulls,  !propIDs[6])


    src    = list ? src : Color_Fuzzy_search (src)
    tgt    = list ? tgt : Color_Fuzzy_search (tgt)
    wps    = Matrix_coef(src)
    wpt    = Matrix_coef(tgt)
    same   = wps[3] == wpt[3]

    CAT02  = [0.7328,  0.4296, -0.1624, \
             -0.7036,  1.6975,  0.0061, \
              0.0030, -0.0136,  0.9834]

    wpsn   = MatrixDot([wps[3]/wps[4],1.,wps[5]/wps[4]], CAT02)
    wptn   = MatrixDot([wpt[3]/wpt[4],1.,wpt[5]/wpt[4]], CAT02)
    trans  = MatrixDiv(wptn,wpsn)
    vk     = [same?1.:trans[0],   0.0000,        0.0000,  \
              0.0000,   same?1.:trans[1],        0.0000,  \
              0.0000,            0.0000,same?1.:trans[2]]

    CAM    = !same ? MatrixDot(CAT02, MatrixDot(vk, MatrixInvert(CAT02))) : vk

    if (!list) {

        c
        s_gam  = moncurve_coef(src)

        RGBpln = rgb ? IsPlanar() : false

        rgb ? RGBpln ? last : ConvertToPlanarRGB() : \
        YUV_to_RGB(c, src, tv_range_in=range, tv_range_out=false, kernel="Point", fulls=fs)

        moncurve_f(s_gam[0], s_gam[1], false, false, 1)

        mata = RGB_to_XYZ (src, list=true)
        matb = XYZ_to_RGB (src, list=true)
        MatrixClip( MatrixDot(MatrixDot(mata, CAM), matb) )

        moncurve_r(s_gam[0], s_gam[1], false, false, 1)

        rgb ? RGBpln ? last : MatchClip(c) : \
        RGB_to_YUV( src, tv_range_in=false, tv_range_out=range, kernel="Point", pixel_type=PixelType(c), fulls=fs)
        same ? c : last

    } else { CAM } }




####### ARRAY FUNCTIONS #######

function ExtractClip ( clip clp) {

    isY  (clp) ? [         clp,          clp,          clp ] : \
    isRGB(clp) ? [ExtractR(clp),ExtractG(clp),ExtractB(clp)] : \
                 [ExtractY(clp),ExtractU(clp),ExtractV(clp)] }


function MatrixClip ( clip clp, float_array mat) {

    CLPa = ExtractClip(clp)

    # clip · 3x3
    Expr(CLPa[0], CLPa[1], CLPa[2], "x "+string(mat[0])+" * y "+string(mat[3])+" * + z "+string(mat[6])+" * +", \
                                    "x "+string(mat[1])+" * y "+string(mat[4])+" * + z "+string(mat[7])+" * +", \
                                    "x "+string(mat[2])+" * y "+string(mat[5])+" * + z "+string(mat[8])+" * +", optSingleMode=true, format=PixelType(clp)) }


function DotClip ( clip clp, float_array vec) {

    CLPa = ExtractClip(clp)

    # clip · 1x3
    Expr(CLPa[0], \
         CLPa[0], \
         CLPa[0], "x "+string(vec[0])+" * y "+string(vec[1])+" * + z "+string(vec[2])+" * +", optSingleMode=true) }


function DotClipA ( clip_array clp, float_array vec) {

    # clipA · 1x3
    Expr(clp[0], \
         clp[1], \
         clp[2], "x "+string(vec[0])+" * y "+string(vec[1])+" * + z "+string(vec[2])+" * +", optSingleMode=true) }


function MatrixDot ( float_array mat1, \
                     float_array mat2) {
    # 1x3 · 3x3
    if (ArraySize(mat1) == 3) {
        ar1 = Dot([mat1[0],mat1[1],mat1[2]],[mat2[0],mat2[1],mat2[2]])
        ar2 = Dot([mat1[0],mat1[1],mat1[2]],[mat2[3],mat2[4],mat2[5]])
        ar3 = Dot([mat1[0],mat1[1],mat1[2]],[mat2[6],mat2[7],mat2[8]])

       [ar1,ar2,ar3]
    }
    # 3x3 · 3x3
    else if (ArraySize(mat1) == 9) {
        ar1 = Dot([mat1[0],mat1[1],mat1[2]],[mat2[0],mat2[3],mat2[6]])
        ar2 = Dot([mat1[0],mat1[1],mat1[2]],[mat2[1],mat2[4],mat2[7]])
        ar3 = Dot([mat1[0],mat1[1],mat1[2]],[mat2[2],mat2[5],mat2[8]])
        ar4 = Dot([mat1[3],mat1[4],mat1[5]],[mat2[0],mat2[3],mat2[6]])
        ar5 = Dot([mat1[3],mat1[4],mat1[5]],[mat2[1],mat2[4],mat2[7]])
        ar6 = Dot([mat1[3],mat1[4],mat1[5]],[mat2[2],mat2[5],mat2[8]])
        ar7 = Dot([mat1[6],mat1[7],mat1[8]],[mat2[0],mat2[3],mat2[6]])
        ar8 = Dot([mat1[6],mat1[7],mat1[8]],[mat2[1],mat2[4],mat2[7]])
        ar9 = Dot([mat1[6],mat1[7],mat1[8]],[mat2[2],mat2[5],mat2[8]])

       [ar1,ar2,ar3,ar4,ar5,ar6,ar7,ar8,ar9]  }  }


function MatrixInvert (float_array mat) {

    Det = (mat[0]*((mat[8]*mat[4])-(mat[7]*mat[5]))) - \
          (mat[3]*((mat[8]*mat[1])-(mat[7]*mat[2]))) + \
          (mat[6]*((mat[5]*mat[1])-(mat[4]*mat[2])))

           ar1 =  ((mat[8]*mat[4])-(mat[7]*mat[5]))/Det
           ar2 = -((mat[8]*mat[1])-(mat[7]*mat[2]))/Det
           ar3 =  ((mat[5]*mat[1])-(mat[4]*mat[2]))/Det
           ar4 = -((mat[8]*mat[3])-(mat[6]*mat[5]))/Det
           ar5 =  ((mat[8]*mat[0])-(mat[6]*mat[2]))/Det
           ar6 = -((mat[5]*mat[0])-(mat[3]*mat[2]))/Det
           ar7 =  ((mat[7]*mat[3])-(mat[6]*mat[4]))/Det
           ar8 = -((mat[7]*mat[0])-(mat[6]*mat[1]))/Det
           ar9 =  ((mat[4]*mat[0])-(mat[3]*mat[1]))/Det

           [ar1,ar2,ar3,ar4,ar5,ar6,ar7,ar8,ar9] }


function MatrixTranspose (float_array mat) {

  [mat[0],mat[3],mat[6],\
   mat[1],mat[4],mat[7],\
   mat[2],mat[5],mat[8]] }


function Cross (float_array vec1, \
                float_array vec2) {
    # 1x3 X 1x3
    cr1 = vec1[1] * vec2[2] - vec1[2] * vec2[1]
    cr2 = vec1[2] * vec2[0] - vec1[0] * vec2[2]
    cr3 = vec1[0] * vec2[1] - vec1[1] * vec2[0]

    [cr1, cr2, cr3] }


function Dot (float_array vec1, \
              float_array vec2) {
    # 1x3 · 1x3
    (vec1[0] * vec2[0]) + (vec1[1] * vec2[1]) + (vec1[2] * vec2[2]) }


function MatrixDiv ( float_array mat1, \
                     float_array mat2) {

    asize = ArraySize(mat1)
    str = ""
    for (i=0, asize, 1) {
        cm  = asize == i+1 ? "" : ","
        str = str + string(mat1[i] / mat2[i]) + cm
        i   = asize == i+1 ? asize : i
       }

    return Eval("["+str+"]") }


function MatrixMul ( float_array mat1, \
                     float_array mat2) {

    asize = ArraySize(mat1)
    str = ""
    for (i=0, asize, 1) {
        cm  = asize == i+1 ? "" : ","
        str = str + string(mat1[i] * mat2[i]) + cm
        i   = asize == i+1 ? asize : i
       }

    return Eval("["+str+"]") }


/*
# (LEGACY: since v3.7.1 test29)
function ArrayAdd( val_array "a", val_array "b") {

    as = ArraySize(a)-1
    bs = ArraySize(b)-1
    na = ""
    for (i = 0, as+bs+1, 1) {

        o  = i  - as  - 1
        cm = i != as+bs+1 ? "," : ""
        na = na + ( i > as ? String(Eval(Format("b[{o}]"))) : \
                             String(Eval(Format("a[{i}]")))) + cm
      }

    return Eval("["+na+"]") }
*/